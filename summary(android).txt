ffmpeg
SIP
Anychat for Android


ANRs (“Application Not Responding”)


将字符串转为整型，资源
    Field field=R.drawable.class.getField("icon");
    int drawable= field.getInt(new R.drawable());
	
	
如果自定义layout中有EditText，点击EditText会弹出输入法，此时会调用自定义layout或view的onMeasure方法，
所以，使用此策略可以监听输入法弹出

自定义view在xml中使用，通常会在objec(context, attrs)的构造方法中进入

修改代码时，若想要获取之前view的配置，例如图片、颜色、字号等，可以调试，获取之前view的信息，通过view查找配置

--------------------------------------------------------------

Px （Pixel像素）
也称为图像元素，是作为图像构成的基本单元，单个像素的大小并不固定，跟随屏幕大小和像素数量的关系变化
（屏幕越大，像素越低，单个像素越大，反之亦然）。所以在使用像素作为设计单位时，在不同的设备上可能会有缩放或拉伸的情况。
Resolution（分辨率）
是指屏幕的垂直和水平方向的像素数量，如果分辨率是 1920*1080 ，那就是垂直方向有 1920 个像素，水平方向有 1080 个像素。

Dpi（像素密度）
是指屏幕上每英寸（1英寸 = 2.54 厘米）距离中有多少个像素点。
如果屏幕为 320*240，屏幕长 2 英寸宽 1.5 英寸，Dpi = 320 / 2 = 240 / 1.5 = 160。

Density（密度）
这个是指屏幕上每平方英寸（2.54 ^ 2 平方厘米）中含有的像素点数量。
density=dpi/160

Dip / dp (设备独立像素)
也可以叫做dp，长度单位，同一个单位在不同的设备上有不同的显示效果，具体效果根据设备的密度有关，详细的公式请看下面 。

px = dp * (dpi / 160) = dp * density
dp = px / density

QVGA(320*240)分辨率
如果屏幕为 320*240，屏幕长 2 英寸宽 1.5 英寸，Dpi = 320 / 2 = 240 / 1.5 = 160。
wdp = 240/(160/160)   hdp = 320/(160/160)
Dpi有160，那么1dp等于1px，所以这个尺寸下的height dp是320，width dp是240


 	一英寸有多少点	density分辨
ldpi	120dpi		0.75
mdpi	160dpi		1
hdpi	240dpi		1.5
xhdpi	320dpi		2


这些术语都是指屏幕的分辨率。分辨率对应DPI
ldpi  QVGA (240×320)  Quarter VGA，即：VGA的四分之一，分辨率为320×240，一般用于小屏手机 
mdpi  HVGA (320×480)  Half-size VGA，即：VGA的一半，分辨率为480×320，
hdpi  WVGA (480×800),FWVGA (480×854)  Wide Video Graphics Array，即：扩大的VGA，分辨率为800×480像素
xhdpi  720P（1280*720）
xxhdpi 1080p（1920*1080 ）
xxxhdpi 4K（3840×2160）

VGA：Video Graphics Array，即：显示绘图矩阵，相当于640×480 像素；
WQVGA：Wide Quarter VGA，即：扩大的QVGA，分辨率比QVGA高，比VGA低，一般是：400×240，480×272；
FWVGA：Full Wide VGA ，数码产品屏幕材质的一种，VGA的另一种形式，比WVGA分辨率高，别名 ： Full Wide VGA, ，其分辨 率为854×480象素(16:9)。


代码：
public void getScreenDensity_ByWindowManager(){  
    DisplayMetrics mDisplayMetrics = new DisplayMetrics();//屏幕分辨率容器  
    getWindowManager().getDefaultDisplay().getMetrics(mDisplayMetrics);  
    int width = mDisplayMetrics.widthPixels;      // 像素宽度
    int height = mDisplayMetrics.heightPixels;    // 像素高度
    float density = mDisplayMetrics.density;	  // 获取屏幕密度density
    int densityDpi = mDisplayMetrics.densityDpi;  // 获取dpi
    Log.d(TAG,"Screen Ratio: ["+width+"x"+height+"],density="+density+",densityDpi="+densityDpi);  
    Log.d(TAG,"Screen mDisplayMetrics: "+mDisplayMetrics);  
}  


屏幕为 640*480，长4英寸*宽3英寸，Dpi是160，density是1，height dp是640，width dp是480
屏幕为 640*480，长2英寸*宽1.5英寸，Dpi=640/2=480/1.5=320，density=320/160=2，height dp是640/2=320，width dp是480/2=240
也就是说，相同分辨率下，尺寸越小，屏幕越高清，Dpi和density越大，dp反而越小

屏幕为 1280*960，长4英寸*宽3英寸，Dpi=320，density=2，height dp是640，width dp是480
屏幕为 2560*1920，长4英寸*宽3英寸，Dpi=640，density=4，height dp是2560/4=640，width dp是1920/4=480
对比640*480、1280*960、2560*1920，相同尺寸下(长4*宽3)，分辨率越大，屏幕越高清，Dpi和density越大，dp相等

dpi与dp是不成比关系的，dp具体大小要结合，由 dpi的大小、px的大小 共同决定


--------------------------------------------------------------

listview继承自AbsListView，AbsListView中封装了对view的回收处理，使用setRecyclerListener对view被回收时做出处理

------------------------------------------------------------------------------------------------------------

在使用listview，recycleview等进行嵌套时，系统本身不会对里面的listview进行宽高计算，所以要手动计算宽高，并设置里面的listview

------------------------------------------------------------------------------------------------------------

自定义view中重写onTouchEvent，返回false，则该控件不响应点击，
例如在RelativeLayout, FrameLayout中摆放一些控件，再在最顶层摆放一个覆盖布局的控件，
此时如果在onTouchEvent中返回flase则该控件不处理touch，并且底层控件可以处理touch事件
注：RelativeLayout也可以像FrameLayout那样有层级关系，xml中写在最下面的控件位于最顶层，code中最后加入的view位于最顶层

即使是在自定义view中重写onTouchEvent，他所响应到的区间也是他的父布局，即所产生的坐标是父布局的相对坐标而不是整个屏幕绝对的坐标，
所以对自定义view的TouchEvent做出响应，应该判断是不是view的区间
在view 的OnTouchListener事件中，若返回FALSE则继续向上传递，若返回TRUE则由监听方法处理
即如果想要处理move移动事件或者up弹起事件要返回TRUE
有些控件，例如checkbox，即使不设置click监听也会对点击作出响应，这时需要在控件中加入
android:focusable="false"
android:focusableInTouchMode="false"
此时就会和listview本身的点击互不影响


------------------------------------------------------------------------------------------------------------------------

从 Android 6.0（API 级别 23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。
此方法可以简化应用安装过程，因为用户在安装或更新应用时不需要授予权限。
系统权限分为两类：正常权限和危险权限：
正常权限不会直接给用户隐私权带来风险。如果您的 app在其 manifest 中列出了正常权限，系统将自动授予该权限。
危险权限会授予应用访问用户机密数据的权限。如果您列出了危险权限，则用户必须明确批准您的应用使用这些权限。

在所有版本的 Android 中，都需要在其应用manifest中同时声明它需要的正常权限和危险权限
该声明的影响因系统版本和应用的目标 SDK 级别的不同而有所差异
如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您在清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。
如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。

也就是说，在高于Android 6.0版本，那么需要在manifest配置权限，并且如果权限是危险权限的话，
那么还需要在程序中调用checkSelfPermission() 和 requestPermissions()来检查和动态申请权限


------------------------------------------------------------------------------------------------------------------------

可以在canvas中通过控制矩阵Matrix来控制旋转rotate和缩放scale
在使用Matrix处理bitmap旋转、缩放、平移时，平移会和旋转、缩放冲突，导致只能执行其中一个，
可以先使用Matrix.setTranslate设置平移距离，再使用Matrix.postRotate、Matrix.postScale来处理冲突问题

------------------------------------------------------------------------------------------------------------
				
scroll的三大状态(能滑动的控件，listview，gridview，recycleview都有)： SCROLL_STATE_IDLE, SCROLL_STATE_DRAGGING or SCROLL_STATE_SETTLING.
IDLE指的是控件没有在滑动(SCROLL_STATE_IDLE为0)
DRAGGING指的是控件在滑动，手指在屏幕上移动(SCROLL_STATE_DRAGGING为1)
SETTLING指的是控件在滑动，手指已经放开屏幕，控件处于自动的动画滑动中(SCROLL_STATE_SETTLING为2)

------------------------------------------------------------------------------------------------------------


android:launchMode 由以下几个：
“standard” ， “singleTop” ， “singleTask” ， “singleInstance”
默认模式是“standard”

这些模式分为两大类，“standard”和“singleTop”Activity 为一类，“singleTask”和“singleInstance”为另一类。

使用“standard”或“singleTop”启动模式的 Activity 可多次实例化（也就是允许有多个这种activity）

（1） “standard”和“singleTop”模式只在一个方面有差异：
当 startActivity() 时 , “standard”Activity”，系统都会创建新的类实例Activity 来响应 该Intent ;
如果目标任务在其堆栈顶部已有一个 “singleTop”Activity 实例，那么该实例将接收新 Intent（通过调用 onNewIntent()）不会创建新实例
如果“singleTop”Activity没有位于顶部，则会创建新的activity

（2） “singleTask”和“singleInstance”Activity 只能启动任务。 它们始终位于 Activity 堆栈的根位置。
此外，设备一次只能保留一个 Activity 实例 — 只允许一个此类任务。（也就是只有一个存在于栈task中）

“singleTask”和“singleInstance”模式同样只在一个方面有差异： “singleTask”Activity 允许其他 Activity 成为其任务的组成部分。
 “singleInstance”Activity 则不允许其他 Activity 成为其任务的组成部分。它是任务中唯一的 Activity。 

 singleTask始终位于其任务的根位置，但其他 Activity（必然是“standard”和“singleTop”Activity）可以启动到该任务中。
 如果singleInstance 启动另一个 Activity，系统会将该 Activity 分配给其他任务 — 就好像 Intent 中包含 FLAG_ACTIVITY_NEW_TASK 一样。

如果已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向 singleTask和singleInstance 传送 Intent，而不是创建新的 Activity 实例


（3）普通的activity直接用默认的standard就可以，但是主页 HomeActivity 或者 MainActivity 这种 位于第一级页面的 activity最好是singleTask
1.避免重复创建activity的开销，
2.也方便保存离开时的状态，回到首页之后还是之前的状态，
3.还有个优点是返回首页时，因为只有一个，所以不会出现在 HomeActivity点击 back键还有一个 HomeActivity的情况

而通过onNewIntent与之进行数据状态交互


(4) singleTask会对home机制有影响，如果在不是主页的页面按下home键，接着点击 启动按钮，这时候会进入HomeActivity而不是上一次home键退出app的的页面。


(5) 遇到过的问题：
    1.  activity(singleTask模式)是主入口，再多设置一个启动方式activity-alias，一共有两个启动图标。
    无论点哪一个启动图标，通过getIntent().getComponent().getClassName()拿到的name都不对，
    但是onNewIntent()拿到的 name是对的，原因是getIntent()是第一次启动传入的那个intent，一直都不会被替换。
    在activity的onNewIntent()调用setIntent()把新传入的intent设置进去就可以了


-----------------------

Task的概念
Task (Activity任务堆栈)(A task is a stack of activities.) 
task是一个具有栈结构的容器，可以放置多个Activity实例
默认情况下，一个应用内的所有Activity都具有相同的affinity，
都是从Application继承而来，而Application默认的affinity是<manifest>中的包名，
我们可以为<application>设置taskAffinity属性值，这样可以应用到<application>下的所有<activity>，
也可以单独为某个Activity设置taskAffinity。
FLAG_ACTIVITY_NEW_TASK：当Intent对象包含这个标记时，系统会寻找或创建一个新的task来放置目标Activity，
寻找时依据目标Activity的taskAffinity属性进行匹配，如果找到一个task的taskAffinity与之相同，
就将目标Activity压入此task中，如果查找无果，则创建一个新的task。

启动一个应用，系统就会为之创建一个task，来放置根Activity；默认情况下，
一个Activity启动另一个Activity时，两个Activity是放置在同一个task中的，后者被压入前者所在的task栈，
当用户按下后退键，后者从task被弹出，前者又显示在幕前，特别是启动其他应用中的Activity时，两个Activity对用户来说就好像是属于同一个应用；
系统task和task之间是互相独立的，当我们运行一个应用时，按下Home键回到主屏，启动另一个应用，这个过程中，之前的task被转移到后台，
新的task被转移到前台，其根Activity也会显示到幕前，过了一会之后，在此按下Home键回到主屏，再选择之前的应用，
之前的task会被转移到前台，系统仍然保留着task内的所有Activity实例，而那个新的task会被转移到后台，如果这时用户再做后退等动作，
就是针对该task内部进行操作了。

------------------------------------------------------------------------------------------------------------

android 可以使用Thread.currentThread().getId()或者
Thread.currentThread().getName()来确定当前线程，

如果是主线程的话，getName()拿到的是 "main"
如果是子线程，例如 new HandlerThread("backgroundThread”)
或者 Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
            }
        }, "backgroundThread");
那么getName() 拿到的就是 "backgroundThread"

------------------------------------------------------------------------------------------------------------

handler looper HandlerThread解析

1. 一个Thread线程绑定一个looper，一个looper绑定一个MessageQueue（消息队列）
   普通的线程的looper如果没有创建: Looper.prepare(), 一般都是空值
   
2. UI主线程有looper，是这么创建的：
   在Activity中，维护一个ActivityThread，其静态方法main，
   调用Looper.prepareMainLooper()，再创建Handler（sMainThreadHandler），再调用Looper.loop()
   
3. Handler 必须要和 Looper 中结合使用，尤其在子线程中创建 Handler，也需要三个步骤：
   Looper.prepare() -> new Handler() -> Looper.loop()
   3.1 Looper.prepare()创建looper, looper的构造 再创建MessageQueue，
   3.2 Handler的构造方法取looper，如果拿到的looper为空会报错, 取到looper会再取消息队列MessageQueue
   3.3 Looper.loop()是个死循环，不断在MessageQueue取出任务并 分发msg.target.dispatchMessage(msg)，（这里的target是handler对象）

4. 当Handler.sendEmptyMessage调用时，消息队列MessageQueue 将消息对象 入队queue.enqueueMessage(msg, uptimeMillis)
   结合 3.3，入队的消息会被 handler.dispatchMessage 执行, 而dispatchMessage调用的正是 handleMessage方法

5. UI线程也是如此，如果在UI线程中创建了Handler，那么这个Handler使用的就是属于主线程的 looper和消息队列

6. HandlerThread继承自Thread，其中已经实现了
   looper的创建 -> 调用onLooperPrepared -> 执行loop消息死循环
   如果想要控制一个消息队列，那么就需要在HandlerThread中创建 Handle，
   可以重写onLooperPrepared() 并在其中 new Handler(getLooper(), new Callback({handleMessage(Message msg)}) );
   注意，此时的 handleMessage()是属于 子线程的

小结：
一条线程只有 一个Looper和一个MessageQueue，主线程创建的handle持有主线程的消息队列。
子线程里也可以实现消息队列，需要自己创建looper和handle。HandlerThread就是一个已经实现了looper的线程




------------------------------------------------------------------------------------------------------------

主线程中创建handler，主要用来修改UI界面
Handler handler;
onCreate
{
	handler=new Handler();
}
//接着在任意地方
handler.post(new runable(可以传入参数));
//定义一个Runnable
private class runable implements Runnable
    {
        //构造方法
        private runable()
        {
        }
//实例化Runnable借口必须实现的
        @Override
        public void run(){
        }
    }
	

通过使用message调用handle
        Handler mHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
            }
        };
调用：
mHandler.sendEmptyMessage(0);
注：一般发送的是Message，在handleMessage()方法中判断Message，执行不同的代码段


在android使用handler.post(runnable)，并不会开启新的线程，而是将消息压到main线程使用的消息池中，
所以handler.post还是在主线程中，

而使用  Thread thread = new Thread(runnable);thread.start(); 才是开启一个新的线程，
 
  而使用以下发送Message的方法也是在主线程当做执行
            Handler handler = new Handler(new Handler.Callback() {
                @Override
                public boolean handleMessage(Message msg) {
                    Log.w("sendEmptyMessage",Thread.currentThread().getName());
                    return false;
                }
            });
            handler.sendEmptyMessage(1);

即使是在线程中发送消息，最后handle的执行也是在主线程当中
            final Handler handler = new Handler(new Handler.Callback() {
                @Override
                public boolean handleMessage(Message msg) {
                    Log.w("runnable2",Thread.currentThread().getName());
                    return false;
                }
            });
            Runnable runnable2 = new Runnable() {
                @Override
                public void run() {
                    handler.sendEmptyMessage(1);
                }
            };
            Thread thread = new Thread(runnable2);
            thread.start();

可以使用特殊线程HandlerThread,可以很好的和handle结合在一起使用
            mWorkThread = new HandlerThread("threadname");
            mWorkThread.start();
            Handler workHandler = new Handler(mWorkThread.getLooper(), new Handler.Callback() {
                @Override
                public boolean handleMessage(Message msg) {
                    return false;
                }
            });
            workHandler.sendEmptyMessage(1);
			
			
综上，加载数据使用Thread开启一个线程，加载完成之后，在线程当中send或者post，handle消息，
通知主线程修改界面。

------------------------------------------------------------------------------------------------------------

android进程通讯，IPC

一、AIDL(Android Interface Definition Language)
android基于linux内核，所以进程管理也是linux那一套，进程之间是相互独立的互不干扰的，数据是独享的，所以要进行进程间的通信也是通过Binder机制去搞，而android的AIDL底层也是基于Binder机制的，只不过封装的比较好，android开发不需要知道Binder机制也能使用AIDL跨进程开发，只需要遵循一定的流程，一一步步创建就好；由于android的每个app对应一个独立进程，要想跨应用访问共享数据，那就得掌握进程间的通信。 Android中的跨进程服务其实是采用C/S的架构，因而AIDL的目的就是实现通信接口。
AIDL是一种语言, 后缀 .aidl
-----------------------------
AIDL 支持的数据类型
共 4 种：
1. Java 的基本数据类型
2. List 和 Map, 元素必须是 AIDL 支持的数据类型, Server 端具体的类里则必须是 ArrayList 或者 HashMap
3. 其他 AIDL 生成的接口
4. 实现 Parcelable 的实体

-----------------------------
AIDL 如何编写
AIDL 的编写主要为以下三部分：
1. 创建 AIDL 
（1）创建要操作的实体类，实现 Parcelable 接口，以便序列化/反序列化
（2）新建 aidl 文件夹，在其中创建接口 aidl 文件以及实体类的映射 aidl 文件
（3）Make project ，生成 Binder 的 Java 文件

2. 服务端 
（1）创建 Service，在其中创建上面生成的 Binder 对象实例，实现接口定义的方法
（2）在 onBind() 中返回

3.客户端 
（1）实现 ServiceConnection 接口，在其中拿到 AIDL 类
（2）bindService()
（3）调用 AIDL 类中定义好的操作请求

-----------------------------

Parcel类，Parcel翻译过来是打包的意思,其实就是包装了我们需要传输的数据,然后在Binder中传输,也就是用于跨进程传输数据
简单来说，Parcel提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过Parcel可以从这块共享内存中读出字节流，并反序列化成对象,下图是这个过程的模型。
Parcel可以包含原始数据类型（用各种对应的方法写入，比如writeInt(),writeFloat()等），可以包含Parcelable对象，它还包含了一个活动的IBinder对象的引用，这个引用导致另一端接收到一个指向这个IBinder的代理IBinder。

Parcelable接口：
实现Parcelable接口可以对Parcel进行写入和恢复，实现Parcelable接口的类还必须有一个名为CREATOR的非null静态字段，该字段实现Parcelable.Creator接口。

序列化：将对象转换为可以传输的二进制流(二进制序列)的过程,这样我们就可以通过序列化,转化为可以在网络传输或者保存到本地的流(序列),从而进行传输数据 ,那反序列化就是从二进制流(序列)转化为对象的过程.Parcelable是Android为我们提供的序列化的接口,Parcelable相对于Serializable的使用相对复杂一些,但Parcelable的效率相对Serializable也高很多,这一直是Google工程师引以为傲的,有时间的可以看一下Parcelable和Serializable的效率对比 Parcelable vs Serializable 号称快10倍的效率

-----------------------------

AIDL 非常简单实例：
这个实例有两个app组成，一个服务端，一个客户端，
注意：android studio的调试是基于进程的，即使代码下了断点如果所在进程不同，是不会走到断点的，所以应该尽量使用log输出测试代码

总结：
 其实就是服务端实现一个普通的Service，客户端实现ServiceConnection去绑定。
 绑定完了就要通信，继承Binder类的IRemoteService.Stub是为了服务端和客户端之间的数据通信。
 所以，实现了Service和创建Binder(IRemoteService.Stub)实例的就是服务端，实现一个ServiceConnection就是客户端。

服务端实例：
1. 创建包名为wrx.aidlserver的应用。
2. 在app/src/main/下，与java目录同级 创建一个aidl文件夹，在aidl/下创建包 wrx.aidlserver ，在其中创建IRemoteService.aidl文件。
3. IRemoteService.aidl中创方法：int getPid()，执行android studio的build，
   可以看到生成的文件：app/build/generated/source/aidl/debug/wrx/aidlserver/IRemoteService.java
4. java/wrx.aidlserver下创建 RemoteService.java，mBinder=IRemoteService.Stub()并在onBind中返回
   IRemoteService.Stub的getPid()返回当前进程ID：return android.os.Process.myPid();
5. manifest中添加RemoteService，为RemoteService设置一个action："wrx.aidlserver.service"

客户端实例：
1. 创包名为 wrx.aidlclient的应用。
2. 在app/src/main/下，与java目录同级 创建一个aidl文件夹，在aidl/下创建包：wrx.aidlserver(这里的包名用的是服务端的)。
3. 把在服务端的 IRemoteService.aidl文件复制到 wrx.aidlserver下，并执行android studio的build。
4. 在MainActivity中创建ServiceConnection和IRemoteService，
   在ServiceConnection的 onServiceConnected中赋值：mIRemoteService = IRemoteService.Stub.asInterface(service)。
5. 在在MainActivity的onCreate中创建Intent并加上action：intent.setAction("wrx.aidlserver.service");
   最后连接：bindService(intent, mConnection, BIND_AUTO_CREATE);
6. 第5步骤：调用bindService之后，会触发ServiceConnection的回调：onServiceConnected
   此时就会对第4步骤的IRemoteService mIRemoteServic赋值
7. 赋值之后就可以调用mIRemoteService.getPid()这个方法了，此时可以拿到 服务端应用的进程ID

进阶：
（1）服务端：
1. 如果需要传输数据，那么需要在服务端实现一个 DataItem.java类，DataItem要实现Parcelable接口。
2. 在aidl目录中也实现一个DataItem.aidl并加上parcelable DataItem;
3. IRemoteService.aidl中加上对DataItem的使用，记得导入这个文件：import wrx.aidlserver.DataItem;
    ...
    void addDataItem(in DataItem data);
    List<DataItem> getDateItemList();
    ...
4. 在RemoteService.java中new IRemoteService.Stub()下的getDateItemList()方法再返回一个创建好的List<DataItem>

（2）客户端：
1. 在java/下创建包：wrx.aidlserver，再把服务端的DataItem.java复制到这个包下。
2. 在aidl目录的wrx.aidlserver下，把服务端的DataItem.aidl复制到这个包下。
3. 在MainActivity中就可使用了，直接调用 mIRemoteService.getDateItemList()方法拿到数据。


------------------------------------------------------------------------------------------------------------

其他进程通讯方式

二、Broadcast 广播
通过发送端发送一个广播，接收端接收这个广播就可以实现跨进程通信，也是利用了 Intent 可以携带额外数据。

三、Content Provider 内容提供者
获取一个联系人的详情。联系人的详情时存在系统里面的，app一定不会和系统程序在一个进程，Content Provider 很明显就是一个跨进程通信的方法。

------------------------------------------------------------------------------------------------------------

android:process=":remote"
Manifest.xml中有时候会对相关的 Service 设置一个android:process, 
一般情况下一个Service没有自己独立的进程，它一般是作为一个线程运行于它所在的应用的进程中。
Android声明文件中的android:process属性却可以为任意组件包括应用指定进程，换句话说，通过在声明文件中设置android:process属性,我们可以让组件（例如Activity, Service等）和应用(Application)创建并运行于我们指定的进程中。

如果对Service加上android:process属性，那么这个Service是运行在新创建的remote进程下的
**注意，这会对调试带来影响，android studio的调试是基于进程的，不能在两条不同的进程上调试代码，这时，只能使用log输出测试代码


------------------------------------------------------------------------------------------------------------

Android中的ABI
ABI是Application Binary Interface的缩写。
ABI常表示两个程序模块之间的接口，且其中一个模块常为机器码级别的library或操作系统。
ABI定义了函数库的调用、应用的二进制文件（尤其是.so）如何运行在相应的系统平台上等细节。
Android目前支持以下七种ABI：armeabi、armeabi-v7a、arm64-v8a、x86、x86_64、mips、mips64。

Android中的CPU
不同的Android设备使用支持不同指令集的CPU。
Android目前有以下七种cpu架构：ARMv5、ARMv7、ARMv8、x86、x86_64、MIPS和MIPS64。

Android中的ABI与CPU
每种CPU架构都有其自己支持的ABIs。可通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。
例如：ARMv5支持armeabi一种，ARMv8支持armeabi、armeabi-v7a、arm64-v8a三种。
每种CPU架构都有自己对应的最优ABI。例如ARMv8是arm64-v8a。

---------------------

不同的Android手机使用不同的CPU，而这些CPU又支持不同的指令集。 CPU和指令集的每个组合都有其自己的应用程序二进制接口（即ABI）。
ABI非常精确地定义了应用程序的机器代码应该如何在运行时与系统交互。

每个ABI支持一个或多个指令集。可在官方网站查看：https://developer.android.com/ndk/guides/abis.html
armeabi，该ABI适用于至少支持ARMv5TE指令集的基于ARM的CPU。
armeabi-v7a，这个ABI扩展了armeabi以包含多个CPU指令集扩展，包括：Thumb-2指令集扩展，VFP硬件-FPU指令
arm64-v8a，此ABI适用于支持AArch64的基于ARMv8的CPU。 它还包括NEON和VFPv4指令集。
x86，该ABI用于支持通常称为“x86”或“IA-32”的指令集的CPU。
x86_64，此ABI适用于支持通常称为“x86-64”的指令集的CPU。

---------------------

Android中的so库
so库的名称和文件名，so库的名称可任意，如daking。
*so库的文件名必须以lib开头。如libdaking.so，其中lib是必要前缀，daking才是这个库的名称。

so库的代码加载
System.loadLibrary("so库的名称");如System.loadLibrary("daking");会加载该应用下的libdaking.so文件。

so库的使用建议
理论上应该为每个ABI目录提供对应的so库。但是Android支持7种ABI，若全部支持，必然导致APK包过大。
一般只保留armeabi、armeabi-v7a这两个ABI的so库。

---------------------

主流cpu的架构
现在手机处理器架构都是ARM架构，采用简单指令集，而电脑的X86架构则是复杂指令集，但功耗稍大。

高通晓龙801，基于顶级Krait400核心架构，Krait是美国高通公司基于ARMv7-A指令集、自主设计的采用28纳米工艺的全新处理器微架构。
高通骁龙835，Kryo280架构，基于ARMv8指令集，支持64位运算。Kryo是Qualcomm Technologies推出的首款定制设计的64位CPU，Krait的延续。

高通公司的Krait与ARM公司的Cortex-A53（俗称 公版ARM架构）
A53是ARM公司最新开发的基于ARMv8指令集的A50系列架构之一，是目前ARM公司能效比最好的处理器架构。
Cortex-A7 处理器是一种由ARM公司推出的基于ARMv7-A架构的高能效处理器。
高通推出的八核处理器骁龙810即采用A57架构。
骁龙820高通首款64位自主微架构“Kryo”，之前的架构都是ARM公版架构和在ARM架构基础上优化的Krait（800，801,805）

华为的麒麟960
麒麟960（kirin 960）是海思公司推出的移动设备芯片，麒麟960首次配备ARM Cortex-A73 CPU核心，小核心为A53，
麒麟970 四核A73+四核A53（ARMv8）。
组成四大四小的big.LITTLE组合，GPU为Mali G71 MP8。
Cortex-A73处理器全面支持ARMv8-A架构。

三星Exynos
Exynos是三星电子基于ARM构架设计研发的处理器品牌
Exynos 4210，CPU：双核Cortex-A9（也就是 ARMv7 ），GPU：ARM Mali-400 MP4 266MHz
Exynos 9810，CPU：Exynos M3
三星从Exynos 8890开始就学习苹果展开了自研CPU的旅程，基于ARMv8指令集推出了名为猫鼬（Mongoose）的架构核心

联发科
Helio X30 (ARMv8-A指令集): 采用三丛十核：包括两个Cortex-A73、四个Cortex-A53、四个Cortex-A35。GPU：Imagination PowerVR 7XTP


苹果：
Apple A9处理器（来自维基百科）：内含了基于苹果自主微架构（区别于ARM发布的公版微架构）的中央处理器核心，
拥有64比特ARMv8-A指令集架构。被搭载于iPhone 6S和iPhone 6S Plus智能手机中。
A11 Bionic：基于ARM64位指令架构，被搭载于iPhone 8、iPhone 8 Plus及iPhone X

---------------------

处理器架构的具体解释：
CPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。
目前市面上的CPU指令集分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，
另一个是以IBM、ARM为首的精简指令集CPU。
两个不同品牌的CPU，其产品的架构也不相同，例如，Intel、AMD的CPU是X86架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构。

---------------------


CPU与GPU
图形处理器（英语：Graphics Processing Unit，缩写：GPU）
对于移动终端手机来说，通常情况下 移动处理器里面就有 CPU和GPU，例如晓龙系列的处理器

Adreno GPU同样是高通公司的产品，搭载在晓龙处理器上。
例如，骁龙835处理器，搭载Adreno540GPU，支持OpenGLES3.2、完整的OpenCL2.0、Vulkan和DX12


------------------------------------------------------------------------------------------------------------

改变背景颜色：
这样输入：              layout.setBackgroundColor(Color.parseColor("#ffff00"));
或者这样输入：           layout.setBackgroundColor(0xFF6db7ff);
0xFF6db7ff是Android中特殊的16进制颜色编码，FF表示的是透明度，6db7ff表示颜色编码
表达式顺序是“aabbggrr”，其中“aa=alpha”（00 到 ff,00透明度为0，ff透明度为100%）；“bb=blue”（00 到 ff）；“gg=green”（00 到 ff)；“rr=red”（00 到 ff）

------------------------------------------------------------------------------------------------------------

Service 生命周期：
Service分为两种形式：

启动：当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。
一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。
服务必须通过调用 stopSelf() 自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。

绑定：当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。仅当与另一个应用组件绑定时，绑定服务才会运行。 
多个组件可以同时绑定到该服务；全部取消绑定后，该服务即会被销毁。
绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 

启动的生命周期：
其他组件调用startService -> onCreate -> onStartCommand -> 
运行中, 随时准备调用stopSelf，或者有其他组件调用stopService -> onDestroy -> 系统销毁服务

绑定的生命周期：
其他组件调用bindService -> onCreate -> onBind -> 运行中, 等待其他组件调用unbindService -> onUnbind
-> 所有的绑定都与客户端解除时，onDestroy -> 系统销毁服务

绑定的通信
Activity中创建 内部类并实现接口ServiceConnection，ServiceConnection的onServiceConnected方法将 参数IBinder service传入
Activity调用bindService (Intent service, ServiceConnection conn, int flags)
Service中创建IBinder service，并在onBind方法中返回
如此，Activity和Service都有IBinder，这样就可以通信了

------------------------------------------------------------------------------------------------------------
自定义View的监听回调机制

public class colorpick extends View{

（1）在自定义View的类内预留接口
 public interface OnColorChangedListener {
        void colorChanged(int color);
    }

（2）在自定义View的类内创建一个该接口
private OnColorChangedListener mListener;

（3）在构造方法中对创建的接口赋值
    public colorpick(Context context,
                             OnColorChangedListener listener,
                             int initialColor) {
        mListener = listener;
    }

（5）至此，就可以在View的内部调用实例化好的接口，如下，对mListener.colorChanged输入0xff0000ff的参数，因为mListener在构造方法中被赋值，相当于外部定义的colorpick赋值给了mListener，
        所以，mListener的colorChanged方法会有Log.w("color is "+color,"color is "+color);的语句，会在控制台输出log

	mListener.colorChanged(0xff0000ff);
}

（4）在外部创建自定义View
                colorpick colorpick1= new colorpick(testactivity.this, new colorpick.OnColorChangedListener() {
                    @Override
                    public void colorChanged(int color) {
                        Log.w("color is "+color,"color is "+color);
                    }
                }
                ,0xff000000);
------------------------------------------------------------------------------------------------------------


获取自定义view的颜色值
	int pixel;
	View view；
	Bitmap bitmap;
                view.buildDrawingCache();
                bitmap = view.getDrawingCache();
                pixel = bitmap.getPixel((int)event.getX(),(int)event.getY());

------------------------------------------------------------------------------------------------------------

设置EditText的输入范围
    private void setRegion_0_255(final EditText et)
    {
        final int MIN_MARK = 0;
        final int MAX_MARK = 255;
        et.addTextChangedListener(new TextWatcher() {
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                if (start > 1)
                {
                    if (MIN_MARK != -1 && MAX_MARK != -1)
                    {
                        int num = Integer.parseInt(s.toString());
                        if (num > MAX_MARK)
                        {
                            s = String.valueOf(MAX_MARK);
                            et.setText(s);
                        }
                        else if(num < MIN_MARK)
                            s = String.valueOf(MIN_MARK);
                        return;
                    }
                }
            }

            @Override
            public void beforeTextChanged(CharSequence s, int start, int count,
                                          int after) {
            }

            @Override
            public void afterTextChanged(Editable s)
            {
                if (s != null && !s.equals(""))
                {
                    if (MIN_MARK != -1 && MAX_MARK != -1)
                    {
                        int markVal = 0;
                        try
                        {
                            markVal = Integer.parseInt(s.toString());
                        }
                        catch (NumberFormatException e)
                        {
                            markVal = 0;
                        }
                        if (markVal > MAX_MARK)
                        {
                            Toast.makeText(getBaseContext(), "输入范围0-255", Toast.LENGTH_SHORT).show();
                            et.setText(String.valueOf(MAX_MARK));
                        }
                        return;
                    }
                }
            }
        });
    }
------------------------------------------------------------------------------------------------------------

match_parent,在android线性布局中比较可以生效，需要加上  
android:layout_weight="1"
------------------------------------------------------------------------------------------------------------
android:digits
指定接受固定的数字，如android:digits="012345"，则只接受0～5数字的输入


------------------------------------------------------------------------------------------------------------
    使用别的包的资源：
不把图片放在res/drawable下，而是存放在src某个package中（如：com.drawable.resource），这种情况下的调用方法为： 
String path = "com/drawable/resource/imageName.png"; 
InputStream is = getClassLoader().getResourceAsStream(path); 
Drawable.createFromStream(is, "src"); 

如果还是希望直接使用res/drawable中的图片，就需要通过下面的方法了： 
假设创建工程的时候，填写的package名字为：com.test.image 
int resID = getResources().getIdentifier("imageName", "drawable", "com.test.image"); 
Drawable image = getResources().getDrawable(resID);

------------------------------------------------------------------------------------------------------------
自定义layout
使用以下方法加载布局，为控件找到ID
       LayoutInflater inflater=(LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
      inflater.inflate(R.layout.editkeyboard_layout, this);
        upButton = (Button)findViewById(R.id.up) ;
或者（其实都一样）
       LayoutInflater inflater=LayoutInflater.from(mContext);
        View contextVie=inflater.inflate(R.layout.editkeyboard_layout, EditKeyboardLayout.this);
        upButton = (Button)contextVie.findViewById(R.id.up) ;
		
在自定义layout中使用merge标签来包含子控件，例如：
<merge
    xmlns:android="http://schemas.android.com/apk/res/android">
    <ImageButton/>
    <LinearLayout/>
    <LinearLayout>
        <TextView/>
    </LinearLayout>
    <ImageButton/>
</merge>

------------------------------------------------------------------------------------------------------------

输入法和EditText的光标移动，选择，粘贴，删除：

	EditText:

        editKeyboardLayout.setLeftButton(new EditKeyboardListener.leftClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection()) {
                    Selection.extendLeft(editText.getText(), editText.getLayout());
                } else {
                    Selection.moveLeft(editText.getText(), editText.getLayout());
                }
            }
        });

        editKeyboardLayout.setRightButton(new EditKeyboardListener.rightClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection()) {
                    Selection.extendRight(editText.getText(), editText.getLayout());
                } else {
                    Selection.moveRight(editText.getText(), editText.getLayout());
                }
            }
        });

        editKeyboardLayout.setUpButton(new EditKeyboardListener.upClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection()) {
                    Selection.extendUp(editText.getText(), editText.getLayout());
                } else {
                    Selection.moveUp(editText.getText(), editText.getLayout());
                }
            }
        });


        editKeyboardLayout.setDownButton(new EditKeyboardListener.downClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection()) {
                    Selection.extendDown(editText.getText(), editText.getLayout());
                } else {
                    Selection.moveDown(editText.getText(), editText.getLayout());
                }
            }
        });

        editKeyboardLayout.setChooseButton(new EditKeyboardListener.chooseClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection() == false) {
                    editKeyboardLayout.setIsSelection(true);
                } else {
                    if (editKeyboardLayout.getIsSelection() == true) {
                        editKeyboardLayout.setIsSelection(false);
                    }
                }
            }
        });

        editKeyboardLayout.setCopyButton(new EditKeyboardListener.copyClickListener() {
            @Override
            public void onClick(View v) {
                int start = Math.min(editText.getSelectionStart(), editText.getSelectionEnd());
                int end = Math.max(editText.getSelectionStart(), editText.getSelectionEnd());
                if (editKeyboardLayout.getIsSelection() && start != end) {
                    selectText = editText.getText().subSequence(start, end).toString();
                }
                mClipBoardLayout.setClipText(selectText);
            }
        });

        editKeyboardLayout.setPasteButton(new EditKeyboardListener.pasteClickListener() {
            @Override
            public void onClick(View v) {
                if (selectText != null) {
                    editText.getText().insert(Selection.getSelectionStart(editText.getText()), selectText);
                }

            }
        });

        editKeyboardLayout.setCutButton(new EditKeyboardListener.cutClickListener() {
            @Override
            public void onClick(View v) {
                int start = Math.min(editText.getSelectionStart(), editText.getSelectionEnd());
                int end = Math.max(editText.getSelectionStart(), editText.getSelectionEnd());
                if (editKeyboardLayout.getIsSelection() && start != end) {
                    selectText = editText.getText().subSequence(start, end).toString();
                    editText.getText().delete(start, end);
                }
            }
        });

        editKeyboardLayout.setDeleteButton(new EditKeyboardListener.deleteClickListener() {
            @Override
            public void onClick(View v) {
                int start = Math.min(editText.getSelectionStart(), editText.getSelectionEnd());
                int end = Math.max(editText.getSelectionStart(), editText.getSelectionEnd());
                if (editKeyboardLayout.getIsSelection()) {
                    editText.getText().delete(start, end);
                } else {
                    editText.getText().delete(end - 1, end);
                }

            }
        });



	输入法:
	通过发送KeyEvent执行光标移动操作，通过得到getCurrentInputConnection而得到当前光标位置并可执行插入粘贴板字符串的操作

    public void startSelect(){
        thisInputConnection = mLatinIME.getCurrentInputConnection();
        if(thisInputConnection != null)
            thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT));
    }

    public void endSelect(){
        if(thisInputConnection != null){
            thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT));
        }
    }


	
	editLayout.setUpButton(new EditKeyboardListener.upClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_UP));
            }
        });
        editLayout.setDownButton(new EditKeyboardListener.downClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_DOWN));
            }
        });
        editLayout.setRightButton(new EditKeyboardListener.rightClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_RIGHT));
            }
        });
        editLayout.setLeftButton(new EditKeyboardListener.leftClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_LEFT));
            }
        });
        editLayout.setChooseButton(new EditKeyboardListener.chooseClickListener() {
            @Override
            public void onClick(View v) {
                ChooseView = v;
                if (ChooseFlag == false) {
                    startSelect();
                    Toast.makeText(getContext(), "Start Choosing", Toast.LENGTH_SHORT).show();
                    ChooseFlag = true;
                    v.setBackgroundResource(R.drawable.choose_highlight);
                } else {
                    endSelect();
                    Toast.makeText(getContext(), "Stop Choosing", Toast.LENGTH_SHORT).show();
                    v.setBackgroundResource(R.drawable.choose_bt);
                    ChooseFlag = false;
                }
            }
        });
        editLayout.setCopyButton(new EditKeyboardListener.copyClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                if (thisInputConnection.getSelectedText(1000) != null) {
                    Toast.makeText(getContext(), "Complete copy", Toast.LENGTH_SHORT).show();
                    clipboardManager.setText(thisInputConnection.getSelectedText(1000));
                }
            }
        });
        editLayout.setPasteButton(new EditKeyboardListener.pasteClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                if (clipboardManager.getText().length() > 0) {
                    thisInputConnection.setComposingText(clipboardManager.getText(), 1);
                }
//                else {
//                    thisInputConnection.setComposingText("PASTE", 1);
//                }
            }
        });
        editLayout.setDeleteButton(new EditKeyboardListener.deleteClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
            }
        });
        editLayout.setCutButton(new EditKeyboardListener.cutClickListener() {
            @Override
            public void onClick(View v) {
                if (thisInputConnection.getSelectedText(1000) != null) {
                    setPopEditKeyboard();
                    Toast.makeText(getContext(), "Complete cut", Toast.LENGTH_SHORT).show();
                    clipboardManager.setText(thisInputConnection.getSelectedText(1000));
                    thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
                }
            }
        });
        editLayout.setSelectAllButton(new EditKeyboardListener.selectAllClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                //to using selectALL
                thisInputConnection.performContextMenuAction(16908319);
                thisInputConnection.performContextMenuAction(16908319);
            }
        });
        editLayout.setBackButton(new EditKeyboardListener.backClickListener() {
            @Override
            public void onClick(View v) {
                if (popEditKeyboard != null && popEditKeyboard.isShowing()) {
                    popEditKeyboard.dismiss();
                }
            }
        });


------------------------------------------------------------------------------------------------------------

Time t=new Time(); 
t.setToNow(); 
int year = t.year;  
int month = t.month;  
int date = t.monthDay;  
int hour = t.hour; // 0-23  
int minute = t.minute;  
int second = t.second;  

1月份t.month为0，第一天t.yearDay为0.


------------------------------------------------------------------------------------------------------------
子View脱离父View再加入新View：
        InputView view = (InputView)mKeyboardSwitcher.getInputView();
        if (view.getParent() != null) {
            ViewGroup parent = (ViewGroup)view.getParent();
            parent.removeView(view);
        }
        LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);
        mLinearLayout.addView(view, p);


------------------------------------------------------------------------------------------------------------
屏幕宽度：	
	WindowManager wm = (WindowManager) getContext()
                    .getSystemService(Context.WINDOW_SERVICE);
 
     int width = wm.getDefaultDisplay().getWidth();
     int height = wm.getDefaultDisplay().getHeight();

------------------------------------------------------------------------------------------------------------
TextView文字居中：
1.在xml文件设置：android:gravity="center"
2.在程序中设置：m_TxtTitle.setGravity(Gravity.CENTER);

TextViews从dimen中获取字号
        mGetPaintTextView = new TextView(mContext);
        mGetPaintTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, mContext.getResources().getDimension(R.dimen.yantext_size));

------------------------------------------------------------------------------------------------------------
popupwindow:
创建：
view是什么布局参数2和3的LayoutParams可以采用什么，也可以填入固定整型数值
mPopupWindow = new PopupWindow(view, LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);

附着锚点显示：mPopupWindow.showAsDropDown(mButton);
showAsDropDown有不同的函数提供重载
mPopupWindow.dismiss();隐藏

 创建PopupWindow
     步骤1：初始化
	 PopupWindow popupWindow = new PopupWindow();
	 步骤2：设置ContentView
        LayoutInflater layoutInflater = LayoutInflater.from(mContext);
        View view1 = layoutInflater.inflate(R.layout.yantext_listview_item_layout, null);
        TextView textView = (TextView) view1.findViewById(R.id.yantext_view1);
        textView.setText("sfksidfxdhgsdghsrhgrg");
        popupWindow.setContentView(view1);
	步骤3：设置宽高
        popupWindow.setHeight(200);
        popupWindow.setWidth(200);
	步骤4：显示
        popupWindow.showAsDropDown(mAnchor);
	步骤5：消失
		popupWindow.dismiss();

LinearLayout设置控件居中，要在LinearLayout中设置：
android:gravity="center"

------------------------------------------------------------------------------------------------------------

//点击外部PopupWindow消失
        mSharePopupWindow.setBackgroundDrawable(new BitmapDrawable());
        mSharePopupWindow.setOutsideTouchable(true);

------------------------------------------------------------------------------------------------------------

ListView设置
xml：
//去除ListView滑到顶部和底部时边缘的黑色阴影：
android:fadingEdge="none"
//去除拖动时默认的黑色背景：
android:cacheColorHint="#00000000"
//去除选中时的黄色底色：
android:listSelector="#00000000"  
java：
//去除行与行之间的黑线：
msgList.setDivider(null);  
//ListView刷新后自动滚到最底部：
msgList.setSelection(msgList.getAdapter().getCount()-1);
------------------------------------------------------------------------------------------------------------

字符串"R.drawable" 转换资源整型：
方法1：
try{  
 Field field=R.drawable.class.getField("icon");  
 int i= field.getInt(new R.drawable());  
  Log.d("icon",i+"");  
}catch(Exception e){  
 Log.e("icon",e.toString());  
}

方法2：
Resources res=getResources();  
int i=res.getIdentifier("icon","drawable",getPackageName());  
Log.i("res",Integer.toString(i));


------------------------------------------------------------------------------------------------------------
检测apk是否安装在手机上：

获得包名列表：
        PackageManager packageManager = mContext.getPackageManager();
        List<ApplicationInfo> appList = packageManager.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);
检测报名：
 for (ApplicationInfo applicationInfo : appList) { 
	String pkgName = applicationInfo.packageName;
	//对比前缀
	if (pkgName.startsWith("prefix name")) {}
 }

 获取其他pkg下的Resource
 Resources res = packageManager.getResourcesForApplication(pkgName);
 获取其他pkg下的Drawable
 int mDrawableResID = res.getIdentifier(drawableName, "drawable", pkgName);
 mTestDrawable = res.getDrawable(mDrawableResID);
 得到Asset资源
 InputStream is = res.getAssets().open(fileName);
 
------------------------------------------------------------------------------------------------------------
 在循环中，break是退出循环体，continue是结束当前这次循环开始下一次循环

------------------------------------------------------------------------------------------------------------
在viewpager中如果删除页面并删除页面的数据，再显示控件，会有部分页面显示数据为空，
mYanPagerAdapter = mViewPager.getAdapter(); 得到Adapter
mViewPager.setAdapter(null); 			设置Adapter为空
mViewPager.setAdapter(mYanPagerAdapter); 再把Adapter设置回去可解决

------------------------------------------------------------------------------------------------------------
获得安装的包的信息列表
        PackageManager packageManager = mContext.getPackageManager();
        List<ApplicationInfo> appList = packageManager.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES); 

		
------------------------------------------------------------------------------------------------------------
设置view的可见性：
View.setVisibility 
GONE：不可见，不占据位置，即原来的位置会被有fill_parent的控件占据
INVISIBLE：不可见，占据位置，即还有宽高
VISIBLE：可见

------------------------------------------------------------------------------------------------------------
在ui thread中调用view的invalidate方法可以通知view重绘制(刷新)，重绘制将调用onDraw()方法来重新绘制view
------------------------------------------------------------------------------------------------------------
得到acticity中的contentview： content=(ViewGroup)this.findViewById(android.R.id.content)
------------------------------------------------------------------------------------------------------------
在FrameLayout中，放在下面的子控件是叠在上面的，即第一个子控件是位于最底层的
------------------------------------------------------------------------------------------------------------
在android的try，catch中可以利用Exception来输出类似于程序崩溃时的错误信息，包括了错误类型(Exception类)，
具体的错误java文件和错误行数
	try {
	} catch (Exception e) {
		Log.e("MyError", "Exception", e); //输出log level为error
		e.printStackTrace();			//输出log level为warn
	}
	
	

------------------------------------------------------------------------------------------------------------

在recycleview中，在getItemViewType返回position就可以在onCreateViewHolder中的viewType得到position，
这种使用方法并不是对viewType的正确使用
        @Override
        public int getItemViewType(int position) {
            return position;
        }

        @Override
        public EmojiSelectViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        }
		
recycleview滑动监听，onScrolled不是滑动之后才会调用，而是在滑动时就会调用，
个人认为应该是从一个点移动到另一个点就会调用（有待研究）
        mScrollListener = new RecyclerView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
            }
            @Override
            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
                Log.e("onScrolled", "onScrolled");
            }
        };
        mRecyclerView.setOnScrollListener(mScrollListener);
		

自定义xml属性：
(1)建立res/values/attrs.xml文件
(2)在attrs.xml写入
<resources>
   <declare-styleable name="PieChart">
       <attr name="showText" format="boolean" />
       <attr name="labelPosition" format="enum">
           <enum name="left" value="0"/>
           <enum name="right" value="1"/>
       </attr>
   </declare-styleable>
</resources>
(3)使用，特别注意在gradle工程中使用： xmlns:custom="http://schemas.android.com/apk/res-auto"
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
   xmlns:custom="http://schemas.android.com/apk/res/com.example.customviews">
 <com.example.customviews.charting.PieChart
     custom:showText="true"
     custom:labelPosition="left" />
</LinearLayout>
(4)在带有AttributeSet的系统提供的构造方法中获取数值：
public PieChart(Context context, AttributeSet attrs) {
   super(context, attrs);
   TypedArray a = context.getTheme().obtainStyledAttributes(
        attrs,
        R.styleable.PieChart,
        0, 0);

   try {
       mShowText = a.getBoolean(R.styleable.PieChart_showText, false);
       mTextPos = a.getInteger(R.styleable.PieChart_labelPosition, 0);
   } finally {
       a.recycle();
   }
}
(5)TypedArray.getResourceId();
可以取得format="reference" 的数值
------------------------------------------------------------------------------------------------------------

多点触控：
使用 onTouchEvent方法来实现，
action由MotionEventCompat.getActionMasked(event)方法来获取，不再使用event.getAction()方法来获取：
action = MotionEventCompat.getActionMasked(event);
switch (action)
	case MotionEvent.ACTION_DOWN: //第一个点按下
	case MotionEvent.ACTION_POINTER_DOWN: //第二个点或者之后的点按下，这时候要判断2 <= event.getPointerCount()，通常会有2个以上
	case MotionEvent.ACTION_MOVE: 		//遍历所有的点
		for(int i = 0; i < event.getPointerCount(); i++){
            event.getX(i);
            event.getY(i);
			} 
	case MotionEvent.ACTION_POINTER_UP: //有点离开就会调用，event.getActionIndex()获取离开的点，触点的排列顺序的从第一个按下排列到最后一个
										//例如upPointIndex为0，就是第一个按下的点离开了屏幕；upPointIndex为2，就是第三个按下的点离开了屏幕，
		int upPointIndex = event.getActionIndex();
	case MotionEvent.ACTION_UP: //最后一个点离开屏幕


------------------------------------------------------------------------------------------------------------
分享图片：
获取bitmap的URI
                Bitmap bitmap = mDesignContainer.getDrawingCache();
                String pathofBmp = MediaStore.Images.Media.insertImage(EditActivity.this.getContentResolver(), bitmap, null, null);
                Uri bmpUri = Uri.parse(pathofBmp);

指定包名的分享：
                    Intent shareIntent = new Intent(Intent.ACTION_SEND);
                    shareIntent.setType("image/*");
                    shareIntent.setPackage("com.facebook.katana");
                    shareIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    shareIntent.putExtra(Intent.EXTRA_STREAM, mBitmapUri);
                    mContext.startActivity(shareIntent);

打开系统的分享列表，选择指定的分享应用：
                    Intent shareIntent = new Intent(Intent.ACTION_SEND);
                    shareIntent.setType("image/*");
                    shareIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    shareIntent.putExtra(Intent.EXTRA_STREAM, mBitmapUri);
                    mContext.startActivity(Intent.createChooser(shareIntent, "share imger"));

获取响应该分享的应用列表：
					  Intent intent = new Intent(Intent.ACTION_SEND, null);
					intent.addCategory(Intent.CATEGORY_DEFAULT);
					intent.setType("image/*");
					PackageManager pManager = EditActivity.this.getPackageManager();
					mShareImgList = pManager.queryIntentActivities(intent, PackageManager.COMPONENT_ENABLED_STATE_DEFAULT);

					
					
在gridview，recycleview等view中如果设置一个带有按下状态的drawable给每个item会产生按下状态混乱的BUG，
需要给每个item都配置一个带有按下状态的drawable，例如在每次设置item时调用以下方法，赋值一个新的drawable

    public static Drawable cloneDrawableWithState(Context context, Drawable origin) {
        final Drawable.ConstantState constantStateDrawable = origin.getConstantState();
        return (constantStateDrawable != null)
            ? constantStateDrawable.newDrawable(context.getResources()).mutate()
            : origin;
    }
					
					
					
------------------------------------------------------------------------------------------------------------
给edittext或searchview设置提示字符串和提示图标:
1.构建SpannableStringBuilder或者spannableString
SpannableStringBuilder ssb = new SpannableStringBuilder("title");
或者 SpannableString spannableString = new SpannableString("title");

2.构建ImageSpan
ImageSpan imageHint = new ImageSpan(drawable);

3.字号(可以不设)
int textSize = (int) (searchAutoComplete.getTextSize() * 1.25);
searchIcon.setBounds(0, 0, textSize, textSize);

4.将包含了图标的ImageSpan设进去
ssb.setSpan(new ImageSpan(searchIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
spannableString.setSpan(imageHint, 0, 1, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);

5.设置
mEditor.setHint(spannableString);

SearchView.SearchAutoComplete searchAutoComplete = (SearchView.SearchAutoComplete) mSearchView.findViewById(android.support.v7.appcompat.R.id.search_src_text);
searchAutoComplete.setHint(spannableString);

总体：
SpannableStringBuilder ssb = new SpannableStringBuilder("    ");
ssb.append("hint");
 int textSize = (int) (searchAutoComplete.getTextSize() * 1.25);
searchIcon.setBounds(0, 0, textSize, textSize);
ssb.setSpan(new ImageSpan(searchIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);	
 searchAutoComplete.setHint(ssb);		
 
注：在开发过程中遇到过想要去除searchview提示图标去除不了的情况，直接把一个字符串的id设置就可以了，例如：
searchAutoComplete.setHint(R.string.mediapicker_gif_title);
					
	
SearchView
关闭edittext collapseActionView()
展开edittext expandActionView()

也可以对SearchView对应的MenuItem调用collapseActionView()，也可以关闭
mSearchItem = menu.findItem(R.id.action_gif_search);
mSearchView = (SearchView) mSearchItem.getActionView();
------------------------------------------------------------------------------------------------------------

onSizeChanged()方法可以获取高宽，但是不合适在获取高宽之后再利用获取的数值进行子控件的设置


------------------------------------------------------------------------------------------------------------
Fragment
放置在Activity中，可以通过FragmentManager进行交互和管理Fragment，

使用方法1：在xml中放置，Activity的onCreateView()方法设置即可 
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    <fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
</LinearLayout>

方法2：使用FragmentTransaction，其中R.id.fragment_container是一个放置fragment的layout

FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();

------------------------------------------------------------------------------------------------------------
获取：使用find id和find tag获取fragment
findFragmentById() 

------------------------------------------------------------------------------------------------------------
在设置visible时，设置layout为gone，layout的子布局的visible并不会为gone


------------------------------------------------------------------------------------------------------------
span:
SpannableString 在setSpan时需要指定flag，以下四种中的其中一种，
如果设置了SPAN_EXCLUSIVE_EXCLUSIVE指的是如果设置SpannableString改变字体颜色，那么在SpannableString的
之前和之后再输入字符都不会出现改变字体颜色的效果。
如果设置了SPAN_INCLUSIVE_INCLUSIVE指的是如果设置SpannableString改变字体颜色，那么在SpannableString的
之前和之后再输入字符都会出现改变字体颜色的效果。
Spanned.SPAN_EXCLUSIVE_EXCLUSIVE(前后都不包括)
Spanned.SPAN_INCLUSIVE_EXCLUSIVE(前面包括，后面不包括)
Spanned.SPAN_EXCLUSIVE_INCLUSIVE(前面不包括，后面包括)
Spanned.SPAN_INCLUSIVE_INCLUSIVE(前后都包括)

------------------------------------------------------------------------------------------------------------
private abstract void print();  //抽象方法定义，继承该方法所在的类必须实现该方法
------------------------------------------------------------------------------------------------------------

在自定义的layout或者普通layout中如果设置了高宽为wrap_content，这时候再设置padding那么会挤压外部的空间
如果设置了高宽为固定大小例如20dp，那么会挤压内部子view
例如:
1.wrap_content下,设置paddingTop为100dp那么layout会包裹住子view之外再变大100dp,这样会把layout之外的view挤下去
2.设置高度10dp下,设置paddingTop为100dp那么所有子view会看不见,设置paddingTop为5dp子view会只能在layout的下半部看到,而layout的上半部会是空白的


------------------------------------------------------------------------------------------------------------
//Adapter.notifyDataSetChanged() 调用会重新计算，即调用onMeasure
//如果一个View由gone变为visible就会调用onMeasure

------------------------------------------------------------------------------------------------------------

public class JavaClassTest {
    public JavaClassTest() {
    }
    public class InternalClass{
        public InternalClass() {
        }
    }
}
// 在类的外部使用类的内部类必须先实例化类，通过类去实例化其内部类
JavaClassTest javaClassTest = new JavaClassTest();
JavaClassTest.InternalClass internalClass = javaClassTest.new InternalClass();
------------------------------------------------------------------------------------------------------------

调用以下代码，不用点击editText，editText也会出现光标，并且被选中
//前面2句只是设置使能，通常只调用第三句代码，即requestFocus
editText.setFocusable(true);
editText.setFocusableInTouchMode(true);
editText.requestFocus(); 

// editText可以被选中并出现光标，但不弹出键盘
editText.setTextIsSelectable.(true)

------------------------------------------------------------------------------------------------------------
XmlResourceParser 解析

xml文件：
<?xml version="1.0" encoding="utf-8"?>
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:keyWidth="33%p"
          android:keyHeight="50dp"
          android:horizontalGap="0px"
          android:verticalGap="0px"
        >
    <Row>
        <Key android:keyLabel="1" android:codes="49" android:horizontalGap="1%p" android:keyWidth="32%p" />
        <Key android:keyLabel="2" android:codes="-1" app:keyUnderLabel="ABC" android:keyOutputText="2|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
        <Key android:keyLabel="3" android:codes="-1" app:keyUnderLabel="DEF" android:keyOutputText="3|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
    </Row>
    <Row>
        <Key android:keyLabel="4" android:codes="-1" app:keyUnderLabel="GHI" android:keyOutputText="4|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
        <Key android:keyLabel="5" android:codes="-1" app:keyUnderLabel="JKL" android:keyOutputText="5|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
        <Key android:keyLabel="6" android:codes="-1" app:keyUnderLabel="MNO" android:keyOutputText="6|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
    </Row>
</Keyboard>

自定义属性：
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="Search_Keyboard_Key">
        <attr name="keyUnderLabel" format="string" />
		<attr name="keyWidth" format="dimension|fraction"/>
    </declare-styleable>
</resources>

1.读取顺序
try {
	int event;
	// parser.next() 是跳转到下一个标签，先跳转到子标签是子标签，没有子标签跳转同级标签
	// 按照上边的例子，如果当前标签是 Keyboard，下一个标签就是 Row， 第一个Row标签的下一个标签就是 Key
	
	while ((event = parser.next()) != XmlResourceParser.END_DOCUMENT) {
		if (event == XmlResourceParser.START_TAG) {
			// 每一个标签的开始，即 < 符号
			// 部分手机使用com.android.internal.R会报错
			TypedArray a = res.obtainAttributes(Xml.asAttributeSet(parser), 
                    com.android.internal.R.styleable.Keyboard);
			
		} else if (event == XmlResourceParser.END_TAG) {

			// 每一个标签的结束，即 > 符号
		}
	}
	// 该while循环的顺序是
	// Keyboard:XmlResourceParser.START_TAG 
	// -> Row:XmlResourceParser.START_TAG 
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Row:XmlResourceParser.END_TAG 
	// -> Row:XmlResourceParser.START_TAG 
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Row:XmlResourceParser.END_TAG 
	// -> Keyboard:XmlResourceParser.END_TAG 
	// 注:第一遍循环的标签似乎是没有的，标签Keyboard在第二循环出现
} catch (Exception x){
}

2.读取自定义属性
if (event == XmlResourceParser.START_TAG) {
	TypedArray typedArray = getResources().obtainAttributes(Xml.asAttributeSet(parser), R.styleable.Search_Keyboard_Key);
	String underLabel = typedArray.getString(R.styleable.Search_Keyboard_Key_keyUnderLabel);
}


3.读取百分比数值，1%p，32%p 需要特殊读取方式
// 读取dimen或者fract(百分比)，如果是百分比数值会返回 参数base 乘以百分比的值
private static int getDimensionOrFraction(TypedArray a, int index, int base, int defValue) {
	TypedValue value = a.peekValue(index);
	if (value == null) return defValue;
	if (value.type == TypedValue.TYPE_DIMENSION) {
		return a.getDimensionPixelOffset(index, defValue);
	} 
	// 判断是不是百分比数值
	else if (value.type == TypedValue.TYPE_FRACTION) {
		return Math.round(a.getFraction(index, base, base, defValue));
	}
	return defValue;
}

// 自定义属性和android定义属性 作为参数的调用，部分手机使用com.android.internal.R(android定义属性)会报错
getDimensionOrFraction(typedArray, R.styleable.Search_Keyboard_keyWidth,
                    100, 50)
getDimensionOrFraction(typedArray, com.android.internal.R.styleable.Keyboard_keyWidth,
                    100, 50)

------------------------------------------------------------------------------------------------------------
// 得到随机颜色
Random rnd = new Random(); 
int color = Color.argb(255, rnd.nextInt(256), rnd.nextInt(256), rnd.nextInt(256)); 
int color = Color.argb(255, rnd.nextInt(125) + 130, rnd.nextInt(125) + 130, rnd.nextInt(125) + 130);
------------------------------------------------------------------------------------------------------------

// 分享 bitmap
private void shareBitmap(Bitmap bitmap) {
	FileOutputStream fos = null;
	try {
		// must create png file, then you can share this file
		File dir = new File(Environment.getExternalStorageDirectory() + File.separator + "StickerCache");
		if (!dir.exists()) {
			dir.mkdirs();
		}
		File imageFile = new File(dir,"StickerCache.png");
		fos = new FileOutputStream(imageFile);
		bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos);
		fos.close();
		
		// share imageFile
		Intent intent = new Intent(Intent.ACTION_SEND);
		intent.setType("image/*");
		intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(imageFile));
		startActivity(Intent.createChooser(intent, "Share"));
	}
	catch (IOException e) {
		if (fos != null) {
			try {
				fos.close();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
	}
}


------------------------------------------------------------------------------------------------------------
// 从drawable中取得 inputstream 并转化成 uri
// 参数1：context，参数2: 包名，参数3：图片名
// 可以将生成出来的 uri 放浏览器的地址栏，可以出现一张图片
public static Uri getDataUri(Context context, String pkgName, String imageName) {
	InputStream inputStream = null;
	ByteArrayOutputStream byteBuffer = null;
	try {
		// 创建一个Context，来获得 其他应用的资源 或者 本应用的资源
		Context resContext = context.createPackageContext(pkgName, Context.CONTEXT_IGNORE_SECURITY);
		// 通过 图片名 取得图片资源的id
		int resId = resContext.getResources().
				getIdentifier(imageName, "drawable", pkgName);
		// 将该图片转化为inputStream
		inputStream = resContext.getResources().openRawResource(resId);
		byteBuffer = new ByteArrayOutputStream();
		int bufferSize = 1024;
		byte[] buffer = new byte[bufferSize];
		int len = 0;
		while ((len = inputStream.read(buffer)) != -1) {
			byteBuffer.write(buffer, 0, len);
		}
		// 将 该图片的输入流inputStream 转化为 字节数组byte[]
		byte[] imageRaw = byteBuffer.toByteArray();
		// 通过Base64加密
		String image64 = Base64.encodeToString(imageRaw, Base64.DEFAULT);
		// 构建 uri字符串
		String pageData = "data:image/*;base64," + image64;
		Uri uri = Uri.parse(pageData);
		return uri;
	} catch (Exception e) {
	} finally {
		// 关闭流
		if (inputStream != null) {
			try {inputStream.close();}
			catch(IOException ioex) {}
		}
		if (byteBuffer != null) {
			try {byteBuffer.close();}
			catch(IOException ioex) {}
		}
	}
	return null;
}
------------------------------------------------------------------------------------------------------------

// 读取 其他apk包的 gif 资源，转化成输入流，保存为 .gif 文件
// 核心方法 openRawResource() 该方法可以用来读取 drawable文件夹或者raw文件夹下的资源并转化为流
public static File getGifFile(Context context, String pkgName, String resName) {
	Boolean isSDPresent = android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
	File absoluteDir = new File(context.getApplicationContext().getExternalCacheDir().getAbsolutePath());
	if (isSDPresent && absoluteDir.exists() && null != context && null != pkgName && null != resName) {
		String imgDirectoryPath = context.getApplicationContext().getExternalCacheDir().getAbsolutePath()+ "/" + "StickerCache";
		File directory = new File(imgDirectoryPath);
		if (!directory.isDirectory() || !directory.exists()) {
			directory.mkdirs();
		}
		//File file = new File(directory, STICKER_TEMPORARY_PATH + ".gif");
		File file = new File(directory, resName + ".gif");
		if (file.exists()) {
			file.delete();
		}
		InputStream inputStream = null;
		OutputStream outputStream = null;
		try {
			Context resContext = context.createPackageContext(pkgName, Context.CONTEXT_IGNORE_SECURITY);
			inputStream = resContext.getResources().openRawResource(ResUtils.resNameToResId(resContext, resName));
			outputStream = new FileOutputStream(file);
			byte buf[] = new byte[1024];
			int len;
			while ((len = inputStream.read(buf)) > 0)
				outputStream.write(buf, 0, len);
			/*outputStream.close();
			inputStream.close();*/
		} catch (Exception e) {
		} finally {
			if (inputStream != null) {
				try {inputStream.close();}
				catch(IOException ioex) {}
			}
			if (outputStream != null) {
				try {outputStream.close();}
				catch(IOException ioex) {}
			}
		}
		return file;
	} else {
		Toast.makeText(context, "SD card is not exists", Toast.LENGTH_SHORT).show();
		return null;
	}
}

------------------------------------------------------------------------------------------------------------

定义方法设置高宽和android自带的XML设置高宽相兼容：
这样写，就可以增加setWidth()方法和setHeight()方法的同时，不影响View其他原有功能
private int mWidth;
private int mHeight;
private boolean isSetWidthMethodUsed;
private boolean isSetHeightMethodUsed;

//如果使用了setWidth()方法，必须设置xml属性layout_width为wrap_content
public void setWidth(int width) {
	mWidth = width;
	isSetWidthMethodUsed = true;
}

//如果使用了setHeight()方法，必须设置xml属性layout_height为wrap_content
public void setHeight(int height) {
	mHeight = height;
	isSetHeightMethodUsed = true;
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
	int myWidthMeasureSpec = 0;
	int myHeightMeasureSpec = 0;
	if(!isSetWidthMethodUsed) {
		mWidth = MeasureSpec.getSize(widthMeasureSpec);
		myWidthMeasureSpec = widthMeasureSpec;
	} else {
		myWidthMeasureSpec = MeasureSpec.makeMeasureSpec(mWidth, MeasureSpec.EXACTLY);
	}
	if(!isSetHeightMethodUsed) {
		mHeight = MeasureSpec.getSize(heightMeasureSpec);
		myHeightMeasureSpec = heightMeasureSpec;
	} else {
		myHeightMeasureSpec = MeasureSpec.makeMeasureSpec(mHeight, MeasureSpec.EXACTLY);
	}
	super.onMeasure(myWidthMeasureSpec, myHeightMeasureSpec);
}


//在实际应用开发中，发现将一个view的背景设为null(原本有背景)，会触发自身的onMeasure以及父view的onMeasure，如下
iconView.setBackgroundDrawable(drawable) <-> iconView.setBackgroundDrawable(null)

//如果不想调用onMeasure，则可以设置一个透明背景给该view，如下
iconView.setBackgroundDrawable(drawable) <-> iconView.setBackgroundDrawable(transparentDrawable));

------------------------------------------------------------------------------------------------------------

view的晃动动画:
res/anim/shaking.xml
<?xml version="1.0" encoding="utf-8"?>
<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="100"
    android:fromDegrees="-5"
    android:pivotX="50%"
    android:pivotY="50%"
    android:repeatCount="infinite" 
    android:repeatMode="reverse"
    android:toDegrees="5" />
	
Animation animation = AnimationUtils.loadAnimation(this, R.anim.shaking);
ImageView mRotateImage.startAnimation(animation);

android:repeatCount 晃动次数，infinite是一直晃动

------------------------------------------------------------------------------------------------------------

android中的4个文件保存路径
getFilesDir()   /data/data/包名/files
getCacheDir()   /data/data/包名/cache
getExternalFilesDir()  /storage/emulated/0/Android/data/包名/files
getExternalCacheDir()  /storage/emulated/0/Android/data/包名/cache

不同
1.存储位置不同
2.External的文件夹可以被其他有读写权限的app更改
3.External的文件夹不安全，外置卡被拔出时不能使用
4.getFilesDir和getCacheDir不申请读写权限就能使用
相同
当对应的app被删除时，删除这4个文件夹

Files和Cache的区别在于，当空间不足时，系统会删除cache

Environment.getExternalStorageDirectory()  //外置存储卡 路径

------------------------------------------------------------------------------------------------------------

// 该方法指向 sd卡上的路径 /storage/emulated/0/Android/data/com.yourapp.package(应用包名)
getExternalCacheDir().getAbsolutePath()

// 当删除应用时，getExternalCacheDir().getAbsolutePath()指向的文件夹会一并删除

// 注意的是 调用 getExternalCacheDir().getAbsolutePath() 方法
// 就会马上创建一个 /storage/emulated/0/Android/data/com.yourapp.package文件夹
// 如果没有调用该方法 /storage/emulated/0/Android/data/com.yourapp.package文件夹不存在

// SD卡(外置卡)读写权限
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>

------------------------------------------------------------------------------------------------------------

Parcelable
用于在Intent中压入对象，
对象的类要继承Parcelable三个接口：
 public class MyParcelable implements Parcelable {
     private int mData;

     public int describeContents() {
         return 0;
     }

     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mData);
     }

     public static final Parcelable.Creator<MyParcelable> CREATOR
             = new Parcelable.Creator<MyParcelable>() {
         public MyParcelable createFromParcel(Parcel in) {
             return new MyParcelable(in);
         }

         public MyParcelable[] newArray(int size) {
             return new MyParcelable[size];
         }
     };
     
     private MyParcelable(Parcel in) {
         mData = in.readInt();
     }
 }
 
如果要使用Parcel的
readArrayList和writeList方法，则列表的元素的类也要实现Parcelable接口

------------------------------------------------------------------------------------------------------------

绘制VIew本身的内容，通过调用View.onDraw(canvas)函数实现
绘制自己的孩子通过dispatchDraw（canvas）实现

------------------------------------------------------------------------------------------------------------

打开输入法，布局中体上移
步骤1 在manifest中对activity配置，android:windowSoftInputMode="adjustResize"
步骤2 activity最外层的布局必须是RelativeLayout
步骤3 将一个控件，置于RelativeLayout的底部，其他控件都基于该底部控件来布局

------------------------------------------------------------------------------------------------------------

异步任务AsyncTask的四个方法
AsyncTask.execute()会启动异步任务，
onPreExecute(), 异步任务启动之后，第一个调用的方法，该方法在UI线程内，例如，显示进度条
doInBackground(Params...), 异步任务启动之后，在后台调用的方法，例如，加载网络数据
onProgressUpdate(Progress...), 异步任务过程中，调用的方法，例如，进度条展示进度
onPostExecute(Result), 异步任务结束之后，最后调用的方法，该方法在UI线程内，例如，隐藏进度条

AsyncTask.cancel(true)
用来结束异步任务，但不是系统自动结束，需要程序员自己写结束
在doInBackground()方法中，多次调用isCancelled()方法，判断是否结束
结束之后，只会调用onCancelled(),而不是onPostExecute()
		
mLoadBitmapTask.getStatus().equals(AsyncTask.Status.FINISHED)
检测是否结束					
					
					
------------------------------------------------------------------------------------------------------------

使用EditText让键盘弹出或者收起
public void showKeyboard () {
	mEditText.requestFocus();
	InputMethodManager imm = (InputMethodManager) getContext().getApplicationContext()
			.getSystemService(Context.INPUT_METHOD_SERVICE);
	imm.showSoftInput(mEditText, InputMethodManager.SHOW_IMPLICIT);
}

public void hideKeyboard () {
	mEditText.clearFocus();
	InputMethodManager imm = (InputMethodManager) getContext().getApplicationContext()
			.getSystemService(Context.INPUT_METHOD_SERVICE);
	imm.hideSoftInputFromWindow(mEditText.getWindowToken(), 0);
}

------------------------------------------------------------------------------------------------------------
// 加密file name
public static String getFileName(String uri) {
	String fileName = null;
	try {
		// SHA-256 加密
		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
		// string 转为UTF-8格式的字节数组
		messageDigest.update(uri.getBytes("UTF-8"));
		fileName = bytesToHex(messageDigest.digest(), new char[64]);
	} catch (Exception e) {
	} finally {
		return fileName;
	}
}

------------------------------------------------------------------------------------------------------------
图库选图
Intent photoPickerIntent = new Intent(Intent.ACTION_PICK);
photoPickerIntent.setType("image/*");
startActivityForResult(photoPickerIntent, PICK_IMAGE);

在onActivityResult中
Uri selectedImageUri = data.getData();
或者





------------------------------------------------------------------------------------------------------------

android 5.0以上
使得status bar 和 自己的布局共用一张背景
在activity中这么设置
	if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
		getWindow().getDecorView().setSystemUiVisibility(
				View.SYSTEM_UI_FLAG_LAYOUT_STABLE
						| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
		Window window = getWindow();
		window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
		window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
		window.setStatusBarColor(0x00ffffff);
	}
在AndroidManifest中配置
    android:theme="@style/MyBarTheme"
	
styles:
    <style name="MyBarTheme" parent="android:Theme.Holo.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:windowTranslucentStatus">true</item>
    </style>


------------------------------------------------------------------------------------------------------------

	canvas 是不能绘制大于canvas.getMaximumBitmapWidth() 或者 canvas.getMaximumBitmapHeight()的图片
	报错：
	W/OpenGLRenderer: Bitmap too large to be uploaded into a texture (4208x2368, max=4096x4096)
	
------------------------------------------------------------------------------------------------------------
	
	// 判断版本号
	if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP){
    // Do something for lollipop and above versions
	} else{
    // do something for phones running an SDK before lollipop
	}
	
------------------------------------------------------------------------------------------------------------

Bitmap 相关

    // 得到一张 空(null) 的Bitmap ，用于取得图片高宽
    private static void getWHBitmap (String path) {
        BitmapFactory.Options opts = new BitmapFactory.Options();
        opts.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(path, opts);
	int h = opts.outHeight;
	int w = opts.outWidth;
    }


//得到bitmap的内存占用（单位 MB）
bitmap.getByteCount()/1024/1024
// ARGB_8888格式的图片是RGB_565格式的一倍左右
Bitmap.Config.ARGB_8888;
Bitmap.Config.RGB_565;

------------------------------------------------------------------------------------------------------------


BitmapFactory.Options options = new BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.ARGB_8888;
// BitmapFactory 缩小bitmap，缩小2倍，options.inSampleSize设置为 1 是加载原图
// 经过测试，只有设置为2的指数幂有效，即：2，4（缩小4倍），8（缩小8倍）等等
options.inSampleSize = 2;
Bitmap fileBitmapScale = BitmapFactory.decodeFile(imagePath, options);


得到一张1MB以下的磁盘存储的图
public static Bitmap get1MbOpts (String path) {
        Bitmap bitmapArgb = getCompressionOpts(path, 1.024 * 1024D);
        return bitmapArgb;
    }
public static Bitmap get100KbOpts (String path) {
        return getCompressionOpts(path, 0.1 * 1024D);
    }
private static Bitmap getCompressionOpts (String path, double needSize) {
        if (path == null || path.isEmpty()) {
            return null;
        }
        BitmapFactory.Options opts = new BitmapFactory.Options();
        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;
        File imageFile = new File(path);
        if (imageFile.exists()) {
            double fileSize = imageFile.length()/1024D; // image file size (KB)
            if (fileSize > needSize) {
                double fileLog = Math.log(fileSize)/Math.log(2);
                double needLog = Math.log(needSize)/Math.log(2);
                int size = (int)(fileLog - needLog + 1)*2;
                if (size == 0) {
                    opts.inSampleSize = 1;
                } else {
                    opts.inSampleSize = size;
                }
            } else {
                opts.inSampleSize = 1;
            }
        } else {
            return null;
        }
        Bitmap originBitmap = BitmapFactory.decodeFile(path, opts);
        return originBitmap;
    }

---------------------------------------------
 改进 写法，增加对byte数组压缩
    public static Bitmap get50KBOpts (byte[] bytes) {
        Bitmap bitmapArgb = getCompressionOpts(bytes, 1.024D * 50D);
        return bitmapArgb;
    }
    private static Bitmap getCompressionOpts (byte[] bytes, double needSize) {
        BitmapFactory.Options opts = new BitmapFactory.Options();
        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;
            double fileSize = bytes.length/1024D; // image file size (KB)
            if (fileSize > needSize) {

                double size = fileSize / needSize;
                double logSize = Math.log(size)/Math.log(2);
                if (logSize - (int)logSize > 0) {
                    logSize = logSize + 1;
                }
                int intSize = (int)Math.pow(logSize, 2);

                if (size == 0) {
                    opts.inSampleSize = 1;
                } else {
                    opts.inSampleSize = intSize;
                }

            } else {
                opts.inSampleSize = 1;
            }
        Bitmap originBitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length, opts);
        return originBitmap;
    }

------------------------------------------------------------------------------------------------------------
GridLayoutMenager,子项间隔
 public class SpaceItemDecoration extends RecyclerView.ItemDecoration {

        private int space;

        public SpaceItemDecoration(int space) {
            this.space = space;
        }

        @Override
        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
            int gridPosition = parent.getChildLayoutPosition(view);
            if (0 <= gridPosition) {
                if (gridPosition % mManager.getSpanCount() == 0) {
                    outRect.left = space;
                }
                if (gridPosition < mManager.getSpanCount()) {
                    outRect.top = space;
                }
                outRect.right = space;
                outRect.bottom = space;
            }
        }
    }


GridLayoutMenager,子项间隔,有title
 public class SpaceItemDecoration extends RecyclerView.ItemDecoration {

        private int space;

        public SpaceItemDecoration(int space) {
            this.space = space;
        }

        @Override
        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
            // -1 for the title
            int gridPosition = parent.getChildLayoutPosition(view) - 1;
            if (0 <= gridPosition) {
                if (gridPosition % mManager.getSpanCount() == 0) {
                    outRect.left = space;
                } else if (gridPosition % mManager.getSpanCount() == mManager.getSpanCount() - 1) {
                    outRect.right = space;
                }

                if (gridPosition < mManager.getSpanCount()) {
                    outRect.top = space;
                } else {
                    // -1 for the title
                    int offsetTotalCount = (mAdapter.getItemCount() - 1);
                    int lastCount = offsetTotalCount % mManager.getSpanCount();
                    if (lastCount == 0) {
                        if (gridPosition >= offsetTotalCount - mManager.getSpanCount()) {
                            outRect.bottom = space;
                        }
                    } else {
                        if (gridPosition >= offsetTotalCount - lastCount) {
                            outRect.bottom = space;
                        }
                    }
                }

            }
        }
    }

GridLayoutMenager,子项分割线
   public class ItemDecorationAlbumColumns extends RecyclerView.ItemDecoration {

        private int mSizeGridSpacingPx;
        private int mGridSize;

        private Paint mPaint;


        public ItemDecorationAlbumColumns(int gridSpacingPx, int gridSize) {
            mSizeGridSpacingPx = gridSpacingPx;
            mGridSize = gridSize;

            mPaint = new Paint();
            mPaint.setColor(getContext().getResources().getColor(R.color.divide_color));
            mPaint.setStrokeWidth(mSizeGridSpacingPx);
        }

        @Override
        public void onDrawOver(Canvas c, RecyclerView parent, State state) {
            super.onDraw(c, parent, state);
            int childCount = parent.getChildCount();
            for (int i = 0; i < childCount; i++) {
                View child = parent.getChildAt(i);
                c.drawLine(child.getLeft(), child.getBottom(), child.getRight(), child.getBottom(), mPaint);
                c.drawLine(child.getRight(), child.getTop(), child.getRight(), child.getBottom(), mPaint);
                if (i < mGridSize) {
                    c.drawLine(child.getLeft(), child.getTop(), child.getRight(), child.getTop(), mPaint);
                }
                if (i % mGridSize == 0) {
                    c.drawLine(child.getLeft(), child.getTop(), child.getLeft(), child.getBottom(), mPaint);
                }
            }

        }

        @Override
        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
            int itemPosition = ((RecyclerView.LayoutParams) view.getLayoutParams()).getViewAdapterPosition();
            if (itemPosition < mGridSize) {
                outRect.top = mSizeGridSpacingPx;
            } else {
                outRect.top = 0;
            }
            outRect.bottom = mSizeGridSpacingPx;
            if (mAdapter != null && itemPosition % mGridSize == 0) {
                outRect.left = mSizeGridSpacingPx;
            }
            outRect.right = mSizeGridSpacingPx;
        }
    }

------------------------------------------------------------------------------------------------------------

Activity 的 onCreate(@Nullable Bundle savedInstanceState)
参数savedInstanceState, 用来恢复状态

可以把一些缓存数据存在savedInstanceState里面
  savedInstanceState.putBoolean("MyBoolean", true);
  savedInstanceState.putDouble("myDouble", 1.9);
  savedInstanceState.putInt("MyInt", 1);
  savedInstanceState.putString("MyString", "Welcome back to Android");

如果onSaveInstanceState被调用， 那么onCreate中的参数savedInstanceState就不是空的
如果Activity是第一次被创建，那么savedInstanceState一般是空的
onSaveInstanceState(Bundle savedInstanceState)

一般点击home键会调用onSaveInstanceState，点击back键则不会调用

void onRestoreInstanceState (Bundle savedInstanceState)
This method is called between onStart() and onPostCreate(Bundle).


void onSaveInstanceState (Bundle outState)
If called, this method will occur before onStop(). There are no guarantees about whether it will occur before or after onPause().

-----------------------------------------------------------------------------------

Activity动态申请权限, 只有危险权限才需要申请	
	
	//检测权限是否已经拥有
        if (ContextCompat.checkSelfPermission(this,
                Manifest.permission.WRITE_EXTERNAL_STORAGE)
                != PackageManager.PERMISSION_GRANTED) {
	    
	    // 判断用户是否 选过禁止该权限
            if (ActivityCompat.shouldShowRequestPermissionRationale(this,
                    Manifest.permission.WRITE_EXTERNAL_STORAGE)) {

                // 如果用户曾经选择了不授予权限，弹出提示，提示该权限是必要的，并且重新弹出一个权限申请
		Toast.makeText(getApplicationContext(), "please agree", Toast.LENGTH_SHORT).show();
                ActivityCompat.requestPermissions(this,
                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
                        1011);

            } else {
		
		// 申请权限，一般第一次申请会走这里
                ActivityCompat.requestPermissions(this,
                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
                        1011);
            }
        }


// 申请权限之后，用户点击了禁止或者允许 会调用
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        switch (requestCode) {
            case 1011: {
                if (grantResults.length > 0
                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), "permission ok", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(getApplicationContext(), "permission cancel", Toast.LENGTH_SHORT).show();
                }
                return;
            }
        }
    }



-----------------------------------------------------------------------------------

8.0 之后安装需要加入 安装apk权限
<uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/>


-----------------------------------------------------------------------------------

在项目中，app依赖了model，那么在model的build.gradle中的 dependencies，在app中不需要再写
在model的AndroidManifest.xml中写入的权限，在app中也不需要再写


-----------------------------------------------------------------------------------
两种状态栏的设置

一／修改状态栏图标和文字颜色（6.0以上）(放在 values-v23 文件夹下)：
    <style name="MainStyle" parent="Theme.AppCompat.NoActionBar">
        <item name="android:statusBarColor" >@android:color/white</item>
        <item name="android:windowLightStatusBar" >true</item>
    </style>

也可以这么写
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            getWindow().setBackgroundDrawableResource(android.R.color.white);
            getWindow().getDecorView().setSystemUiVisibility(
                    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);
            getWindow().setStatusBarColor(Color.TRANSPARENT);
        }

--------------------------------

二／修改状态栏背景，（状态栏背景和主布局背景一体）
   
    将activity的theme设置为MyBarTheme
    <style name="MyBarTheme" parent="android:Theme.Holo.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:windowTranslucentStatus">true</item>
    </style>

	activity中写入
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
            getWindow().getDecorView().setSystemUiVisibility(
                    View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
            Window window = getWindow();
            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
            window.setStatusBarColor(0x00ffffff);
        }


-----------------------------------------------------------------------------------

Fragment中嵌套使用 FragmentPagerAdapter
在Fragment中创建FragmentPagerAdapter时，传入getChildFragmentManager()代替getActivity().getFragmentManager(）即可

------------------------------------------------------------------------------------------------------------

seekbar 分为Determinate（确定）和 Indeterminate（不确定）两种
确定模式是有进度指示的，例如百分比进度，当进度跑完时，加载即完成
不确定模式则没有进度，一般都是循环播放的动态效果

设置seekbar的确定图片 android:progressDrawable="@android:drawable/progress_horizontal"

设置seekbar的不确定图片  android:indeterminateDrawable="@android:drawable/progress_horizontal"

设置seekbar的游标（即可拖动的滑块） android:thumb="@android:drawable/ic_menu_add"

------------------------------------------------------------------------------------------------------------

view的 dispatchKeyEventPreIme 可以用来捕获键盘弹出时，按下back键时的事件
与activity的 onKeyDown 不一样，关闭键盘的back键不会调用onKeyDown


------------------------------------------------------------------------------------------------------------

毫秒级别时间戳：
15202 34303 694（13位）
long time = System.currentTimeMillis();

秒级别时间戳（10位）
long time = System.currentTimeMillis() / 1000;
有些机器设备是以秒位时间戳的，也就是只有10位的时间戳
而在android的代码中，以13位时间戳为准，如果 其他设备传入的是秒级别时间戳（10位），
需要乘以1000让它变成13位

时间戳转换一 ：
long time = System.currentTimeMillis();
Calendar calendar = Calendar.getInstance();
calendar.setTimeInMillis(time);
int year = calendar.get(Calendar.YEAR);
int month = calendar.get(Calendar.MONTH); // 注意，这里返回的是 月份下标，0-11，0是一月份
int day = calendar.get(Calendar.DAY_OF_MONTH);
int hour = calendar.get(Calendar.HOUR);
int minute = calendar.get(Calendar.MINUTE);
int second = calendar.get(Calendar.SECOND);
int millisecond = calendar.get(Calendar.MILLISECOND);

时间戳转换二 ：
long time = System.currentTimeMillis();
SimpleDateFormat d = new SimpleDateFormat("dd-MM-yyyy, hh:mm.ss.SSS");
String formatString = d.format(time);

HH:mm 24小时制
Hh:mm 12小时制

时间戳转换三 （无法达到毫秒级）：
long time = System.currentTimeMillis();
Calendar cal = Calendar.getInstance(Locale.ENGLISH);
cal.setTimeInMillis(time);
String date = DateFormat.format("dd-MM-yyyy, hh:mm:ss", cal).toString();


拿到星期
String weekDay;
SimpleDateFormat dayFormat = new SimpleDateFormat("EEEE", Locale.US);
Calendar calendar = Calendar.getInstance();
weekDay = dayFormat.format(calendar.getTime());

"EEEE" 拿全称
"E" 拿缩写


------------------------------------------------------------------------------------------------------------

MD5 加密：

    public static final String md5(final String s) {
        final String MD5 = "MD5";
        try {
            // Create MD5 Hash
            MessageDigest digest = java.security.MessageDigest
                    .getInstance(MD5);
            digest.update(s.getBytes());
            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuilder hexString = new StringBuilder();
            for (byte aMessageDigest : messageDigest) {
                String h = Integer.toHexString(0xFF & aMessageDigest);
                while (h.length() < 2)
                    h = "0" + h;
                hexString.append(h);
            }
            return hexString.toString();

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return "";
    }

------------------------------------------------------------------------------------------------------------

ConstraintLayout的 attributes属性

app:layout_constraintBottom_toBottomOf="parent"
app:layout_constraintBottom_toTopOf="parent"
这两个配置效果相同，因为 constraintBottom 都是指 放置于layout的底部
toBottomOf和toTopOf是当指向某个id才有效的配置

1. 这两个view，都位于底部，view1在最底层，view2在view1的上面
    <ImageView
        android:id="@+id/view1"
        android:layout_width="100dp"
        android:layout_height="35dp"
        app:layout_constraintBottom_toBottomOf="parent"
        />

    <ImageView
        android:id="@+id/view2"
        android:layout_width="100dp"
        android:layout_height="35dp"
        app:layout_constraintBottom_toTopOf="@id/view1"
        />

2. 设置margin
    <android.support.v7.widget.CardView
        android:id="@+id/civ_chat_main"
        android:layout_width="156dp"
        android:layout_height="135dp"
        android:layout_marginLeft="24dp"
        android:layout_marginTop="24dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        >
如果没有设置layout_constraintLeft_toLeftOf，layout_marginLeft不会生效
如果没有设置layout_constraintTop_toTopOf，layout_marginTop不会生效


3. 水平居中
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"


4. 3个控件 以外的间距纵向等分，即用3个控件把高度等分成4部分，
   修改 view1 的layout_constraintVertical_chainStyle属性为packed或者spread_inside会有不同的等分效果 （修改view2和view3没有效果）
   
    <Button
        android:id="@+id/view1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toTopOf="@+id/view2"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_chainStyle="spread" />
    <Button
        android:id="@+id/view2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toTopOf="@+id/view3"
        app:layout_constraintTop_toBottomOf="@+id/view1"
        app:layout_constraintVertical_chainStyle="packed" />
    <Button
        android:id="@+id/view3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/view2"
        app:layout_constraintVertical_chainStyle="packed" />

5. 权重分配高度，三个控件均分高度，代码：
   在4的基础上，每个控件加上 纵向权重属性，并设置高度0dp：
   android:layout_height="0dp"
   app:layout_constraintVertical_weight="1"
   



------------------------------------------------------------------------------------------------------------

屏蔽dialog的外部点击消失，屏蔽dialog的点击back键消失

            mForceUpdateDialog.setCanceledOnTouchOutside(false);
            mForceUpdateDialog.setOnKeyListener(new DialogInterface.OnKeyListener() {
                @Override
                public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                    if (keyCode == KeyEvent.KEYCODE_BACK
                            && event.getAction() == KeyEvent.ACTION_DOWN) {
                        if (mForceUpdateDialog != null && mForceUpdateDialog.isShowing()) {
                            showToast(R.string.please_update);
                            return true;
                        }
                    }
                    return false;
                }
            });
------------------------------------------------------------------------------------------------------------



------------------------------------------------------------------------------------------------------------

// 设置风格为@android:style/Theme.Holo.Light
        <DatePicker
            android:id="@+id/date_picker"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:theme="@android:style/Theme.Holo.Light"/>

        <TimePicker
            android:id="@+id/time_picker"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:theme="@android:style/Theme.Holo.Light"
            />

// 设置不显示 日历，也就是只显示picker
mDatePicker.setCalendarViewShown(false);
// 设置24小时制	
mTimePicker.setIs24HourView(true);

------------------------------------------------------------------------------------------------------------

抽屉布局，content_main是主内容，content_drawer是抽屉内容：左边缘向右滑动可以拉出抽屉内容

<?xml version="1.0" encoding="utf-8"?>
<android.support.v4.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true"
    >

    <FrameLayout
        android:id="@+id/content_main"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="@android:color/holo_blue_light"
        />

    <FrameLayout
        android:id="@+id/content_drawer"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="@android:color/holo_green_dark"
        android:layout_gravity="start"
        android:fitsSystemWindows="true"
        />

</android.support.v4.widget.DrawerLayout>


------------------------------------------------------------------------------------------------------------

Theme.AppCompat的风格效果
colorPrimary 顶部actionbar的颜色
colorPrimaryDark 状态栏的颜色
colorAccent EditText光标，CheckBox选中颜色等等view的效果
textColorPrimary
navigationBarColor  // 底下导航栏的颜色
windowBackground  // 主背景颜色


------------------------------------------------------------------------------------------------------------

复制到剪切板
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
ClipData clip = ClipData.newPlainText(“phone number”, “15012345678”);
clipboard.setPrimaryClip(clip);

------------------------------------------------------------------------------------------------------------

android的Touch（dispatchTouchEvent，onInterceptTouchEvent，onTouchEvent）

在普通的view中，有dispatchTouchEvent、onTouchEvent两个方法。
在一个layout中，有dispatchTouchEvent，onInterceptTouchEvent，onTouchEvent三个方法。

View中，执行顺序是 dispatchTouchEvent -> onTouchEvent
在Layout中，执行顺序是 dispatchTouchEvent -> onInterceptTouchEvent -> onTouchEvent
	
如果view在layout中，此时点击view，调用顺序是 Layout.dispatchTouchEvent -> Layout.onInterceptTouchEvent -> View.dispatchTouchEvent 
-> View.onTouchEvent -> Layout.onTouchEvent


1. 在layout的 onInterceptTouchEvent返回true，拦截了这个事件之后就不会把touch事件传给这个layout以下的所有view，也就是说，子view不会触发ontouch。

2. 子view的onTouchEvent返回true，表示这个touch事件由当前view处理，就不会再触发layout的onTouchEvent，同时其他同级的view也不会触发onTouchEvent。

3. dispatchTouchEvent则是总体touch事件的分发方法，即负责对onTouchEvent和onInterceptTouchEvent的调用。
   layout的分发流程在ViewGroup.calss中的dispatchTouchEvent方法：在onInterceptTouchEvent返回false，表示没有拦截，那么取出每一个view并在
   dispatchTransformedTouchEvent()方法中调用view的dispatchTouchEvent方法。
   
4. 承接第3点，view的dispatchTouchEvent()比较简单，就是调用onTouchEvent()并返回布尔值。

------------------------------------------------------------------------------------------------------------

屏幕相关：

android:screenOrientation，控制activity启动时方向
unspecified，默认值，由系统决定，不同手机可能不一致
landscape，强制横屏显示
portrait，强制竖屏显
behind，与前一个activity方向相同
sensor，根据物理传感器方向转动，用户90度、180度、270度旋转手机方向，activity都更着变化
sensorLandscape，横屏旋转，一般横屏游戏会这样设置
sensorPortrait，竖屏旋转
nosensor，旋转设备时候，界面不会跟着旋转。初始化界面方向由系统控制
user，用户当前设置的方向

android:configChanges属性，在Activity中添加，
在当所指定属性(Configuration Changes)发生改变时，通知程序调用onConfigurationChanged()函数。
设置方法：将下列字段用“|”符号分隔开，例如：“locale|navigation|orientation” 

"density" 显示密度已更改-用户可能指定了不同的显示比例，或者现在可能会激活不同的显示。
在API级别24中添加。
“fontScale”字体缩放系数已更改 - 用户选择了新的全局字体大小。
"keyboard"键盘类型已更改 - 例如，用户已插入外部键盘。
"keyboardHidden"键盘辅助功能已更改 - 例如，用户已显示硬件键盘。
“layoutDirection”布局方向已更改 - 例如，从左到右（LTR）更改为从右到左（RTL）。
在API级别17中添加。
"locale"语言环境已更改 - 用户选择了应显示文本的新语言。
“mcc”IMSI移动国家代码（MCC）已更改 - 已检测到SIM并更新了MCC。
“mnc”IMSI移动网络代码（MNC）已发生变化 - 已检测到SIM并更新了MNC。
"navigation"导航类型（轨迹球/ dpad）已更改。 （这通常不会发生。）
"orientation"屏幕方向已更改 - 用户旋转了设备。
注意：如果您的应用程序的目标是Android 3.2（API级别13）或更高，那么您还应该声明“screenSize”配置，
因为当设备在纵向和横向之间切换时它也会发生变化。
“smallestScreenSize”物理屏幕尺寸已更改。
无论方向如何，这代表大小的变化，所以只有在实际物理屏幕尺寸发生变化时才会改变，例如切换到外部显示器。
对此配置的更改对应于最小宽度配置的更改。在API级别13中添加。
"touchscreen"触摸屏已更改。 （这通常不会发生。）
“uiMode”用户界面模式已更改 - 用户将设备放置在桌面或车载底座上，或者夜间模式已更改。
有关不同UI模式的更多信息，请参阅UiModeManager。在API级别8中添加。


------------------------------------------------------------------------------------------------------------

file转string，UTF-8编码

String chipId = "";
// chipId = FileUtils.readTextFile(new File("/proc/chipid"), 0, null);

InputStream inputStream = new FileInputStream(new File("/proc/chipid"));
ByteArrayOutputStream outStream=new ByteArrayOutputStream();
byte[] buffer =new byte[1024];
int len=0;
while((len=inputStream.read(buffer))!=-1){//循环读取数据并且将数据写入到缓存输出流中
    outStream.write(buffer, 0, len);
}
chipId = new String(outStream.toByteArray(), "UTF-8");
chipId = StringUtils.trimAll(chipId);


------------------------------------------------------------------------------------------------------------

activity-alias
这个标签属性可以在manifest中，多配制一个指向某一个activity，
设置了之后，界面多一个图标（类似于快捷方式），
getIntent().getComponent().getClassName()能获取到 pkgName.TestAlias
例如：
        <activity-alias
            android:name=".TestAlias"
            android:targetActivity=".MainActivity"
            android:icon="@mipmap/icon"
            android:label="TestAliasLabel"
            >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity-alias>
	
	
------------------------------------------------------------------------------------------------------------

动态字符串%d %s ------android String

%s、%1$s、%d、%1$d

<xliff:g>标签介绍： 
属性id可以随便命名 
属性值举例说明
%n$ms：代表输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格 
%n$md：代表输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格，也可以设为0m,在输出之前放置m个0 
%n$mf：代表输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00 

也可简单写成：
%d   （表示整数）
%f    （表示浮点数）
%s   （表示字符串）

例1：
<string name="message">我选择为%s的玩具</string>
String test = String.format(getResources().getString(R.string.message),  "红色");

例2，两个或多个：
<string name="alert">我的名字叫%1$s，我来自%2$s</string>
String sAgeFormatString sAgeFormat1= getResources().getString(R.string.alert);
String sFinal1 = String.format(sAgeFormat1, "李四","首都北京"); 

例3：
<string name="test_xliff">小红今年<xliff:g id="xxx">%d</xliff:g>岁了，上<xliff:g id="yyy">%s</xliff:g>年级！</string>
String test = String.format(getResources().getString(R.string.test_xliff), 7, "小学二");



------------------------------------------------------------------------------------------------------------





android gradle
gradlew assembleDebug --stacktrace
可打印堆栈，当编译报错时，方便定位

------------------------------------------------------------------------------------------------------------


NDK开发 Android 与 C++

------------------------------

关于android的库

jni的本质就是通过反射来进行的，详细可以看android的native方法定义

android的ndk提供了大量的函数(路径是\ndk-bundle\sysroot\usr\include)，都是只有头文件声明，这些头文件的定义就在.so库中，
手机操作系统自带这些库，.so库一般位于/system/lib/下。只要是程序，一般都会用到这些库文件提供的功能。
所以本地开发环境是看不到c++的源码的，只能看到头文件的声明。
不建议在android原生ndk源码上浪费时间，一般的需要使用到c++开发的情况也是 拿着其他框架的源代码利用ndk编译出.so库文件来使用
再把那些.so文件存入项目中进行依赖，比较少使用到android的原生框架代码。

例如 ndk中的\ndk-bundle\sources\cxx-stl\gnu-libstdc++
在真实的设备上，只自带了缺省的C++ 运行时库（一般该文件位于/system/lib/libstdc++.so），
在Android NDK中只包含了这个运行时库所需要的一些头文件，并没有真实的静态库和动态库。
所以，也就是说，Android系统中默认的那个C++运行时库是没有静态库版本的，而且由于系统自带了，
所以在你的程序中也不需要再包含这个库的.so文件了，可以减小安装文件的大小。

C++ 标准除了定义了语法之外，还包含了一个包罗万象的标准库，方便程序的开发者调用，
从而使用简单代码就可以实现复杂的功能。最简单的，比如string就是属于C++ 标准库的，C++ 自己的语法中并没有string关键字，只有char。

运行时库（Runtime library）通俗的说就是我们的程序运行的时候所依赖的库文件，
在Windows平台这些库由微软提供，并且是以2种形式提供：静态库(lib)、动态库(lib+dll)。每个库还都提供debug、release 2个版本。
C/C++运行时库从形式上来讲和我们自己开发的静态库、动态库没什么两样，
只是它们由微软开发和维护，并提供了一些常用的功能支持（如malloc,free, printf等等），
如果我们的程序需要使用这些功能（事实上，只要是C/C++程序就一定会用到运行时库提供的功能），
就要链接C/C++运行时库。我们可以自主选择是链接“静态库”还是“动态库”，是链接“debug版本”的还是“release版本”的。

参考博客：
https://blog.csdn.net/koibiki/article/details/80952367

----------------------------------------------------------------

Clang是一个由Apple主导编写，基于LLVM的C/C++/Objective-C编译器

----------------------------------------------------------------

一些个人的理解：
----------------------
关于.so库
在java中，如果要使用到c++代码，必须要用到jni，
也就是说cpp代码至少有一个方法是指向java代码的( 用JNIEXPORT void JNICALL 关键字标识，方法名是java的包名并以下划线分隔开)
接着java代码中定义一个对应的方法。
如果编译出.so文件并需要使用该.so文件，不使用cpp源码，那么.so文件的cpp源码，也必须有一个jni方法，
同时，java代码中也要有对应的包名下的方法。

如果在一些项目中发现没有cpp文件却有java的native方法，应该是依赖了.so文件，并且使用了jni技术，
那么这些native方法是不能换名字的，或者也不能把native方法所在的类转移到其他路径，否则在调用native方法时会报错。
----------------------
关于android studio ndk c++开发
可能有时无法查看c++源码，需要在setting中plugins中开启 "android ndk support"
这个源码是位于ndk中的，例如#include 

------------------------------------------------------------------------------------------------------------

NDK开发 CMake

CMake
cmake就是脚本构建工具，用于构建C / C ++库

android 官网介绍了几个cmake脚本的基础命令
https://developer.android.com/studio/projects/configure-cmake

cmake官方也有这些命令的详细描述，比较不友好的是没有例子
https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html
https://cmake.org/cmake/help/latest/command/add_library.html
https://cmake.org/cmake/help/latest/command/find_library.html
https://cmake.org/cmake/help/latest/command/target_link_libraries.html

------------

android原生api官方文档
https://developer.android.com/ndk/guides/stable_apis

----------------------------------------------------------------

Android NDK 原生 API：
Android NDK 会提供一组随着新的 Android API 级别的后续发布而逐渐添加的原生标头和共享库文件。
https://developer.android.com/ndk/guides/stable_apis.html

以下两个基本步骤的操作，以便让您的应用使用 NDK 提供的库：
1.在您的代码中添加与您想使用的库关联的标头。
  这个就是cpp代码中include头文件

2.通知编译系统您的原生模块需要在加载时链接库。
  在cmake中要引入链接库，使用target_link_libraries命令

Android平台上已经存在预构建的NDK库，因此您无需构建它们或将它们打包到APK中。 
因为NDK库已经是CMake搜索路径的一部分，所以您甚至不需要在本地NDK安装中指定库的位置 - 您只需要向CMake提供您要使用的库的名称并链接 

----------------------------------------------------------------
cmake_minimum_required(VERSION 3.4.1)
描述当前cmake是使用了哪一个版本，也有很多版本
------------
add_library()
加入一个动态库
可以在一个cmake文件中多次使用add_library命令，
一般情况下是一套c++功能的文件写一个
例如：
add_library(plasma SHARED
              plasma.cpp
              native-lib.cpp )
编译名plasma的为动态库，这个动态库里面是两个cpp(plasma、native-lib)的代码组成的。

SHARED是参数，意思是建立名为plasma的动态库，还有其他参数STATIC, MODULE
STATIC是建立静态仓库，具体使用说明可以看官方介绍，一般情况就是编译动态库

如果要使用到这个库，那么需要在java代码中加入
static {
	System.loadLibrary("plasma");
}

注意：java代码中，声明native方法，
那么这个方法就要在两个cpp文件中的其中一个，再定义好相对应的方法
例如 native String plasmaTest()
然后在native-lib.cpp定义一个方法：
extern "C" JNIEXPORT jstring JNICALL
Java_wrx_mytest_PlasmaView_plasmaTest()

------------
include_directories(src/main/cpp/include/)
用于指定头文件路径

------------
find_library( log-lib
              log )
log是android的日志库，log-lib是别名

target_link_libraries(
                       #Links the log library to the target library.
					   #将日志库链接到目标库
                       ${log-lib}
                       )

------------
target_link_libraries()
将预构建的库链接，这个是最后一步，
其实通常只需要 写 add_library和target_link_libraries就可以，
add_library 是预构建自己的代码
target_link_libraries 是把预构建的代码进行连接，如果还要使用一些预构建的NDK库，也要写进去

------------
注意：
1.add_library、target_link_libraries等大多数命令都可以执行多次，即在一个cmake文件中，可以多次执行这些函数
2.编译完成之后，build下面会生成.so的动态库文件
3.注意命令中 library和libraries这种一个和多个的区别
4.以上命令不可以更换顺序，否则在编译时，cmake会报错，正常情况下几个add_library命令写在最前面，
   然后是几个target_link_libraries写在最后面。

------------------------------------------------------------------------------------------------------------




