
TCP/IP五层模型
物理层 数据链路层(MAC) 网络层(ip) 传输层(tcp) 应用层(http,ftp)

---------------------------------------

http中，get是拿，请求页面，
post是发，提交表单


socket是套接字，位于应用层和传输层之间，用于封装TCP，UDP，
里面还封装了应用层的某一个端口号，例如：HTTP默认端口号80，FTP默认端口号21


---------------------------------------

TCP （传输层）
TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议

当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，
最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。
之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。

TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。
然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

在数据正确性与合法性上，TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和；同时可以使用md5认证对数据进行加密。
在保证可靠性上，采用超时重传和捎带确认机制。
在流量控制上，采用滑动窗口协议，协议中规定，对于窗口内未经确认的分组需要重传。
在拥塞控制上，采用广受好评的TCP拥塞控制算法（也称AIMD算法）。该算法主要包括三个主要部分：1）加性增、乘性减；2）慢启动；3）对超时事件做出反应。


建立一个连接需要三次握手，而终止一个连接要经过四次握手.
三次握手
(1).客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。
(2).服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。
(3).客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。
四次握手
(1).客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
(2).服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 
(3).服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
(4).客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 


---------------------------------------


端口
一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。
那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。

TCP端口和UDP端口。由于TCP和UDP 两个协议是独立的，因此各自的端口号也相互独立，比如TCP有235端口，UDP也 可以有235端口，两者并不冲突。

公认端口
这类端口也常称之为"常用端口"。
这类端口的端口号从0到1024，它们紧密绑定于一些特定的服务。通常这些端口的通信明确表明了某种服务的协议，这种端口是不可再重新定义它的作用对象。
例如：80端口实际上总是HTTP通信所使用的，而23号端口则是Telnet服务专用的。这些端口通常不会像木马这样的黑客程序利用。
 
注册端口 端口号从1025到49151。它们松散地绑定于一些服务。也是说有许多服务绑定于这些端口，这些端口同样用于许多其他目的。
这些端口多数没有明确的定义服务对象，不同程序可根据实际需要自己定义，如后面要介绍的远程控制软件和木马程序中都会有这些端口的定义的。
记住这些常见的程序端口在木马程序的防护和查杀上是非常有必要的。常见木马所使用的端口在后面将有详细的列表。 

动态和/或私有端口
端口号从49152到65535。理论上，不应把常用服务分配在这些端口上。实际上，有些较为特殊的程序，特别是一些木马程序就非常喜欢用这些端口，因为这些端口常常不被引起注意，容易隐蔽。 


---------------------------------------



TELNET (远程登录) （C/S）（tcp）


FTP （文件传送协议）（C/S）(TCP)
FTP协议的客户机与服务器之间需要建立两个连接， 一个用于控制数据传输（端口21）， 一个用于数据传输（端口20）。
数据连接主要用于数据传输，完成文件内容的传输。控制连接主要用于传输FTP控制命令和服务器的回送消息。


SMTP （简单邮件传输协议）（TCP）（C/S）


---------------------------------------

HTTP （超文本传输协议）（C/S）(TCP)

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 -->
浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户

一次完整的HTTP请求过程从TCP三次握手建立连接成功后开始，客户端按照指定的格式开始向服务端发送HTTP请求，
服务端接收请求后，解析HTTP请求，处理完业务逻辑，最后返回一个HTTP的响应给客户端，HTTP的响应内容同样有标准的格式。

***************
（Http请求由以下部分组成，分别是：请求行、消息报头、请求正文）
HTTP请求格式主要有四部分组成，分别是：请求行、请求头、空行、消息体，每部分内容占一行
<request-line>
<general-headers>
<request-headers>
<entity-headers>
<empty-line>
[<message-body>]

请求行：请求行是请求消息的第一行，由三部分组成：分别是请求方法（GET/POST/DELETE/PUT/HEAD）、请求资源的URI路径、HTTP的版本号
GET /index.html HTTP/1.1

请求头：请求头中的信息有和缓存相关的头（Cache-Control，If-Modified-Since）、客户端身份信息（User-Agent）等等。
Cache-Control:max-age=0
Cookie:gsScrollPos=; _ga=GA1.2.329038035.1465891024; _gat=1
If-Modified-Since:Sun, 01 May 2016 11:19:03 GMT
User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36

请求体
若方法字段是GET，则此项为空，没有数据
若方法字段是POST,则通常来说此处放置的就是要提交的数据
比如要使用POST方法提交一个表单，其中有user字段中数据为“admin”, password字段为123456，那么这里的请求数据就是 user=admin&password=123456，使用&来连接各个字段。

***************

（HTTP响应也是由以下组成，分别是：状态行、消息报头、响应正文）
HTTP响应消息的格式包括：状态行、响应头、空行、消息体。每部分内容占一行。
<status-line>
<general-headers>
<response-headers>
<entity-headers>
<empty-line>
[<message-body>]

状态行：状态行位于相应消息的第一行，有HTTP协议版本号，状态码和状态说明三部分构成。如：
HTTP/1.1 200 OK

响应头：响应头是服务器传递给客户端用于说明服务器的一些信息，以及将来继续访问该资源时的策略。
Connection:keep-alive
Content-Encoding:gzip
Content-Type:text/html; charset=utf-8
Date:Fri, 24 Jun 2016 06:23:31 GMT
Server:nginx/1.9.12
Transfer-Encoding:chunked

响应体：响应体是服务端返回给客户端的HTML文本内容，或者其他格式的数据，比如：视频流、图片或者音频数据。
响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。



***************

主要区分一下get和post

1.提交数据的形式：
GET请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，会直接展现在地址栏中，以?分割URL和传输数据，参数之间以&相连，如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5 %A5%BD。
如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，
得出如：%E4 %BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。
而POST方法则会把数据放到 请求数据（请求体） 字段中以&分隔各个字段，请求行不包含数据参数，地址栏也不会额外附带参数

2.提交数据的大小
  get方法提交数据的大小直接影响到了URL的长度，但HTTP协议规范中其实是没有对URL限制长度的，限制URL长度的是客户端或服务器的支持的不同所影响：
比如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。
  post方式HTTP协议规范中也没有限定，起限制作用的是服务器的处理程序的处理能力。
所以大小的限制还是得受各个web服务器配置的不同而影响。

3.提交数据的安全
POST比GET方式的安全性要高
通过GET提交数据，用户名和密码将明文出现在URL上，因为一下几个原因get方式安全性会比post弱：
(1)登录页面有可能被浏览器缓存
(2)其他人查看浏览器的历史纪录，那么别人就可 以拿到你的账号和密码了
(3)当遇上跨站的攻击时，安全性的表现更差了

---------------------------------------

HTTP协议详解

http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，
常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，
绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。

HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。
HTTP协议的主要特点可概括如下：
1.支持客户/服务器模式。
2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。
  每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
  另一方面，在服务器不需要先前信息时它的应答就较快。

---------------------------------------


DNS （域名解析系统）（UDP）
DNS通常被其他应用层协议（HTTP, SMTP, FTP）所使用， 以便将用户提供的主机名解析为IP地址。
域名是一种分布式并具有层次结构的命名机制：
例如：www.sina.com.cn， 其中最高域名是cn， 表示这台主机在中国。 
第二级域名是com， 表示这个主机属于公司机构； 接下来是sina表示这台主机属于新浪网， 
最左边的是www，表示该主机是一台web服务器。人们可以很容易的就记住它的域名，而不用他的IP地址。

---------------------------------------

SNMP （简单网络管理协议）（UDP）


TFTP （UDP）


---------------------------------------


套接字
源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。其用于标识客户端请求的服务器和服务。






------------------------------------------------------------------------------

对称加密：
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。
所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。
在对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等。
对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。

密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。

------------------------
非对称加密：

非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。
公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。

解决信息公开传送和密钥管理问题，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。

非对称加密与对称加密相比，其安全性更好

非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。
DSA是Schnorr和ElGamal签名算法的变种

公钥和私钥:
在公开密钥密码体制中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK。

重点：
RSA公钥加密算法是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。
RSA算法是第一个能同时用于加密和数字签名的算法

DSA 一般用于数字签名和认证，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，
只用于签名,它比RSA要快很多.
DSA算法是美国的国家标准数字签名算法，它只能数字签名，而不能用户数据加密和密钥交换。

RSA的安全性是基于极其困难的大整数的分解（两个素数的乘积）；
DSA的安全性是基于整数有限域离散对数难题。
基本上可以认为相同密钥长度的 RSA 算法与 DSA 算法安全性相当。



------------------------

消息摘要：
是一类算法的称呼，包括了MD5，SHA1等等，
原理：其实就是将需要摘要的数据作为参数，经过哈希函数(Hash)的计算，得到的散列值。
特点：
1.加密过程不需要密钥并且经过加密的数据无法被解密，
  消息摘要是单向、不可逆的。只能进行正向的信息摘要，而无法从摘要中恢复出任何的原始消息
2.只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文
 （只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。）
3.消息摘要保证了消息的完整性。如果发送者发送的消息，在传输过程中被恶意篡改，那么接收者收到消息后，用同样的摘要算法计算其摘要，如果新摘要与发送者原始摘要不
  同，那么接收者就知道消息被篡改了。
  *这里有一个前提条件就是：接收者一定要事先知道消息的原始摘要。
  消息摘要不需要秘钥，不存在秘钥的保管和分发问题。
4.无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出，SHA-1的变体可以产生192比特位和256比特位的消息摘要。一般认为，摘要的最终输出越长，该摘要算法就越安全。变长输入，定长输出。

一般地，把对一个信息的摘要称为该消息的指纹或数字签名。
数字签名是保证信息的完整性和不可否认性的方法。
数据的完整性是指信宿接收到的消息一定是信源发送的信息，而中间绝无任何更改；
信息的不可否认性是指信源不能否认曾经发送过的信息。
数字签名应该具有唯一性，即不同的消息的签名是不一样的；
同时还应具有不可伪造性，即不可能找到另一个消息，使其签名与已有的消息的签名一样；
还应具有不可逆性，即无法根据签名还原被签名的消息的任何信息。
这些特征恰恰都是消息摘要算法的特征，所以消息摘要算法适合作为数字签名算法。

------------------------

数字签名：
数字签名算法可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥。也就是说，数字签名算法是非对称加密算法和消息摘要算法的结合体。
数字签名算法要求能够验证数据完整性、认证数据来源，并起到抗否认的作用。
数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。
数字签名是非对称密钥加密技术与数字摘要技术的应用。


公钥,私钥,数字签名的工作流程：
1.客户端有一份公钥，一份秘钥，公钥向 许多客户机端分发，私钥 自己存储并且不可泄露。
2.客户机如果要发送加密文档给服务机，需要用公钥加密；服务机收到之后，用私钥解密。

3.服务机发送 文档给客户机，采用"数字签名”。使用Hash函数（消息摘要算法），生成文档的摘要（digest）
4.接着用 私钥 把 摘要 进行加密，生成 数字签名（signature）
5.接着把 数字签名和文档本身 发送给 客户机（注意了，这里发的是两个，一个数字签名，一个未经过摘要和加密的原文档）

6.客户机收到数字签名和文档之后，用公钥解密数字签名，得到第一个摘要, 如果有效，那么它证明是服务器签署了文档，因为只有服务器有私钥
7.客户机拿原信息再次进行摘要算法得到 第二个摘要
8.对比第一个和第二个摘要 如果两者一致，就证明 文档的数据 未被修改过。


数字证书和证书中心CA：
由于公钥是广泛发出，如果客户端不小心下载了不是服务端本身发出的公钥，如果遇到公钥造假，
其他服务端也可以冒充 原服务端给客户端发送假消息，就有可能导致 客户端的信息泄露，
那么需要确认 客户端拥有的公钥就是 原服务端给出的那个公钥。

1.”证书中心"certificate authority，简称CA，可以证明公钥是服务器的那个公钥，
2.服务器到 证书中心为 服务端的公钥做认证，证书中心用自己的私钥，对服务端的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）
3.服务器端 每次发送给客户端时，发送 数字签名和文档本身和数字证书

4.客户端 用CA的公钥解开数字证书，拿到服务端的公钥，然后就能证明"数字签名"是否真的是鲍勃签的

-------------------------------------------



1.客户端向服务器发出加密请求
2.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端
3.客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内
4.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告
  (此网站的安全证书有问题，此网站出具的安全这证书是 为其他网站地址颁发的。安全证书问题可能显示师徒欺骗您或截获您向服务器发送的数据)
5.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。
  （该安全证书由您没有选定信任的公司颁发）
6.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。


------------------------------------------------------------------------------

SSL(Secure Sockets Layer 安全套接层)及其继任者 TLS（Transport Layer Security，传输层安全）
是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。

SSL证书是数字证书的一种。
SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。

SSL协议可分为两层：
SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 
SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

功能：
1）认证用户和服务器，确保数据发送到正确的客户机和服务器；
2）加密数据以防止数据中途被窃取；
3）维护数据的完整性，确保数据在传输过程中不被改变。


SSL协议的握手过程
开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。
1.客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
2.服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
3.客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。
4.服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。
5.客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。


顺序：
1.客户端 -> 2.服务器 -> 3.客户端 -> 4.服务器 -> 5.开始通讯
前3步骤分别产生一个随机数

------------------------------------------------------------------------------

TLS 安全传输层协议（Transport Layer Security）

TLS 是进行 HTTPS 连接的重要环节，通过了 TLS 层进行协商，后续的 HTTP 请求就可以使用协商好的对称密钥进行加密

SSL 是 Netscape 开发的专门用来保护 Web 通讯，目前版本为 3.0。TLS 是 IETF 制定的新协议，建立在 SSL 3.0 之上。所以 TLS 1.0 可以认为是 SSL 3.1

TSL 用于在两个通信应用程序之间提供保密性和数据完整性。
该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面，与具体的应用无关，所以，一般把TLS协议归为传输层安全协议。

*SSL/TLS有两个阶段握手协议和传输协议(记录协议)，握手协议就是建立起连接的过程，这个阶段采用非对称加密，这个过程完毕后会生成一个对话秘钥，
从而传输协议过程，就是用这个对话秘钥使用对称加密进行传输。
1.客户端发出请求(Client Hello)，客户端发出请求，
  客户端主要向服务端提供以下信息：
  (1)支持的SSL/TLS协议版本
  (2)支持的加密套件列表(cipher suite)
  (3)支持的压缩算法列表(compression methods)，用于后续的压缩传输
  (4)产生的一个随机数random_C(random number)，客户端有存留，稍后用于生成"对话密钥(session key)"
2.服务端回应(Server Hello),收到客服端的请求之后，
  服务端向客户端回应以下信息：
  (1)根据客户端支持的SSL/TLS协议版本，和自己的比较确定使用的SSL/TLS协议版本，如果没有合适的，对话关闭
  (2)回应加密套件，压缩算法
  (3)产生的一个随机数random_S(random number)，服务端有存留，稍后用于生成"对话密钥(session key)"
  (4)服务端数字证书(证明自己的身份，传递公钥)，
  (5)如果需要验证客户端，发出请求，要求客户端提供证书
3.客户端回应，客户端收到服务端的回应后，
  首先验证服务端的数字证书，如果证书没有问题继续下去，如果证书有问题，则会有相应提示，或者对话直接关闭。
  然后客户端在向服务端发送以下信息：
  (1)如果服务端有请求证书，发送自己的数字证书
  (2)在产生一个随机数pre-master key(random number)，并且用服务端数字证书中的公钥加密
  (3)编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送
4.服务端最后的回应, 如果有客户端的证书，就先验证客户端的证书
  (1)使用自己的私钥，对随机数pre-master key解密，这时客户端和服务端各自有了三个随机数，然后用原来协商的加密方式生成本次通话使用的会话密钥   
     (session key)
  (2)编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送
这时客户端和服务端都有了session key，然后握手协议阶段就结束了。下面开始使用session key对称加密数据，进行传输，就进入了下一个阶段，传输协议过程。

5.这块的重点在与SSL/TSL协议的握手协议过程。在第三步，客户端验证证书的时候，如果服务端的证书在系统默认信任证书列表中(系统会默认信任一些CA认证中心的根证书)则会直接通过，如果没有在系统默认信任证书列表中，浏览器可能会弹窗让用户选择是否信任该证书，也有可能会直接关闭连接，提示用户，证书不可信。而在App内，如果想要信任未在系统信任列表中的证书，则需要在App内提前置入服务端证书，关于这一点有讲。而关于认证方式，大多数也都是采用的单向认证，也就是说仅仅认证服务端的证书，而像银行等机构则多使用双向认证的方式。


代码相关：
主要由 JDK 的 java.security，javax.net 和 javax.net.ssl 提供的
SSLSocketFactory，SSLSocket，SSLSession，TrustManager
X509TrustManager，Certificate，X509Certificate，HostNameVerifier







---------------------------------------


服务器端可以有多个域名，当访问服务器用IP地址不用域名时，会有返回错误






---------------------------------------














