

使用 pycharm开发 python web， 现在有虚拟机，所以不用安装dlango，只需直接创建项目再运行即可。
个人理解，想要使用安装过的dlango开发也可，但需要制定路径，

python3.6 默认安装了pip3，可以使用pip3直接安装 dlango框架


------------------------------

Pycharm连接mysql

安装mysqlclient，django连接mysql可以用mysqlclient，还有Mysql官方提供的mysql-connector-python
pip3 install mysqlclient


如果Pycharm是使用虚拟环境的话，
在Pycharm的终端下，键入which python
会输出该python的环境  ../venv/bin/python/bin/python
这个环境不是本机python的环境，只是当前项目的虚拟python环境
再键入which pip (pip --version 也可以看)
会输出该python的环境  ../venv/bin/python/bin/pip
这个路径也不是本机pip3的路径，只是当前项目的虚拟python环境

总结，如果Pycharm使用虚拟环境，那么需要在虚拟环境中安装mysqlclient

在终端下执行
pip list
还可以看到安装了django

直接在Pycharm下执行：
pip install mysqlclient







mysql -u root -p

------------------------------------------------------------------------

dlango 整体框架：

服务器对url进行解析后, 调用View中的逻辑(MTV中的V), 其中又涉及到Model(MTV中的M), 与数据库的进行交互, 将数据发到Template(MTV中的T)进行渲染, 然后发送到浏览器中, 浏览器以合适的方式呈现给用户。

MTV：
Django的MTV模式本质上与MVC模式没有什么差别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同，Django的MTV分别代表：
Model(模型)：负责业务对象与数据库的对象(ORM)
Template(模版)：负责如何把页面展示给用户
View(视图)：负责业务逻辑，并在适当的时候调用Model和Template
  区别于MCV，View代替了Controller的功能，Template代替了原本的 View的功能。
  此外，Django还有一个url分发器，它的作用是将一个个URL的页面请求分发给不同的view处理，view再调用相应的Model和Template


MCV:把web应用分为模型(Model),控制器(Controller),视图(View)三层；他们之间以一种插件似的，松耦合的方式连接在一起。
模型负责业务对象与数据库的对象(ORM),视图负责与用户的交互(页面)，控制器(C)接受用户的输入调用模型和视图完成用户的请求。


------------------------------------------------------------------------

官方教程mysite：

第一步

（1）使用PyCharm直接创建Django项目，或者命令创建项目(需要安装django)： django-admin startproject mysite

创建完成后，看到以下结构：
mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        wsgi.py

翻译官方的资料：
外部mysite/根目录 只是您的项目的容器。它的名字与Django无关;你可以将它重命名为任何你喜欢的东西。

manage.py：一个命令行工具，可让您以各种方式与此Django项目进行交互。你可以在django-admin和manage.py中阅读关于manage.py的所有细节。

内部mysite/目录 是实际Python包。如果其他python文件 要import 到 mysite 下一些代码，就需要加上mysite这个包名。例如：from mysite import urls

mysite / __ init__.py：一个空文件，告诉Python这个目录应该被视为一个Python包。如果您是Python初学者，请阅读官方Python文档中有关软件包的更多信息。

mysite / settings.py：这个Django项目的设置/配置。 Django settings 会告诉你有关设置如何工作的所有信息。

mysite / urls.py：这个Django项目的URL声明;您的Django支持的网站的“目录”。您可以在URL调度器中阅读更多关于URL的内容。

mysite / wsgi.py：WSGI兼容的Web服务器为您的项目提供服务的入口点。有关更多详细信息，请参阅如何使用WSGI进行部署。

这样就可以执行一下这个服务器程序了，在系统的命令行，或者pycharm的命令行，或者pycharm直接按下run图标。
命令行：python manage.py runserver

有这么一段输出：Starting development server at http://127.0.0.1:8000/。浏览器访问一下本机的127.0.0.1:8000/。
会看到一个“恭喜！”页面，火箭起飞。

这里暂时无需配置服务器，Django自带 开发和调试用的服务器，但是当项目准备要正式上线时，就需要配置服务器，例如Apache。

还可以在其他端口跑这个服务器程序：python manage.py runserver 8080


（2）环境搭建好， 一个“项目”已经建立起来了，在Django中编写的每个app(application)都包含遵循特定约定的Python包。 
Django自带有一个实用程序，可以自动生成app(application)的基本目录结构。

创建一个名为Polls的app：
在manage.py同级的目录下执行命令行：python manage.py startapp polls
目前pycharm只有在创建项目时才能加入app，如果在项目中创建，只能用命令行。

创建之后看到一个polls目录，有以下结构：
polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py

打开polls/views.py，添加代码：
from django.http import HttpResponse
def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")

这是Django中最简单的视图。 要调用视图，我们需要将它映射到一个URL - 为此我们需要一个URLconf。
要在polls目录中创建一个URLconf。

创建polls/urls.py，添加代码：
from django.urls import path
from . import views
urlpatterns = [
    path('', views.index, name='index'),
]

下一步是将根URLconf指向polls.urls模块。
在mysite/urls.py中，为django.urls.include添加一个导入，并在urlpatterns列表中插入一个include（）:
from django.contrib import admin
from django.urls import include, path
urlpatterns = [
    path('polls/', include('polls.urls')),
    path('admin/', admin.site.urls),
]

include（）函数允许引用其他URLconf。 每当Django遇到include（）时，它会截断与该点匹配的URL的任何部分，并将剩余的字符串发送到包含的URLconf以供进一步处理。
include（）背后的想法是使插入和播放URL变得容易。 由于民意调查(polls)是在他们自己的URLconf（polls / urls.py）中，它们可以放在“/ polls /”下，或者放在“/ fun_polls /”下，或者放在“/ content / polls /”或任何其他路径根下， 该应用程序仍然可以工作。

接着run一下，可以访问polls下的index: http://127.0.0.1:8000/polls/

--------------------------

第二步：
设置数据库，创建第一个模型(model)，并快速介绍Django自动生成的管理站点。

（1）Database(数据库)的设置：
打开mysite / settings.py。 这里可以配置SQLite。SQLite包含在Python中，当项目上线时，应当使用像PostgreSQL这样的更具可扩展性的数据库。
(顺便编辑一下时区：settings.py/TIME_ZONE)

查看INSTALLED_APPS设置。它包含在此Django实例中激活的所有Django application的名称。 
App可以用于多个项目，可以打包并分发这些应用程序以供他人在其项目中使用。

默认情况下，INSTALLED_APPS包含以下应用程序，所有应用程序都附带Django：
django.contrib.admin - 管理网站。 你会很快使用它。
django.contrib.auth - 一个认证系统。
django.contrib.contenttypes - 内容类型的框架。
django.contrib.sessions - 会话框架。
django.contrib.messages - 一个消息框架。
django.contrib.staticfiles - 管理静态文件的框架。

其中一些应用程序至少使用了一个数据库表，所以我们需要在数据库中创建表格，然后才能使用它们。 
运行命令：  
python manage.py migrate

migrate命令查看INSTALLED_APPS设置，并根据 mysite/settings.py 文件中的数据库设置以及 polls下的 migrations (数据库迁移) 创建任何必需的数据库表。 
您会看到每条适用的迁移消息。 如果您有兴趣，请为您的数据库运行命令行客户端并键入
\ dt（PostgreSQL），SHOW TABLES; （MySQL），.schema（SQLite）
或 SELECT TABLE_NAME FROM USER_TABLES; （Oracle）来显示Django创建的表。

默认应用程序包含在常见的情况下，但不是每个人都需要它们。 如果您不需要其中的任何或全部，
请在运行migrate 之前 注释或删除 INSTALLED_APPS中的相应行。 migrate命令将仅在INSTALLED_APPS中运行应用程序的migrations。

运行之后可以看到创建了一个db.sqlite3数据库。


（2）创建模型：models
在我们简单的民意调查应用程序(polls app)中，我们将创建两个模型：问题和选择。
一个问题有一个问题和一个出版日期。 选择有两个领域：选择的文本和一个票数。 每个选项都与一个问题相关联。

polls/models.py:
from django.db import models
class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')
class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

每个模型都由代表django.db.models.Model的子类表示。每个模型都有许多类变量，每个变量表示模型中的数据库字段。(类的定义中，加一个括号再加类表示父类)
每个字段由一个Field类的实例表示 - 例如，字符字段的CharField和日期时间的DateTimeField。这告诉Django每个字段拥有什么类型的数据。
每个Field实例的名称（例如question_text或pub_date）是机器友好格式的字段名称。您将在您的Python代码中使用此值，并且您的数据库将使用它作为列名称。
某些Field类需要参数。例如，CharField要求你给它一个max_length。这不仅在数据库模式中使用，而且在验证中使用，我们很快就会看到。
一个Field也可以有各种可选的参数;在这种情况下，我们已将投票的默认值设置为0。
最后，请注意使用ForeignKey定义的关系。这告诉Django每个Choice都与单个问题有关。 Django支持所有常见的数据库关系：多对一，多对多和一对一。



（3）激活模型：
上边的模型代码为Django提供了大量信息。
有了它，Django能够：
为此应用程序创建数据库模式（CREATE TABLE语句）。
创建一个用于访问Question和Choice对象的Python数据库访问API。

但首先我们需要告诉我们的项目，民意调查应用程序已安装。
要将该应用程序包含在我们的项目中，我们需要在INSTALLED_APPS设置中添加对其配置类的引用。 
PollsConfig类位于polls / apps.py文件中，因此其虚线路径为'polls.apps.PollsConfig'。 
编辑mysite / settings.py文件并将该虚线路径添加到INSTALLED_APPS设置。
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

再跑一下命令：
python manage.py makemigrations polls
会看到终端的输出：
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Choice
    - Create model Question
    - Add field question to choice

这段命名是告诉 Django 修改了models(这里是创建)，并被存储为一个 migration
Migrations是Django存储对模型(以及数据库模式)的更改——它们只是磁盘上的文件。
如果您愿意，您可以阅读您的新模型的迁移; polls/migrations/0001_initial.py.

运行命令，自动管理数据库，sqlmigrate命令接受迁移名称并返回其SQL:
python manage.py sqlmigrate polls 0001

可能会看到终端的以下输出：
BEGIN;
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" serial NOT NULL PRIMARY KEY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL
);
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" serial NOT NULL PRIMARY KEY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Add field question to choice
--
ALTER TABLE "polls_choice" ADD COLUMN "question_id" integer NOT NULL;
ALTER TABLE "polls_choice" ALTER COLUMN "question_id" DROP DEFAULT;
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
COMMIT;

不同的输出取决于使用的数据库的不同，上面的示例是为PostgreSQL生成的。
将app的名称和model的小写名称- question 和 choice 相结合，自动生成表名。(您可以重写此行为。)
Primary keys 主键(IDs)被自动添加。(你也可以重写这个。)
按照惯例，Django将“_id”附加到  foreign key field 外键字段名。(是的，你也可以重写这个。)
外键关系由 外键约束显式FOREIGN KEY constraint 显示。不要担心可延迟的部分;这只是告诉PostgreSQL在事务结束之前不强制执行外键。
它适合于您正在使用的数据库，因此特定于数据库的字段类型(如auto_increment (MySQL)、串行(PostgreSQL)或整数主键自动增量(SQLite)将自动为您处理。
引用字段名也一样——例如，使用双引号或单引号。
sqlmigrate命令实际上并没有在您的数据库上运行迁移——它只是将它打印到屏幕上，以便您可以看到SQL Django认为是必需的。
它有助于检查Django将要做什么，或者是否有数据库管理员需要SQL脚本进行更改。

如果您感兴趣，也可以运行python manage.py check ;这将检查项目中的任何问题，而不需要进行迁移或修改数据库。

所以，再次运行migrate, 在数据库中创建这些模型表:  python manage.py migrate
migrate命令将所有尚未应用的迁移(Django跟踪应用程序在数据库中使用名为django_migrations的特殊表)，并在数据库上运行它们
说白了，本质上是 对模型的更改与数据库中的模式同步。

迁移非常强大，随着时间的推移，您可以更改您的模型，当您开发项目时，无需删除数据库或表，
并生成新的数据库——它专门用于升级数据库，而不会丢失数据。
记住进行模型更改的三个步骤:
1. 在models.py中创建 新的models
2. python manage.py makemigrations [app name] 为这些更改创建迁移。
3. python manage.py migrate 将这些更改应用到数据库。
   
注意：走完这一步，数据库中就已经有表了，  .schema + 表名 可以查询表结构



（4）使用API：

命令行 进入Django 的shell下：
python manage.py shell

>>> from polls.models import Choice, Question  

#打印所有的对象
>>> Question.objects.all()
<QuerySet []>

>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())
>>> q.save()

#可以查看打印信息
>>> q.id
1
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)

#修改信息
>>> q.question_text = "What's up?"
>>> q.save()

#打印所有的对象
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>


polls/models.py，将一个__str__()方法添加到问题和选择中:
from django.db import models
class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text
class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text

导入datetime和django的添加一个方法：
import datetime
from django.db import models
from django.utils import timezone
class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)

再次进入shell： python manage.py shell：
>>> from polls.models import Choice, Question
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith='What')
<QuerySet [<Question: What's up?>]>

>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

>>> Question.objects.get(pk=1)
<Question: What's up?>

>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

>>> q = Question.objects.get(pk=1)

>>> q.choice_set.all()
<QuerySet []>

>>> q.choice_set.create(choice_text='Not much', votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text='The sky', votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)

>>> c.question
<Question: What's up?>

>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()


（5）Django管理：
Django完全自动化了模型管理界面的创建。
Django是在新闻编辑室环境中编写的，在“内容发布者”和“公共”站点之间有着非常清晰的分离。
网站管理员使用该系统添加新闻故事、事件、体育比赛成绩等等，这些内容会在公共站点上显示。Django解决了为站点管理员创建一个统一的界面来编辑内容的问题。

创建管理者用户：
python manage.py createsuperuser

接着需要输入用户名，邮件，密码等等：
Username: admin
Email address: admin@example.com
Password: 123456abc
Password (again): 123456abc
Superuser created successfully.


Run 服务器，其实可以不用执行：
python manage.py runserver

访问， http://127.0.0.1:8000/admin/ ，进入登录界面。
会看到在 authentication and authorization这一栏下有两个选项： Groups群管理 Users用户管理

polls/admin.py 添加代码，将之前创建的问题管理给用户：
from django.contrib import admin
from .models import Question
admin.site.register(Question)

接着会看到在polls这一栏下有一个 Question的选项, 点击进入。

注意事项:
表单是由问题模型自动生成的。
不同的模型字段类型(DateTimeField, CharField)对应于适当的HTML输入小部件。每种类型的字段都知道如何在Django管理中显示自己。
每个DateTimeField都获得了免费的JavaScript快捷方式。日期得到一个“今天”的快捷方式和日历弹出，并且时间得到一个“现在”的快捷方式和一个方便的弹出列表通常进入的时间。
页面的底部提供了几个选项:
保存-保存更改，并返回到该类型对象的变更列表页面。
保存并继续编辑-保存更改并重新加载该对象的管理页面。
保存并添加另一个-保存更改，并为这类对象加载一个新的空白表单。
删除-显示删除确认页。
如果“发布日期”的值与您在教程1中创建问题时的时间不匹配，这可能意味着您忘记为TIME_ZONE设置设置正确的值。更改它，重新加载页面并检查是否出现了正确的值。

--------------------------

第三步，添加视图（view）。
View在django中就是一个webPage，有特定的功能和特定的模板（template）

在poll这个app中，有四个view。
Index：主页。  detail：展示问题和投票数。  results：特定问题的结果。  Vote action：在特定问题中处理针对特定选择的投票。

为了从URL获得视图，Django使用了所谓的'URLconf'。 URLconf将URL模式映射到视图。


（1）首先在polls/views.py中添加三个方法
def detail(request, question_id):
    return HttpResponse("You're looking at question %s." % question_id)

def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)

def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)


接着在 polls/urls.py 中将之前添加的三个方法加进去
from django.urls import path
from . import views
urlpatterns = [
    # ex: /polls/
    path('', views.index, name='index'),
    # ex: /polls/5/
    path('<int:question_id>/', views.detail, name='detail'),
    # ex: /polls/5/results/
    path('<int:question_id>/results/', views.results, name='results'),
    # ex: /polls/5/vote/
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

注意，这里的url是可以配置参数的path的question_id正好对应了 detail等三个方法中的question_id参数。
这里都是一步步分发的，先由ROOT_URLCONF进行匹配，再发到“polls.urls”URLconf以供进一步处理

也可以在path中直接加上 .html的指向，不建议这么做：
path('polls/latest.html', views.index),

每个视图负责执行以下两项操作之一：返回包含所请求页面内容的HttpResponse对象，或引发异常（如Http404）。 其余的由你决定。

视图可以从数据库中读取记录，或不是。 它可以使用模板系统，例如Django's - 或第三方Python模板系统 - 也可以不使用。
它可以生成一个PDF文件，输出XML，随时创建一个ZIP文件，任何你想要的，使用任何你想要的Python库。
所有的Django都希望是HttpResponse。


（2）
使用Django自己的数据库API，我们在教程2中介绍了它。新的index() 视图，它根据出版日期显示系统中最新的5个轮询问题，用逗号分隔：
polls/views.py
from django.http import HttpResponse
from .models import Question
def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    output = ', '.join([q.question_text for q in latest_question_list])
    return HttpResponse(output)

接着创建模板 Templates，放在polls/templates/polls/index.html，
也可以直接放在polls/index.html，但是不建议这么做
{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}

将index方法修改：
def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls/index.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
该代码加载名为polls / index.html的模板并将其传递给 context。 context是一个将模板变量名称映射到Python对象的字典。
通过将浏览器指向“/ polls /”来加载页面，并且您应该看到一个包含教程2中“What's up”问题的项目符号列表。该链接指向问题的详细信息页面。


（3）使用render()
Django提供了一个捷径。 下面是完整的index（）视图，重写：
from django.shortcuts import render
from .models import Question
def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)
render（）函数将请求对象作为第一个参数，将模板名称作为第二个参数，并将字典（dictionary）作为其可选的第三个参数。 
它返回给定上下文呈现给定模板的HttpResponse对象。


（4）404error，修改detail方法：

from django.http import Http404
from django.shortcuts import render
from .models import Question
# ...
def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(request, 'polls/detail.html', {'question': question})

新概念：如果所请求的ID的问题不存在，该视图会引发Http404异常，detail.html添加：
polls/templates/polls/detail.html
{{ question }}

shortcut快捷调用404:
polls/views.py
from django.shortcuts import get_object_or_404, render
from .models import Question
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})

get_object_or_404（）函数将Django模型作为其第一个参数和任意数量的关键字参数，并将其传递给模型管理器的get（）函数。 如果对象不存在，它会引发Http404。
为什么我们使用助手函数get_object_or_404（）而不是在更高级别自动捕获ObjectDoesNotExist异常，或让模型API引发Http404而不是ObjectDoesNotExist？
因为那会将模型图层耦合到视图图层。 Django最重要的设计目标之一是保持松耦合。 在django.shortcuts模块中引入了一些受控耦合。
还有一个get_list_or_404（）函数，它的作用与get_object_or_404（）一样 - 除了使用filter（）而不是get（）。 如果列表为空，它会引发Http404。


（5）修改detail的template，
polls/templates/polls/detail.html
<h1>{{ question.question_text }}</h1>
<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }}</li>
{% endfor %}
</ul>
在{％for％}循环中：question.choice_set.all被解释为Python代码question.choice_set.all（），它返回Choice对象的迭代并适用于{％for％ } 标签。

访问：http://127.0.0.1:8000/polls/1/  可以看到“what’t up？”问题


（6）灵活修改url path
原来的index.html需要进行修改，原来的硬编码（hardcoded）：
<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
这种编码会造成紧密耦合，修改url路径难度加大。

使用{％url％}模板标记删除对URL配置中定义的特定URL路径的依赖：
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
这里会指向polls.urls 中的定义：
path('<int:question_id>/', views.detail, name='detail'),

这样，当需要将url的路径修改为polls/specifics/12/，只需要在polls/urls.py中，将path改为：
path('specifics/<int:question_id>/', views.detail, name='detail'),


（7）灵活修改url名称，
该教程项目只有一个应用程序，民意调查。 在真正的Django项目中，可能会有五个，十个，二十个应用程序或更多。 
Django如何区分它们之间的URL名称？ 例如，民意调查应用程序有一个详细信息视图，所以同一个项目上的应用程序可能会用于博客。 
如何让Django在使用{％url％}模板标签时知道要为网址创建哪个应用视图？
答案是将命名空间添加到您的URLconf中。 在polls / urls.py文件中，继续并添加一个app_name来设置应用程序名称空间：
polls/urls.py
from django.urls import path
from . import views
app_name = 'polls'
urlpatterns = [
    path('', views.index, name='index'),
    path('<int:question_id>/', views.detail, name='detail'),
    path('<int:question_id>/results/', views.results, name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

将index.html修改：
polls/templates/polls/index.html
<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>

--------------------------

第四步，表单处理：
(1)
polls/templates/polls/detail.html
<h1>{{ question.question_text }}</h1>

{% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

<form action="{% url 'polls:vote' question.id %}" method="post">
{% csrf_token %}
{% for choice in question.choice_set.all %}
    <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}" />
    <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br />
{% endfor %}
<input type="submit" value="Vote" />
</form>

每个choice展示一个radio button，当提交时，post一个choice。

(2)创建view，处理提交的数据
URLconf：polls/urls.py
path('<int:question_id>/vote/', views.vote, name='vote'),

polls/views.py：
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse

from .models import Choice, Question
# ...
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))


request.POST是一个类似字典的对象，允许您通过键名访问提交的数据
request.GET以相同的方式访问GET数据

如果在POST数据中未提供选项，request.POST ['choice']将引发KeyError。

增加选择计数后，代码返回HttpResponseRedirect而不是正常的HttpResponse。 
HttpResponseRedirect接受一个参数：用户将被重定向到的URL

everse（）调用将返回一个类似的字符串:'/polls/3/results/',
给出了我们想要传递控制权的视图的名称以及指向该视图的URL模式的可变部分。

其中3是question.id的值。 然后，这个重定向的网址将调用“results” 的view 来显示最终页面。

（3）添加result 的view、template。URLconf暂时不需要配置：
polls/views.py
from django.shortcuts import get_object_or_404, render
def results(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/results.html', {'question': question})

polls/templates/polls/results.html
<h1>{{ question.question_text }}</h1>
<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
{% endfor %}
</ul>
<a href="{% url 'polls:detail' question.id %}">Vote again?</a>

访问，http://127.0.0.1:8000/polls/1/vote/
会调用的vote()，并加载detail.html进行投票。
投票完成之后跳转到result()并加载result.html

（4）优化流程，使用generic views(通用视图)。

我们将我们的投票应用程序转换为使用通用视图系统，以便我们可以删除一大堆我们自己的代码。
我们只需采取几个步骤即可完成转换。我们会：
1.转换URLconf。2.删除一些旧的不需要的视图。3.基于Django的通用视图引入新的视图。

修改URLconf：
polls/urls.py
from django.urls import path
from . import views
app_name = 'polls'
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

使用generic views代替index, detail, and results这几个方法。
polls/views.py，  from django.views import generic
class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        """Return the last five published questions."""
        return Question.objects.order_by('-pub_date')[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'


class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'


这里使用两个通用视图：ListView和DetailView。这两个视图分别抽象出“显示对象列表”和“显示特定类型对象的详细页面”的概念。
每个通用视图都需要知道它将采取何种模式。这是使用模型属性提供的。
DetailView通用视图期望从URL中捕获的主键值被称为“pk”，所以我们已将question_id更改为通用视图的pk。
默认情况下，DetailView通用视图使用名为<app name> / <model name> _detail.html的模板。
在我们的例子中，它会使用模板“polls / question_detail.html”。 
template_name属性用于告诉Django使用特定的模板名称而不是自动生成的默认模板名称。
我们还为结果列表视图指定了template_name - 这确保了结果视图和细节视图在呈现时具有不同的外观，即使它们在幕后都是DetailView。

ListView通用视图使用名为 <app name>/<model name>_list.html;的默认模板;我们使用template_name来告诉ListView使用我们现有的“polls / index.html”模板。

--------------------------


第五步，创建自动化测试，
自动化测试其实就是 测试web接口，写好程序访问web接口，测试有没有异常。
测试代码的逻辑是程序员定制的，把所有可能发生的访问情况测试一遍，肯定有测不到的地方，有没有测试过的情况，
但是自动化测试最大的好处就是可以一键执行，只要写好代码就可以一键测试，不需要再由测试人员一条一条接口的去访问。

（1）发现BUG
Question类的was_published_recently()是有BUG得，如果发布时间是昨天之前，那么判定为不是最近：
return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
但是如果pub_date被改为未来事件，就会一直返回true，这就是BUG。
在shell下测试BUG：
>>> import datetime
>>> from django.utils import timezone
>>> from polls.models import Question
>>> # create a Question instance with pub_date 30 days in the future
>>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
>>> # was it published recently?
>>> future_question.was_published_recently()
True

（2）创建测试python脚本，将（1）的测试写为代码，
polls/tests.py
import datetime
from django.test import TestCase
from django.utils import timezone
from .models import Question
class QuestionModelTests(TestCase):

    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)

执行：
python manage.py test polls
执行结果：
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
F
======================================================================
FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/path/to/mysite/polls/tests.py", line 16, in test_was_published_recently_with_future_question
    self.assertIs(future_question.was_published_recently(), False)
AssertionError: True is not False

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
Destroying test database for alias 'default'...


发生了什么是这样的：
python manage.py测试民意调查在民意调查应用程序中查找测试
它找到了django.test.TestCase类的一个子类
它创建了一个专门用于测试目的的数据库
它寻找测试方法 - 名称以测试开始的测试方法
在test_was_published_recently_with_future_question中，它创建了一个Question实例，其pub_date字段将来是30天
...并使用assertIs（）方法，它发现它的was_published_recently（）返回True，尽管我们希望它返回False
测试通知我们哪个测试失败，甚至发生故障的线路。


（3）修复BUG：
修改以下代码：
polls/models.py
def was_published_recently(self):
    now = timezone.now()
    return now - datetime.timedelta(days=1) <= self.pub_date <= now

再次测试：python manage.py test polls，校验一下BUG是否修复成功。


（4）写更多测试方法：
polls/tests.py
def test_was_published_recently_with_old_question(self):
    """
    was_published_recently() returns False for questions whose pub_date
    is older than 1 day.
    """
    time = timezone.now() - datetime.timedelta(days=1, seconds=1)
    old_question = Question(pub_date=time)
    self.assertIs(old_question.was_published_recently(), False)

def test_was_published_recently_with_recent_question(self):
    """
    was_published_recently() returns True for questions whose pub_date
    is within the last day.
    """
    time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
    recent_question = Question(pub_date=time)
    self.assertIs(recent_question.was_published_recently(), True)


（5）测试view，
Django提供了一个测试客户端来模拟用户在视图级别与代码进行交互。 我们可以在tests.py或者shell中使用它。
我们将重新启动shell，在那里我们需要做一些在tests.py中不需要的事情。 首先是在shell中设置测试环境：
>>> from django.test.utils import setup_test_environment
>>> setup_test_environment()

setup_test_environment（）安装了一个模板渲染器，它将允许我们检查响应的一些附加属性，如response.context，否则这些属性将不可用。
数据库运行以下内容，并且输出可能会略有不同。 如果settings.py中的TIME_ZONE不正确，您可能会收到意外的结果。 如果您不记得提前设置，请在继续之前检查它。

接下来，我们需要导入测试客户端类（稍后在tests.py中，我们将使用django.test.TestCase类，该类自带客户端，因此不需要）：
>>> from django.test import Client
>>> # create an instance of the client for our use
>>> client = Client()

然后就可以敲入命令：
>>> # get a response from '/'
>>> response = client.get('/')
Not Found: /
>>> # we should expect a 404 from that address; if you instead see an
>>> # "Invalid HTTP_HOST header" error and a 400 response, you probably
>>> # omitted the setup_test_environment() call described earlier.
>>> response.status_code
404
>>> # on the other hand we should expect to find something at '/polls/'
>>> # we'll use 'reverse()' rather than a hardcoded URL
>>> from django.urls import reverse
>>> response = client.get(reverse('polls:index'))
>>> response.status_code
200
>>> response.content
b'\n    <ul>\n    \n        <li><a href="/polls/1/">What&#39;s up?</a></li>\n    \n    </ul>\n\n'
>>> response.context['latest_question_list']
<QuerySet [<Question: What's up?>]>

（6）改善view，
polls/views.py
class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        """Return the last five published questions."""
        return Question.objects.order_by('-pub_date')[:5]
接着导入timezone
from django.utils import timezone
修改get_queryset方法：
def get_queryset(self):
    """
    Return the last five published questions (not including those set to be
    published in the future).
    """
    return Question.objects.filter(
        pub_date__lte=timezone.now()
    ).order_by('-pub_date')[:5]

测试新的view：
polls/tests.py
from django.urls import reverse
polls/tests.py
def create_question(question_text, days):
    """
    Create a question with the given `question_text` and published the
    given number of `days` offset to now (negative for questions published
    in the past, positive for questions that have yet to be published).
    """
    time = timezone.now() + datetime.timedelta(days=days)
    return Question.objects.create(question_text=question_text, pub_date=time)


class QuestionIndexViewTests(TestCase):
    def test_no_questions(self):
        """
        If no questions exist, an appropriate message is displayed.
        """
        response = self.client.get(reverse('polls:index'))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "No polls are available.")
        self.assertQuerysetEqual(response.context['latest_question_list'], [])

    def test_past_question(self):
        """
        Questions with a pub_date in the past are displayed on the
        index page.
        """
        create_question(question_text="Past question.", days=-30)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question.>']
        )

    def test_future_question(self):
        """
        Questions with a pub_date in the future aren't displayed on
        the index page.
        """
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse('polls:index'))
        self.assertContains(response, "No polls are available.")
        self.assertQuerysetEqual(response.context['latest_question_list'], [])

    def test_future_question_and_past_question(self):
        """
        Even if both past and future questions exist, only past questions
        are displayed.
        """
        create_question(question_text="Past question.", days=-30)
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question.>']
        )

    def test_two_past_questions(self):
        """
        The questions index page may display multiple questions.
        """
        create_question(question_text="Past question 1.", days=-30)
        create_question(question_text="Past question 2.", days=-5)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question 2.>', '<Question: Past question 1.>']
        )

（7）增加detail：
polls/views.py
class DetailView(generic.DetailView):
    ...
    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        return Question.objects.filter(pub_date__lte=timezone.now())
测试接口：
polls/tests.py
class QuestionDetailViewTests(TestCase):
    def test_future_question(self):
        """
        The detail view of a question with a pub_date in the future
        returns a 404 not found.
        """
        future_question = create_question(question_text='Future question.', days=5)
        url = reverse('polls:detail', args=(future_question.id,))
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_past_question(self):
        """
        The detail view of a question with a pub_date in the past
        displays the question's text.
        """
        past_question = create_question(question_text='Past Question.', days=-5)
        url = reverse('polls:detail', args=(past_question.id,))
        response = self.client.get(url)
        self.assertContains(response, past_question.question_text)


--------------------------

第六步，添加样式表和图像，例如CSS，JavaScript，image等等，这些文件被称为：“static files”.
django.contrib.staticfiles的用途：它将来自每个应用程序（以及您指定的任何其他位置）的静态文件收集到一个可以在生产中轻松投放的位置。

（1）
类似于template，创建polls/static/polls/目录，之后的静态资源都放在这里。
polls/static/polls/style.css
li a {
    color: green;
}

使用style.css：
polls/templates/polls/index.html
{% load static %}
<link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}" />

{％static％}模板标签生成静态文件的绝对URL。

--------------------------

第七步：
（1）并将重点定制Django的自动生成的管理站点。
将之前的代码改为：
polls/admin.py
from django.contrib import admin
from .models import Question
class QuestionAdmin(admin.ModelAdmin):
    fields = ['pub_date', 'question_text']
admin.site.register(Question, QuestionAdmin)

再次修改：
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date']}),
    ]
admin.site.register(Question, QuestionAdmin)

（2）在anmin管理中，加入Choice，
polls/admin.py中加入这行代码
admin.site.register(Choice)

再次加入修改
polls/admin.py
from django.contrib import admin
from .models import Choice, Question
class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]
    inlines = [ChoiceInline]
admin.site.register(Question, QuestionAdmin)

依次做出以下修改，可以看到不同效果：
1.
class QuestionAdmin(admin.ModelAdmin):
    # ...
    list_display = ('question_text', 'pub_date')

2.
class QuestionAdmin(admin.ModelAdmin):
    # ...
    list_display = ('question_text', 'pub_date', 'was_published_recently')

3.在QuestionAdmin最后添加：
list_filter = ['pub_date']

4.在QuestionAdmin最后添加：
search_fields = ['question_text']

（3）自定制templates
mysite/settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]












--------------------------

其他细节：

（1）
wsgi：Web Server Gateway Interface。略有了解：python已经实现了接受HTTP请求、解析HTTP请求、发送HTTP响应这些底层，wsgi就是提供接口的。
WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。例如：
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'<h1>Hello, web!</h1>']
上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：
environ：一个包含所有HTTP请求信息的dict对象
start_response：一个发送HTTP响应的函数。

这样，只需要关系怎么响应http请求，不需要去管理底层的 http和tcp通讯。

（2）
项目(Project)与应用程序(app即application)
项目和应用程序有什么区别？ 应用程序是一种Web应用程序，它可以执行某些操作，例如Weblog系统，公共记录数据库或简单的民意调查应用程序。 
项目是特定网站的配置和应用程序的集合。 项目可以包含多个应用程序。 一个应用程序可以在多个项目中。

（3）
更换数据库：
如果希望使用其他数据库，请安装适当的数据库绑定，并在DATABASES的“默认”项中更改以下键以匹配数据库连接设置：
ENGINE - “django.db.backends.sqlite3”，“django.db.backends.postgresql”，“django.db.backends.mysql”或“django.db.backends.oracle”。 
其他后端也可用。
NAME - 数据库的名称。 如果您使用SQLite，数据库将成为您计算机上的文件; 在这种情况下，NAME应该是该文件的完整绝对路径，包括文件名。 
缺省值os.path.join（BASE_DIR，'db.sqlite3'）将把文件存储在你的项目目录中。
如果您不使用SQLite作为数据库，则必须添加其他设置，例如USER，PASSWORD和HOST。 

对于SQLite以外的数据库
如果使用SQLite之外的数据库，请确保你已经创建了一个数据库。 在数据库的交互式提示中使用“CREATE DATABASE database_name;”做到这一点。
还要确保mysite / settings.py中提供的数据库用户具有“创建数据库”权限。 这允许自动创建测试数据库，这将在稍后的教程中需要。
如果您使用的是SQLite，则无需事先创建任何内容 - 数据库文件将在需要时自动创建。

（4）
migration，数据库迁移，
个人理解：迁移就是数据持久化，将对象存入数据库中.
migration是迁移命令，可以用来创建表，当执行这条命令时，会根据settings.py的 DATABASES这一项去创建数据库和表，默认数据库db.sqlite3在根目录下。

（5）
filter 数据过滤：
很少会一次性从数据库中取出所有的数据；通常都只针对一部分数据进行操作。
在Django API中，我们可以使用`` filter()`` 方法对数据进行过滤：
>>> Publisher.objects.filter(name='Apress')
[<Publisher: Apress>]

filter() 根据关键字参数来转换成 WHERE SQL语句。 前面这个例子 相当于这样：
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';

可以传递多个参数到 filter() 来缩小选取范围：
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress>]

多个参数会被转换成 AND SQL从句， 因此上面的代码可以转化成这样：
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE country = 'U.S.A.'
AND state_province = 'CA';

SQL缺省的 = 操作符是精确匹配的， 其他类型的查找也可以使用：
>>> Publisher.objects.filter(name__contains="press")
[<Publisher: Apress>]
在 name 和 contains 之间有双下划线。和Python一样，Django也使用双下划线来表明会进行一些魔术般的操作。
这里，contains部分会被Django翻译成LIKE语句：
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name LIKE '%press%';

（6）Django中，除了开发者自己创建的app外，setting中还有多几个app。
admin，这个app是后台界面管理，会经常用到


------------------------------------------------------------------------

Django总结：

Django的项目构建 与javaWeb不同：
只要安装了Django，不需要其他项目构建工具，例如 gradle和maven这种主要面向java的项目构建工具，在python中是没有的。
Django本身就是Web应用框架，
自带特有的 MTV模式，类似于MVC
自带持久层代码框架, 也就是 对象关系映射（ORM，Object Relational Mapping）
自带UI界面和管理界面

--------------------

如果想执行 django的命令，需要进入django项目的环境
python manage.py shell 

--------------------

Django也是一个MVC框架。
但是在Django中，控制器接受用户输入的部分由框架自行处理，
所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式：
M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。
T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。
V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。

Django 视图不处理用户输入，而仅仅决定要展现哪些数据给用户，而Django 模板 仅仅决定如何展现Django视图指定的数据。
或者说, Django将MVC中的视图进一步分解为 Django视图 和 Django模板两个部分，分别决定 “展现哪些数据” 和 “如何展现”，
使得Django的模板可以根据需要随时替换，而不仅仅限制于内置的模板。

至于MVC控制器部分，由Django框架的URLconf来实现。
URLconf机制是使用正则表达式匹配URL，然后调用合适的Python函数。
URLconf对于URL的规则没有任何限制，你完全可以设计成任意的URL风格，不管是传统的，RESTful的，或者是另类的。
框架把控制层给封装了，无非与数据交互这层都是数据库表的读,写,删除,更新的操作。

在写程序的时候，只要调用相应的方法就行了，感觉很方便。程序员把控制层东西交给Django自动完成了。
只需要编写非常少的代码完成很多的事情。所以，它比MVC框架考虑的问题要深一步，因为我们程序员大都在写控制层的程序。
现在这个工作交给了框架，仅需写很少的调用代码，大大提高了工作效率。

--------------------

{% %}  
对于template，即.html，django可以使用{% %}在html中嵌入代码，例如if for这种语句。

django所使用的模板引擎约定的 {{ 变量 }}, {% 代码段落 %} 表示方法

--------------------

python添加依赖库的方式与java不同，

Python 使用第三方包时，需要下载和安装，使用自带的pip 命令工具来下载，python3使用 pip3命令：
pip install xxx
pip3 install xxx




------------------------------------------------------------------------

Templates解析，其实就是文本文件，HTML, XML, CSV 等等
模板包含variables（变量），variables在模板被评估时被 替换为值，variables控制模板的逻辑。

例如：
{% extends "base_generic.html" %}

{% block title %}{{ section.title }}{% endblock %}

{% block content %}
<h1>{{ section.title }}</h1>

{% for story in story_list %}
<h2>
  <a href="{{ story.get_absolute_url }}">
    {{ story.headline|upper }}
  </a>
</h2>
<p>{{ story.tease|truncatewords:"100" }}</p>
{% endfor %}
{% endblock %}

--------------------


Variables变量的概念：

{{ variable }}   一般情况下属性都是这么写的

当模板引擎遇到变量时，它会评估该变量并将其替换为结果。 变量名称由字母数字字符和下划线（“_”）的任意组合组成。
 点（“.”）也出现在变量部分，但具有特殊含义，如下所示。 重要的是，变量名中不能包含空格或标点符号。
使用 点 . 来访问变量的属性。




--------------------

Admin 用户管理：

Django 提供了基于 web 的管理工具。
Django 自动管理工具是 django.contrib 的一部分。你可以在项目的 settings.py 中的 INSTALLED_APPS 看到它：
INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
)
django.contrib是一套庞大的功能集，它是Django基本代码的组成部分。

在主工程的urls.py下加入admin，就可以使用上admin管理
urlpatterns = [
    path('admin/', admin.site.urls),
]

使用命令创建超级用户：
python manage.py createsuperuser

在localhost:8080/admin 下登录，可以看到用户管理的界面

为了让 admin 界面管理某个数据模型，我们需要先注册该数据模型到 admin。
在子项目app的 admin.py中注册模型，注册的类必须是继承自models.Model。例如：
admin.site.register(Test)










--------------------

















------------------------------------------------------------------------

SQLite:
终端执行sqlite3，打开 SQLite 命令提示符

打开或者创建数据库，终端执行
sqlite3 DatabaseName.db
这个命令会再次打开SQLite 命令提示符，接着就可以使用SQL语言来操作这个数据库

.quit 退出
.help 帮助
.table 当前数据库，查看所有表名称

.schema polls_question 查看 表polls_question 的结构，只有当表中有数据时才能看到，否则不会打印任何信息

查看 表polls_question 的所有数据
select * from polls_question;

注意：在sqlite3 DatabaseName.db之后，SQLite 命令提示符下，既可以使用 一个. 加上具体命令语句 的形势操作数据库，
也可以使用SQL语言去操作数据库，区别是SQL语言要 以分号;结尾






------------------------------------------------------------------------

Html各种标签属性：

<a> 标签定义超链接，用于从一张页面链接到另一张页面。
<a> 元素最重要的属性是 href 属性，它指示链接的目标。
<a> 标签的 href 属性用于指定超链接目标的 URL。
例如：
<a href="http://www.w3school.com.cn">W3School</a>



------------------------------------------------------------------------

表1：商品分类
分类ID（主键）	分类名称
1		鞋子
2		衣服
3		裤子

表2：商品
商品ID（主键	商品名称  商品简介  商品分类（外键）  分类ID（外键）
1		短袖	无	 衣服		2
2		牛仔裤	无	 裤子		3
3		跑鞋	无	 鞋子		1
4		外套	无	 衣服		2



表3：用户
用户id（主键）	用户名
1		A
2		B
3		C


表4：对话列表
id		对话内容		发送方

















