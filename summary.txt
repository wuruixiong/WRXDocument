ffmpeg
SIP
Anychat for Android


ANRs (“Application Not Responding”)


将字符串转为整型，资源
    Field field=R.drawable.class.getField("icon");
    int drawable= field.getInt(new R.drawable());
	
	
如果自定义layout中有EditText，点击EditText会弹出输入法，此时会调用自定义layout或view的onMeasure方法，
所以，使用此策略可以监听输入法弹出

自定义view在xml中使用，通常会在objec(context, attrs)的构造方法中进入

修改代码时，若想要获取之前view的配置，例如图片、颜色、字号等，可以调试，获取之前view的信息，通过view查找配置


listview继承自AbsListView，AbsListView中封装了对view的回收处理，使用setRecyclerListener对view被回收时做出处理

在使用listview，recycleview等进行嵌套时，系统本身不会对里面的listview进行宽高计算，所以要手动计算宽高，并设置里面的listview

自定义view中重写onTouchEvent，返回false，则该控件不响应点击，
例如在RelativeLayout, FrameLayout中摆放一些控件，再在最顶层摆放一个覆盖布局的控件，
此时如果在onTouchEvent中返回flase则该控件不处理touch，并且底层控件可以处理touch事件
注：RelativeLayout也可以像FrameLayout那样有层级关系，xml中写在最下面的控件位于最顶层，code中最后加入的view位于最顶层

即使是在自定义view中重写onTouchEvent，他所响应到的区间也是他的父布局，即所产生的坐标是父布局的相对坐标而不是整个屏幕绝对的坐标，
所以对自定义view的TouchEvent做出响应，应该判断是不是view的区间
在view 的OnTouchListener事件中，若返回FALSE则继续向上传递，若返回TRUE则由监听方法处理
即如果想要处理move移动事件或者up弹起事件要返回TRUE
有些控件，例如checkbox，即使不设置click监听也会对点击作出响应，这时需要在控件中加入
android:focusable="false"
android:focusableInTouchMode="false"
此时就会和listview本身的点击互不影响


可以在canvas中通过控制矩阵Matrix来控制旋转rotate和缩放scale
在使用Matrix处理bitmap旋转、缩放、平移时，平移会和旋转、缩放冲突，导致只能执行其中一个，
可以先使用Matrix.setTranslate设置平移距离，再使用Matrix.postRotate、Matrix.postScale来处理冲突问题
				
				
scroll的三大状态(能滑动的控件，listview，gridview，recycleview都有)： SCROLL_STATE_IDLE, SCROLL_STATE_DRAGGING or SCROLL_STATE_SETTLING.
IDLE指的是控件没有在滑动(SCROLL_STATE_IDLE为0)
DRAGGING指的是控件在滑动，手指在屏幕上移动(SCROLL_STATE_DRAGGING为1)
SETTLING指的是控件在滑动，手指已经放开屏幕，控件处于自动的动画滑动中(SCROLL_STATE_SETTLING为2)


主线程中创建handler，主要用来修改UI界面
Handler handler;
onCreate
{
	handler=new Handler();
}
//接着在任意地方
handler.post(new runable(可以传入参数));
//定义一个Runnable
private class runable implements Runnable
    {
        //构造方法
        private runable()
        {
        }
//实例化Runnable借口必须实现的
        @Override
        public void run(){
        }
    }
	

通过使用message调用handle
        Handler mHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
            }
        };
调用：
mHandler.sendEmptyMessage(0);
注：一般发送的是Message，在handleMessage()方法中判断Message，执行不同的代码段


在android使用handler.post(runnable)，并不会开启新的线程，而是将消息压到main线程使用的消息池中，
所以handler.post还是在主线程中，
可以使用Thread.currentThread().getId()或者Thread.currentThread().getName()来确定当前线程，

而使用  Thread thread = new Thread(runnable);thread.start(); 才是开启一个新的线程，
 
  而使用以下发送Message的方法也是在主线程当做执行
            Handler handler = new Handler(new Handler.Callback() {
                @Override
                public boolean handleMessage(Message msg) {
                    Log.w("sendEmptyMessage",Thread.currentThread().getName());
                    return false;
                }
            });
            handler.sendEmptyMessage(1);

即使是在线程中发送消息，最后handle的执行也是在主线程当中
            final Handler handler = new Handler(new Handler.Callback() {
                @Override
                public boolean handleMessage(Message msg) {
                    Log.w("runnable2",Thread.currentThread().getName());
                    return false;
                }
            });
            Runnable runnable2 = new Runnable() {
                @Override
                public void run() {
                    handler.sendEmptyMessage(1);
                }
            };
            Thread thread = new Thread(runnable2);
            thread.start();

可以使用特殊线程HandlerThread,可以很好的和handle结合在一起使用
            mWorkThread = new HandlerThread("threadname");
            mWorkThread.start();
            Handler workHandler = new Handler(mWorkThread.getLooper(), new Handler.Callback() {
                @Override
                public boolean handleMessage(Message msg) {
                    return false;
                }
            });
            workHandler.sendEmptyMessage(1);
			
			
综上，加载数据使用Thread开启一个线程，加载完成之后，在线程当中send或者post，handle消息，
通知主线程修改界面。


周报：
2014.12.15-2014.12.19 周报——xxx

------------------ Original ------------------
From:  "吴锐雄"<wuruixiong@emojikeyboard.mobi>;
Date:  Fri, Dec 19, 2014 02:32 PM
To:  "houhuihua"<houhuihua@emojikeyboard.mobi>;
Subject:  一周工作总结报告-吴锐雄

xxx先生
　　您好：
我因学校课业原因，于2015年4月17日将在学校进行体能考试，无法按时上班，特向xxx先生在2015年4月17日请假一天，请xxx先生批准。
　　　　　　　　　　　　　　　　　　　　　　　　　　　——请假人：吴锐雄
　　　　　　　　　　　　　　　　　　　　　　　　　　　　2015年4月16日


改变背景颜色：
这样输入：              layout.setBackgroundColor(Color.parseColor("#ffff00"));
或者这样输入：           layout.setBackgroundColor(0xFF6db7ff);
0xFF6db7ff是Android中特殊的16进制颜色编码，FF表示的是透明度，6db7ff表示颜色编码
表达式顺序是“aabbggrr”，其中“aa=alpha”（00 到 ff,00透明度为0，ff透明度为100%）；“bb=blue”（00 到 ff）；“gg=green”（00 到 ff)；“rr=red”（00 到 ff）


java 代码修改控件高宽
        RelativeLayout.LayoutParams params=new RelativeLayout.LayoutParams((gwidth-40)/glistcount,(int)((gwidth-40)/glinecount*0.99));
//new RelativeLayout.LayoutParams(40,40);像素值
//new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);自适应
        控件.setLayoutParams(params);


android颜色color.xml设置  
<?xml version="1.0" encoding="utf-8"?>
<resources>
<color name="white">#FFFFFF</color><!--白色 -->
</resources>


计时器控件chronometer
chronometer.getText()得到时间
chronometer.stop();结束
chronometer.start();开始
chronometer.setBase(SystemClock.elapsedRealtime());设施开始时间为00:00

沉睡：
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace(); 
        }



WindowManager：
//使用时加入许可
//<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    WindowManager wmManager;
    WindowManager.LayoutParams wmParams;
        wmManager=(WindowManager) getSystemService(Context.WINDOW_SERVICE);
        wmParams = new WindowManager.LayoutParams();
        /**
         *以下都是WindowManager.LayoutParams的相关属性
         * 具体用途请参考SDK文档
         */
        wmParams.type=2002;   //这里是关键，你也可以试试2003
        wmParams.format=1;
        /**
         *这里的flags也很关键
         *代码实际是wmParams.flags |= FLAG_NOT_FOCUSABLE;
         *40的由来是wmParams的默认属性（32）+ FLAG_NOT_FOCUSABLE（8）
         */
        wmParams.flags=80;

	Button bb=new Button(getApplicationContext());

                if(mm.getParent()!=null) {
                    wmManager.removeView(bb);
                }
                else
                {
                    if(mm.getParent()==null)
                    {
                        wmManager.addView(bb, wmParams);

                    }
                }



导航栏高度：
ActionBar actionBar;
actionBar=getActionBar();
actionBar.getHeight();

//得到gridview的子视图
gridview.getChildAt(填入下标)

PreferenceScreen点击之后没有actionbar是因为没有设置title属性的原因
当工程失去R文件时重新编译就会出现一个新的R文件

    //设置全背景为一张图，包括actionbar
    private void setBackgrounnd() {
        Activity context =this;
        ViewGroup root =  (ViewGroup)context.getWindow().getDecorView();
        if (root != null) {
            ViewGroup group = ((ViewGroup)root.getChildAt(0));
            group.setBackgroundResource(R.drawable.background);
        }
    }


自定义View的监听回调机制

public class colorpick extends View{

（1）在自定义View的类内预留接口
 public interface OnColorChangedListener {
        void colorChanged(int color);
    }

（2）在自定义View的类内创建一个该接口
private OnColorChangedListener mListener;

（3）在构造方法中对创建的接口赋值
    public colorpick(Context context,
                             OnColorChangedListener listener,
                             int initialColor) {
        mListener = listener;
    }

（5）至此，就可以在View的内部调用实例化好的接口，如下，对mListener.colorChanged输入0xff0000ff的参数，因为mListener在构造方法中被赋值，相当于外部定义的colorpick赋值给了mListener，
        所以，mListener的colorChanged方法会有Log.w("color is "+color,"color is "+color);的语句，会在控制台输出log

	mListener.colorChanged(0xff0000ff);
}

（4）在外部创建自定义View
                colorpick colorpick1= new colorpick(testactivity.this, new colorpick.OnColorChangedListener() {
                    @Override
                    public void colorChanged(int color) {
                        Log.w("color is "+color,"color is "+color);
                    }
                }
                ,0xff000000);



混合渲染ComposeShader显示无效果时，需要在配置文件中加入
<activity android:hardwareAccelerated="false" />
或者
<application android:hardwareAccelerated="false" >


获取自定义view的颜色值
	int pixel;
	View view；
	Bitmap bitmap;
                view.buildDrawingCache();
                bitmap = view.getDrawingCache();
                pixel = bitmap.getPixel((int)event.getX(),(int)event.getY());



设置EditText的输入范围
    private void setRegion_0_255(final EditText et)
    {
        final int MIN_MARK = 0;
        final int MAX_MARK = 255;
        et.addTextChangedListener(new TextWatcher() {
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                if (start > 1)
                {
                    if (MIN_MARK != -1 && MAX_MARK != -1)
                    {
                        int num = Integer.parseInt(s.toString());
                        if (num > MAX_MARK)
                        {
                            s = String.valueOf(MAX_MARK);
                            et.setText(s);
                        }
                        else if(num < MIN_MARK)
                            s = String.valueOf(MIN_MARK);
                        return;
                    }
                }
            }

            @Override
            public void beforeTextChanged(CharSequence s, int start, int count,
                                          int after) {
            }

            @Override
            public void afterTextChanged(Editable s)
            {
                if (s != null && !s.equals(""))
                {
                    if (MIN_MARK != -1 && MAX_MARK != -1)
                    {
                        int markVal = 0;
                        try
                        {
                            markVal = Integer.parseInt(s.toString());
                        }
                        catch (NumberFormatException e)
                        {
                            markVal = 0;
                        }
                        if (markVal > MAX_MARK)
                        {
                            Toast.makeText(getBaseContext(), "输入范围0-255", Toast.LENGTH_SHORT).show();
                            et.setText(String.valueOf(MAX_MARK));
                        }
                        return;
                    }
                }
            }
        });
    }



判断EditText中是否有字符串

                if(TextUtils.isEmpty(rEditText.getText()))
                {
                    Log.w("r is null","r is null");
                }
                else
                {
                    if(!TextUtils.isEmpty(rEditText.getText()))
                    {
                        Log.w("r is value","value is"+rEditText.getText());
                    }
                }


调节边距可以尝试padding和margin


match_parent,在android线性布局中比较可以生效，需要加上  
android:layout_weight="1"


自定义控件，onMeasure可以设置空间的大小,只有当所在的控件设置为match_parent时才能有数值，
而设置wrap_content时widthMeasureSpec和heightMeasureSpec是没有数值的，因为wrap_content是自己计算宽度和高度的。
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        w=measure(widthMeasureSpec);
        setMeasuredDimension(w,w);
    }

    private int measure(int measureSpec) {
        int result = 0;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if (specMode == MeasureSpec.EXACTLY) {
            result = specSize;
        } else {
            if (specMode == MeasureSpec.AT_MOST) {
                result = Math.min(result, specSize);
            }
        }
        return result;
    }



android:digits
指定接受固定的数字，如android:digits="012345"，则只接受0～5数字的输入


context启动Activity
 getContext().startActivity(intent);
或者mContext.startActivity(intent);


    使用别的包的资源：
不把图片放在res/drawable下，而是存放在src某个package中（如：com.drawable.resource），这种情况下的调用方法为： 
String path = "com/drawable/resource/imageName.png"; 
InputStream is = getClassLoader().getResourceAsStream(path); 
Drawable.createFromStream(is, "src"); 

如果还是希望直接使用res/drawable中的图片，就需要通过下面的方法了： 
假设创建工程的时候，填写的package名字为：com.test.image 
int resID = getResources().getIdentifier("imageName", "drawable", "com.test.image"); 
Drawable image = getResources().getDrawable(resID);


自定义layout
使用以下方法加载布局，为控件找到ID
       LayoutInflater inflater=(LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
      inflater.inflate(R.layout.editkeyboard_layout, this);
        upButton = (Button)findViewById(R.id.up) ;
或者（其实都一样）
       LayoutInflater inflater=LayoutInflater.from(mContext);
        View contextVie=inflater.inflate(R.layout.editkeyboard_layout, EditKeyboardLayout.this);
        upButton = (Button)contextVie.findViewById(R.id.up) ;
		
在自定义layout中使用merge标签来包含子控件，例如：
<merge
    xmlns:android="http://schemas.android.com/apk/res/android">
    <ImageButton/>
    <LinearLayout/>
    <LinearLayout>
        <TextView/>
    </LinearLayout>
    <ImageButton/>
</merge>



输入法和EditText的光标移动，选择，粘贴，删除：

	EditText:

        editKeyboardLayout.setLeftButton(new EditKeyboardListener.leftClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection()) {
                    Selection.extendLeft(editText.getText(), editText.getLayout());
                } else {
                    Selection.moveLeft(editText.getText(), editText.getLayout());
                }
            }
        });

        editKeyboardLayout.setRightButton(new EditKeyboardListener.rightClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection()) {
                    Selection.extendRight(editText.getText(), editText.getLayout());
                } else {
                    Selection.moveRight(editText.getText(), editText.getLayout());
                }
            }
        });

        editKeyboardLayout.setUpButton(new EditKeyboardListener.upClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection()) {
                    Selection.extendUp(editText.getText(), editText.getLayout());
                } else {
                    Selection.moveUp(editText.getText(), editText.getLayout());
                }
            }
        });


        editKeyboardLayout.setDownButton(new EditKeyboardListener.downClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection()) {
                    Selection.extendDown(editText.getText(), editText.getLayout());
                } else {
                    Selection.moveDown(editText.getText(), editText.getLayout());
                }
            }
        });

        editKeyboardLayout.setChooseButton(new EditKeyboardListener.chooseClickListener() {
            @Override
            public void onClick(View v) {
                if (editKeyboardLayout.getIsSelection() == false) {
                    editKeyboardLayout.setIsSelection(true);
                } else {
                    if (editKeyboardLayout.getIsSelection() == true) {
                        editKeyboardLayout.setIsSelection(false);
                    }
                }
            }
        });

        editKeyboardLayout.setCopyButton(new EditKeyboardListener.copyClickListener() {
            @Override
            public void onClick(View v) {
                int start = Math.min(editText.getSelectionStart(), editText.getSelectionEnd());
                int end = Math.max(editText.getSelectionStart(), editText.getSelectionEnd());
                if (editKeyboardLayout.getIsSelection() && start != end) {
                    selectText = editText.getText().subSequence(start, end).toString();
                }
                mClipBoardLayout.setClipText(selectText);
            }
        });

        editKeyboardLayout.setPasteButton(new EditKeyboardListener.pasteClickListener() {
            @Override
            public void onClick(View v) {
                if (selectText != null) {
                    editText.getText().insert(Selection.getSelectionStart(editText.getText()), selectText);
                }

            }
        });

        editKeyboardLayout.setCutButton(new EditKeyboardListener.cutClickListener() {
            @Override
            public void onClick(View v) {
                int start = Math.min(editText.getSelectionStart(), editText.getSelectionEnd());
                int end = Math.max(editText.getSelectionStart(), editText.getSelectionEnd());
                if (editKeyboardLayout.getIsSelection() && start != end) {
                    selectText = editText.getText().subSequence(start, end).toString();
                    editText.getText().delete(start, end);
                }
            }
        });

        editKeyboardLayout.setDeleteButton(new EditKeyboardListener.deleteClickListener() {
            @Override
            public void onClick(View v) {
                int start = Math.min(editText.getSelectionStart(), editText.getSelectionEnd());
                int end = Math.max(editText.getSelectionStart(), editText.getSelectionEnd());
                if (editKeyboardLayout.getIsSelection()) {
                    editText.getText().delete(start, end);
                } else {
                    editText.getText().delete(end - 1, end);
                }

            }
        });



	输入法:
	通过发送KeyEvent执行光标移动操作，通过得到getCurrentInputConnection而得到当前光标位置并可执行插入粘贴板字符串的操作

    public void startSelect(){
        thisInputConnection = mLatinIME.getCurrentInputConnection();
        if(thisInputConnection != null)
            thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT));
    }

    public void endSelect(){
        if(thisInputConnection != null){
            thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT));
        }
    }


	
	editLayout.setUpButton(new EditKeyboardListener.upClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_UP));
            }
        });
        editLayout.setDownButton(new EditKeyboardListener.downClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_DOWN));
            }
        });
        editLayout.setRightButton(new EditKeyboardListener.rightClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_RIGHT));
            }
        });
        editLayout.setLeftButton(new EditKeyboardListener.leftClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DPAD_LEFT));
            }
        });
        editLayout.setChooseButton(new EditKeyboardListener.chooseClickListener() {
            @Override
            public void onClick(View v) {
                ChooseView = v;
                if (ChooseFlag == false) {
                    startSelect();
                    Toast.makeText(getContext(), "Start Choosing", Toast.LENGTH_SHORT).show();
                    ChooseFlag = true;
                    v.setBackgroundResource(R.drawable.choose_highlight);
                } else {
                    endSelect();
                    Toast.makeText(getContext(), "Stop Choosing", Toast.LENGTH_SHORT).show();
                    v.setBackgroundResource(R.drawable.choose_bt);
                    ChooseFlag = false;
                }
            }
        });
        editLayout.setCopyButton(new EditKeyboardListener.copyClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                if (thisInputConnection.getSelectedText(1000) != null) {
                    Toast.makeText(getContext(), "Complete copy", Toast.LENGTH_SHORT).show();
                    clipboardManager.setText(thisInputConnection.getSelectedText(1000));
                }
            }
        });
        editLayout.setPasteButton(new EditKeyboardListener.pasteClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                if (clipboardManager.getText().length() > 0) {
                    thisInputConnection.setComposingText(clipboardManager.getText(), 1);
                }
//                else {
//                    thisInputConnection.setComposingText("PASTE", 1);
//                }
            }
        });
        editLayout.setDeleteButton(new EditKeyboardListener.deleteClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
            }
        });
        editLayout.setCutButton(new EditKeyboardListener.cutClickListener() {
            @Override
            public void onClick(View v) {
                if (thisInputConnection.getSelectedText(1000) != null) {
                    setPopEditKeyboard();
                    Toast.makeText(getContext(), "Complete cut", Toast.LENGTH_SHORT).show();
                    clipboardManager.setText(thisInputConnection.getSelectedText(1000));
                    thisInputConnection.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
                }
            }
        });
        editLayout.setSelectAllButton(new EditKeyboardListener.selectAllClickListener() {
            @Override
            public void onClick(View v) {
                setPopEditKeyboard();
                //to using selectALL
                thisInputConnection.performContextMenuAction(16908319);
                thisInputConnection.performContextMenuAction(16908319);
            }
        });
        editLayout.setBackButton(new EditKeyboardListener.backClickListener() {
            @Override
            public void onClick(View v) {
                if (popEditKeyboard != null && popEditKeyboard.isShowing()) {
                    popEditKeyboard.dismiss();
                }
            }
        });



在AndroidManifest中
android:launchMode 控制activitiy弹出方式 



Time t=new Time(); 
t.setToNow(); 
int year = t.year;  
int month = t.month;  
int date = t.monthDay;  
int hour = t.hour; // 0-23  
int minute = t.minute;  
int second = t.second;  

1月份t.month为0，第一天t.yearDay为0.



子View脱离父View再加入新View：
        InputView view = (InputView)mKeyboardSwitcher.getInputView();
        if (view.getParent() != null) {
            ViewGroup parent = (ViewGroup)view.getParent();
            parent.removeView(view);
        }
        LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);
        mLinearLayout.addView(view, p);


	
屏幕宽度：	
	WindowManager wm = (WindowManager) getContext()
                    .getSystemService(Context.WINDOW_SERVICE);
 
     int width = wm.getDefaultDisplay().getWidth();
     int height = wm.getDefaultDisplay().getHeight();

	 
TextView文字居中：
1.在xml文件设置：android:gravity="center"
2.在程序中设置：m_TxtTitle.setGravity(Gravity.CENTER);

TextViews从dimen中获取字号
        mGetPaintTextView = new TextView(mContext);
        mGetPaintTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, mContext.getResources().getDimension(R.dimen.yantext_size));


popupwindow:
创建：
view是什么布局参数2和3的LayoutParams可以采用什么，也可以填入固定整型数值
mPopupWindow = new PopupWindow(view, LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);

附着锚点显示：mPopupWindow.showAsDropDown(mButton);
showAsDropDown有不同的函数提供重载
mPopupWindow.dismiss();隐藏

 创建PopupWindow
     步骤1：初始化
	 PopupWindow popupWindow = new PopupWindow();
	 步骤2：设置ContentView
        LayoutInflater layoutInflater = LayoutInflater.from(mContext);
        View view1 = layoutInflater.inflate(R.layout.yantext_listview_item_layout, null);
        TextView textView = (TextView) view1.findViewById(R.id.yantext_view1);
        textView.setText("sfksidfxdhgsdghsrhgrg");
        popupWindow.setContentView(view1);
	步骤3：设置宽高
        popupWindow.setHeight(200);
        popupWindow.setWidth(200);
	步骤4：显示
        popupWindow.showAsDropDown(mAnchor);
	步骤5：消失
		popupWindow.dismiss();

LinearLayout设置控件居中，要在LinearLayout中设置：
android:gravity="center"

//点击外部PopupWindow消失
        mSharePopupWindow.setBackgroundDrawable(new BitmapDrawable());
        mSharePopupWindow.setOutsideTouchable(true);


ImageView设置 android:scaleType="centerInside"
如果设置了view的width和height大于wrap_content，内部的图片会wrap_content
ListView设置
xml：
//去除ListView滑到顶部和底部时边缘的黑色阴影：
android:fadingEdge="none"
//去除拖动时默认的黑色背景：
android:cacheColorHint="#00000000"
//去除选中时的黄色底色：
android:listSelector="#00000000"  
java：
//去除行与行之间的黑线：
msgList.setDivider(null);  
//ListView刷新后自动滚到最底部：
msgList.setSelection(msgList.getAdapter().getCount()-1);


字符串"R.drawable" 转换资源整型：
方法1：
try{  
 Field field=R.drawable.class.getField("icon");  
 int i= field.getInt(new R.drawable());  
  Log.d("icon",i+"");  
}catch(Exception e){  
 Log.e("icon",e.toString());  
}

方法2：
Resources res=getResources();  
int i=res.getIdentifier("icon","drawable",getPackageName());  
Log.i("res",Integer.toString(i));



检测apk是否安装在手机上：

获得包名列表：
        PackageManager packageManager = mContext.getPackageManager();
        List<ApplicationInfo> appList = packageManager.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);
检测报名：
 for (ApplicationInfo applicationInfo : appList) { 
	String pkgName = applicationInfo.packageName;
	//对比前缀
	if (pkgName.startsWith("prefix name")) {}
 }

 获取其他pkg下的Resource
 Resources res = packageManager.getResourcesForApplication(pkgName);
 获取其他pkg下的Drawable
 int mDrawableResID = res.getIdentifier(drawableName, "drawable", pkgName);
 mTestDrawable = res.getDrawable(mDrawableResID);
 得到Asset资源
 InputStream is = res.getAssets().open(fileName);
 
 
 在循环中，break是退出循环体，continue是结束当前这次循环开始下一次循环

 
在viewpager中如果删除页面并删除页面的数据，再显示控件，会有部分页面显示数据为空，
mYanPagerAdapter = mViewPager.getAdapter(); 得到Adapter
mViewPager.setAdapter(null); 			设置Adapter为空
mViewPager.setAdapter(mYanPagerAdapter); 再把Adapter设置回去可解决


获得安装的包的信息列表
        PackageManager packageManager = mContext.getPackageManager();
        List<ApplicationInfo> appList = packageManager.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES); 

		
		
设置view的可见性：
View.setVisibility 
GONE：不可见，不占据位置，即原来的位置会被有fill_parent的控件占据
INVISIBLE：不可见，占据位置，即还有宽高
VISIBLE：可见


在ui thread中调用view的invalidate方法可以通知view重绘制(刷新)，重绘制将调用onDraw()方法来重新绘制view

得到acticity中的contentview： content=(ViewGroup)this.findViewById(android.R.id.content)

在FrameLayout中，放在下面的子控件是叠在上面的，即第一个子控件是位于最底层的

在android的try，catch中可以利用Exception来输出类似于程序崩溃时的错误信息，包括了错误类型(Exception类)，
具体的错误java文件和错误行数
	try {
	} catch (Exception e) {
		Log.e("MyError", "Exception", e); //输出log level为error
		e.printStackTrace();			//输出log level为warn
	}
	
	



在recycleview中，在getItemViewType返回position就可以在onCreateViewHolder中的viewType得到position，
这种使用方法并不是对viewType的正确使用
        @Override
        public int getItemViewType(int position) {
            return position;
        }

        @Override
        public EmojiSelectViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        }
		
recycleview滑动监听，onScrolled不是滑动之后才会调用，而是在滑动时就会调用，
个人认为应该是从一个点移动到另一个点就会调用（有待研究）
        mScrollListener = new RecyclerView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
            }
            @Override
            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
                Log.e("onScrolled", "onScrolled");
            }
        };
        mRecyclerView.setOnScrollListener(mScrollListener);
		

自定义xml属性：
(1)建立res/values/attrs.xml文件
(2)在attrs.xml写入
<resources>
   <declare-styleable name="PieChart">
       <attr name="showText" format="boolean" />
       <attr name="labelPosition" format="enum">
           <enum name="left" value="0"/>
           <enum name="right" value="1"/>
       </attr>
   </declare-styleable>
</resources>
(3)使用，特别注意在gradle工程中使用： xmlns:custom="http://schemas.android.com/apk/res-auto"
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
   xmlns:custom="http://schemas.android.com/apk/res/com.example.customviews">
 <com.example.customviews.charting.PieChart
     custom:showText="true"
     custom:labelPosition="left" />
</LinearLayout>
(4)在带有AttributeSet的系统提供的构造方法中获取数值：
public PieChart(Context context, AttributeSet attrs) {
   super(context, attrs);
   TypedArray a = context.getTheme().obtainStyledAttributes(
        attrs,
        R.styleable.PieChart,
        0, 0);

   try {
       mShowText = a.getBoolean(R.styleable.PieChart_showText, false);
       mTextPos = a.getInteger(R.styleable.PieChart_labelPosition, 0);
   } finally {
       a.recycle();
   }
}
(5)TypedArray.getResourceId();
可以取得format="reference" 的数值


多点触控：
使用 onTouchEvent方法来实现，
action由MotionEventCompat.getActionMasked(event)方法来获取，不再使用event.getAction()方法来获取：
action = MotionEventCompat.getActionMasked(event);
switch (action)
	case MotionEvent.ACTION_DOWN: //第一个点按下
	case MotionEvent.ACTION_POINTER_DOWN: //第二个点或者之后的点按下，这时候要判断2 <= event.getPointerCount()，通常会有2个以上
	case MotionEvent.ACTION_MOVE: 		//遍历所有的点
		for(int i = 0; i < event.getPointerCount(); i++){
            event.getX(i);
            event.getY(i);
			} 
	case MotionEvent.ACTION_POINTER_UP: //有点离开就会调用，event.getActionIndex()获取离开的点，触点的排列顺序的从第一个按下排列到最后一个
										//例如upPointIndex为0，就是第一个按下的点离开了屏幕；upPointIndex为2，就是第三个按下的点离开了屏幕，
		int upPointIndex = event.getActionIndex();
	case MotionEvent.ACTION_UP: //最后一个点离开屏幕



分享图片：
获取bitmap的URI
                Bitmap bitmap = mDesignContainer.getDrawingCache();
                String pathofBmp = MediaStore.Images.Media.insertImage(EditActivity.this.getContentResolver(), bitmap, null, null);
                Uri bmpUri = Uri.parse(pathofBmp);

指定包名的分享：
                    Intent shareIntent = new Intent(Intent.ACTION_SEND);
                    shareIntent.setType("image/*");
                    shareIntent.setPackage("com.facebook.katana");
                    shareIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    shareIntent.putExtra(Intent.EXTRA_STREAM, mBitmapUri);
                    mContext.startActivity(shareIntent);

打开系统的分享列表，选择指定的分享应用：
                    Intent shareIntent = new Intent(Intent.ACTION_SEND);
                    shareIntent.setType("image/*");
                    shareIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    shareIntent.putExtra(Intent.EXTRA_STREAM, mBitmapUri);
                    mContext.startActivity(Intent.createChooser(shareIntent, "share imger"));

获取响应该分享的应用列表：
					  Intent intent = new Intent(Intent.ACTION_SEND, null);
					intent.addCategory(Intent.CATEGORY_DEFAULT);
					intent.setType("image/*");
					PackageManager pManager = EditActivity.this.getPackageManager();
					mShareImgList = pManager.queryIntentActivities(intent, PackageManager.COMPONENT_ENABLED_STATE_DEFAULT);

					
					
在gridview，recycleview等view中如果设置一个带有按下状态的drawable给每个item会产生按下状态混乱的BUG，
需要给每个item都配置一个带有按下状态的drawable，例如在每次设置item时调用以下方法，赋值一个新的drawable

    public static Drawable cloneDrawableWithState(Context context, Drawable origin) {
        final Drawable.ConstantState constantStateDrawable = origin.getConstantState();
        return (constantStateDrawable != null)
            ? constantStateDrawable.newDrawable(context.getResources()).mutate()
            : origin;
    }
					
					
					

给edittext或searchview设置提示字符串和提示图标:
1.构建SpannableStringBuilder或者spannableString
SpannableStringBuilder ssb = new SpannableStringBuilder("title");
或者 SpannableString spannableString = new SpannableString("title");

2.构建ImageSpan
ImageSpan imageHint = new ImageSpan(drawable);

3.字号(可以不设)
int textSize = (int) (searchAutoComplete.getTextSize() * 1.25);
searchIcon.setBounds(0, 0, textSize, textSize);

4.将包含了图标的ImageSpan设进去
ssb.setSpan(new ImageSpan(searchIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
spannableString.setSpan(imageHint, 0, 1, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);

5.设置
mEditor.setHint(spannableString);

SearchView.SearchAutoComplete searchAutoComplete = (SearchView.SearchAutoComplete) mSearchView.findViewById(android.support.v7.appcompat.R.id.search_src_text);
searchAutoComplete.setHint(spannableString);

总体：
SpannableStringBuilder ssb = new SpannableStringBuilder("    ");
ssb.append("hint");
 int textSize = (int) (searchAutoComplete.getTextSize() * 1.25);
searchIcon.setBounds(0, 0, textSize, textSize);
ssb.setSpan(new ImageSpan(searchIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);	
 searchAutoComplete.setHint(ssb);		
 
注：在开发过程中遇到过想要去除searchview提示图标去除不了的情况，直接把一个字符串的id设置就可以了，例如：
searchAutoComplete.setHint(R.string.mediapicker_gif_title);
					
					
SearchView
关闭edittext collapseActionView()
展开edittext expandActionView()

也可以对SearchView对应的MenuItem调用collapseActionView()，也可以关闭
mSearchItem = menu.findItem(R.id.action_gif_search);
mSearchView = (SearchView) mSearchItem.getActionView();


onSizeChanged()方法可以获取高宽，但是不合适在获取高宽之后再利用获取的数值进行子控件的设置



Fragment
放置在Activity中，可以通过FragmentManager进行交互和管理Fragment，

使用方法1：在xml中放置，Activity的onCreateView()方法设置即可 
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    <fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
</LinearLayout>

方法2：使用FragmentTransaction，其中R.id.fragment_container是一个放置fragment的layout

FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();


获取：使用find id和find tag获取fragment
findFragmentById() 


在设置visible时，设置layout为gone，layout的子布局的visible并不会为gone



span:
SpannableString 在setSpan时需要指定flag，以下四种中的其中一种，
如果设置了SPAN_EXCLUSIVE_EXCLUSIVE指的是如果设置SpannableString改变字体颜色，那么在SpannableString的
之前和之后再输入字符都不会出现改变字体颜色的效果。
如果设置了SPAN_INCLUSIVE_INCLUSIVE指的是如果设置SpannableString改变字体颜色，那么在SpannableString的
之前和之后再输入字符都会出现改变字体颜色的效果。
Spanned.SPAN_EXCLUSIVE_EXCLUSIVE(前后都不包括)
Spanned.SPAN_INCLUSIVE_EXCLUSIVE(前面包括，后面不包括)
Spanned.SPAN_EXCLUSIVE_INCLUSIVE(前面不包括，后面包括)
Spanned.SPAN_INCLUSIVE_INCLUSIVE(前后都包括)


private abstract void print();  //抽象方法定义，继承该方法所在的类必须实现该方法


在自定义的layout或者普通layout中如果设置了高宽为wrap_content，这时候再设置padding那么会挤压外部的空间
如果设置了高宽为固定大小例如20dp，那么会挤压内部子view
例如:
1.wrap_content下,设置paddingTop为100dp那么layout会包裹住子view之外再变大100dp,这样会把layout之外的view挤下去
2.设置高度10dp下,设置paddingTop为100dp那么所有子view会看不见,设置paddingTop为5dp子view会只能在layout的下半部看到,而layout的上半部会是空白的


// 得到缩放比例，scale乘以具体的dp数等于像素值
final float scale = context.getResources().getDisplayMetrics().density;  
scale * dp = px


//得到APP的内部存储空间：/data/data/your.package.name/files
getContext().getFilesDir()


//Adapter.notifyDataSetChanged() 调用会重新计算，即调用onMeasure

//如果一个View由gone变为visible就会调用onMeasure



public class JavaClassTest {
    public JavaClassTest() {
    }
    public class InternalClass{
        public InternalClass() {
        }
    }
}
// 在类的外部使用类的内部类必须先实例化类，通过类去实例化其内部类
JavaClassTest javaClassTest = new JavaClassTest();
JavaClassTest.InternalClass internalClass = javaClassTest.new InternalClass();


调用一下代码，不用点击editText，editText也会出现光标，并且被选中
//前面2句只是设置使能，通常只调用第三句代码，即requestFocus
editText.setFocusable(true);
editText.setFocusableInTouchMode(true);
editText.requestFocus(); 

// editText可以被选中并出现光标，但不弹出键盘
editText.setTextIsSelectable.(true)


XmlResourceParser 解析

xml文件：
<?xml version="1.0" encoding="utf-8"?>
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:keyWidth="33%p"
          android:keyHeight="50dp"
          android:horizontalGap="0px"
          android:verticalGap="0px"
        >
    <Row>
        <Key android:keyLabel="1" android:codes="49" android:horizontalGap="1%p" android:keyWidth="32%p" />
        <Key android:keyLabel="2" android:codes="-1" app:keyUnderLabel="ABC" android:keyOutputText="2|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
        <Key android:keyLabel="3" android:codes="-1" app:keyUnderLabel="DEF" android:keyOutputText="3|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
    </Row>
    <Row>
        <Key android:keyLabel="4" android:codes="-1" app:keyUnderLabel="GHI" android:keyOutputText="4|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
        <Key android:keyLabel="5" android:codes="-1" app:keyUnderLabel="JKL" android:keyOutputText="5|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
        <Key android:keyLabel="6" android:codes="-1" app:keyUnderLabel="MNO" android:keyOutputText="6|" android:horizontalGap="1%p" android:keyWidth="32%p"/>
    </Row>
</Keyboard>

自定义属性：
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="Search_Keyboard_Key">
        <attr name="keyUnderLabel" format="string" />
		<attr name="keyWidth" format="dimension|fraction"/>
    </declare-styleable>
</resources>

1.读取顺序
try {
	int event;
	// parser.next() 是跳转到下一个标签，先跳转到子标签是子标签，没有子标签跳转同级标签
	// 按照上边的例子，如果当前标签是 Keyboard，下一个标签就是 Row， 第一个Row标签的下一个标签就是 Key
	
	while ((event = parser.next()) != XmlResourceParser.END_DOCUMENT) {
		if (event == XmlResourceParser.START_TAG) {
			// 每一个标签的开始，即 < 符号
			// 部分手机使用com.android.internal.R会报错
			TypedArray a = res.obtainAttributes(Xml.asAttributeSet(parser), 
                    com.android.internal.R.styleable.Keyboard);
			
		} else if (event == XmlResourceParser.END_TAG) {

			// 每一个标签的结束，即 > 符号
		}
	}
	// 该while循环的顺序是
	// Keyboard:XmlResourceParser.START_TAG 
	// -> Row:XmlResourceParser.START_TAG 
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Row:XmlResourceParser.END_TAG 
	// -> Row:XmlResourceParser.START_TAG 
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Key:XmlResourceParser.START_TAG -> Key:XmlResourceParser.END_TAG
	// -> Row:XmlResourceParser.END_TAG 
	// -> Keyboard:XmlResourceParser.END_TAG 
	// 注:第一遍循环的标签似乎是没有的，标签Keyboard在第二循环出现
} catch (Exception x){
}

2.读取自定义属性
if (event == XmlResourceParser.START_TAG) {
	TypedArray typedArray = getResources().obtainAttributes(Xml.asAttributeSet(parser), R.styleable.Search_Keyboard_Key);
	String underLabel = typedArray.getString(R.styleable.Search_Keyboard_Key_keyUnderLabel);
}


3.读取百分比数值，1%p，32%p 需要特殊读取方式
// 读取dimen或者fract(百分比)，如果是百分比数值会返回 参数base 乘以百分比的值
private static int getDimensionOrFraction(TypedArray a, int index, int base, int defValue) {
	TypedValue value = a.peekValue(index);
	if (value == null) return defValue;
	if (value.type == TypedValue.TYPE_DIMENSION) {
		return a.getDimensionPixelOffset(index, defValue);
	} 
	// 判断是不是百分比数值
	else if (value.type == TypedValue.TYPE_FRACTION) {
		return Math.round(a.getFraction(index, base, base, defValue));
	}
	return defValue;
}

// 自定义属性和android定义属性 作为参数的调用，部分手机使用com.android.internal.R(android定义属性)会报错
getDimensionOrFraction(typedArray, R.styleable.Search_Keyboard_keyWidth,
                    100, 50)
getDimensionOrFraction(typedArray, com.android.internal.R.styleable.Keyboard_keyWidth,
                    100, 50)

// 得到随机颜色
Random rnd = new Random(); 
int color = Color.argb(255, rnd.nextInt(256), rnd.nextInt(256), rnd.nextInt(256)); 
int color = Color.argb(255, rnd.nextInt(125) + 130, rnd.nextInt(125) + 130, rnd.nextInt(125) + 130);

// 分享 bitmap
private void shareBitmap(Bitmap bitmap) {
	FileOutputStream fos = null;
	try {
		// must create png file, then you can share this file
		File dir = new File(Environment.getExternalStorageDirectory() + File.separator + "StickerCache");
		if (!dir.exists()) {
			dir.mkdirs();
		}
		File imageFile = new File(dir,"StickerCache.png");
		fos = new FileOutputStream(imageFile);
		bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos);
		fos.close();
		
		// share imageFile
		Intent intent = new Intent(Intent.ACTION_SEND);
		intent.setType("image/*");
		intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(imageFile));
		startActivity(Intent.createChooser(intent, "Share"));
	}
	catch (IOException e) {
		if (fos != null) {
			try {
				fos.close();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
	}
}



// 从drawable中取得 inputstream 并转化成 uri
// 参数1：context，参数2: 包名，参数3：图片名
// 可以将生成出来的 uri 放浏览器的地址栏，可以出现一张图片
public static Uri getDataUri(Context context, String pkgName, String imageName) {
	InputStream inputStream = null;
	ByteArrayOutputStream byteBuffer = null;
	try {
		// 创建一个Context，来获得 其他应用的资源 或者 本应用的资源
		Context resContext = context.createPackageContext(pkgName, Context.CONTEXT_IGNORE_SECURITY);
		// 通过 图片名 取得图片资源的id
		int resId = resContext.getResources().
				getIdentifier(imageName, "drawable", pkgName);
		// 将该图片转化为inputStream
		inputStream = resContext.getResources().openRawResource(resId);
		byteBuffer = new ByteArrayOutputStream();
		int bufferSize = 1024;
		byte[] buffer = new byte[bufferSize];
		int len = 0;
		while ((len = inputStream.read(buffer)) != -1) {
			byteBuffer.write(buffer, 0, len);
		}
		// 将 该图片的输入流inputStream 转化为 字节数组byte[]
		byte[] imageRaw = byteBuffer.toByteArray();
		// 通过Base64加密
		String image64 = Base64.encodeToString(imageRaw, Base64.DEFAULT);
		// 构建 uri字符串
		String pageData = "data:image/*;base64," + image64;
		Uri uri = Uri.parse(pageData);
		return uri;
	} catch (Exception e) {
	} finally {
		// 关闭流
		if (inputStream != null) {
			try {inputStream.close();}
			catch(IOException ioex) {}
		}
		if (byteBuffer != null) {
			try {byteBuffer.close();}
			catch(IOException ioex) {}
		}
	}
	return null;
}


// 读取 其他apk包的 gif 资源，转化成输入流，保存为 .gif 文件
// 核心方法 openRawResource() 该方法可以用来读取 drawable文件夹或者raw文件夹下的资源并转化为流
public static File getGifFile(Context context, String pkgName, String resName) {
	Boolean isSDPresent = android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
	File absoluteDir = new File(context.getApplicationContext().getExternalCacheDir().getAbsolutePath());
	if (isSDPresent && absoluteDir.exists() && null != context && null != pkgName && null != resName) {
		String imgDirectoryPath = context.getApplicationContext().getExternalCacheDir().getAbsolutePath()+ "/" + "StickerCache";
		File directory = new File(imgDirectoryPath);
		if (!directory.isDirectory() || !directory.exists()) {
			directory.mkdirs();
		}
		//File file = new File(directory, STICKER_TEMPORARY_PATH + ".gif");
		File file = new File(directory, resName + ".gif");
		if (file.exists()) {
			file.delete();
		}
		InputStream inputStream = null;
		OutputStream outputStream = null;
		try {
			Context resContext = context.createPackageContext(pkgName, Context.CONTEXT_IGNORE_SECURITY);
			inputStream = resContext.getResources().openRawResource(ResUtils.resNameToResId(resContext, resName));
			outputStream = new FileOutputStream(file);
			byte buf[] = new byte[1024];
			int len;
			while ((len = inputStream.read(buf)) > 0)
				outputStream.write(buf, 0, len);
			/*outputStream.close();
			inputStream.close();*/
		} catch (Exception e) {
		} finally {
			if (inputStream != null) {
				try {inputStream.close();}
				catch(IOException ioex) {}
			}
			if (outputStream != null) {
				try {outputStream.close();}
				catch(IOException ioex) {}
			}
		}
		return file;
	} else {
		Toast.makeText(context, "SD card is not exists", Toast.LENGTH_SHORT).show();
		return null;
	}
}


// 自定义ViewHolder，
// 利用ViewHolder持有的view可以ViewHolder里面在对view进行设置数据、修改属性
class ViewHolder{  
	pubilc CustomView view;
}  



定义方法设置高宽和android自带的XML设置高宽相兼容：
这样写，就可以增加setWidth()方法和setHeight()方法的同时，不影响View其他原有功能
private int mWidth;
private int mHeight;
private boolean isSetWidthMethodUsed;
private boolean isSetHeightMethodUsed;

//如果使用了setWidth()方法，必须设置xml属性layout_width为wrap_content
public void setWidth(int width) {
	mWidth = width;
	isSetWidthMethodUsed = true;
}

//如果使用了setHeight()方法，必须设置xml属性layout_height为wrap_content
public void setHeight(int height) {
	mHeight = height;
	isSetHeightMethodUsed = true;
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
	int myWidthMeasureSpec = 0;
	int myHeightMeasureSpec = 0;
	if(!isSetWidthMethodUsed) {
		mWidth = MeasureSpec.getSize(widthMeasureSpec);
		myWidthMeasureSpec = widthMeasureSpec;
	} else {
		myWidthMeasureSpec = MeasureSpec.makeMeasureSpec(mWidth, MeasureSpec.EXACTLY);
	}
	if(!isSetHeightMethodUsed) {
		mHeight = MeasureSpec.getSize(heightMeasureSpec);
		myHeightMeasureSpec = heightMeasureSpec;
	} else {
		myHeightMeasureSpec = MeasureSpec.makeMeasureSpec(mHeight, MeasureSpec.EXACTLY);
	}
	super.onMeasure(myWidthMeasureSpec, myHeightMeasureSpec);
}


//在实际应用开发中，发现将一个view的背景设为null(原本有背景)，会触发自身的onMeasure以及父view的onMeasure，如下
iconView.setBackgroundDrawable(drawable) <-> iconView.setBackgroundDrawable(null)

//如果不想调用onMeasure，则可以设置一个透明背景给该view，如下
iconView.setBackgroundDrawable(drawable) <-> iconView.setBackgroundDrawable(transparentDrawable));



view的晃动动画:
res/anim/shaking.xml
<?xml version="1.0" encoding="utf-8"?>
<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="100"
    android:fromDegrees="-5"
    android:pivotX="50%"
    android:pivotY="50%"
    android:repeatCount="infinite" 
    android:repeatMode="reverse"
    android:toDegrees="5" />
	
Animation animation = AnimationUtils.loadAnimation(this, R.anim.shaking);
ImageView mRotateImage.startAnimation(animation);

android:repeatCount 晃动次数，infinite是一直晃动



android中的4个文件保存路径

getFilesDir()   /data/data/包名/files
getCacheDir()   /data/data/包名/cache
getExternalFilesDir()  /storage/emulated/0/Android/data/包名/files
getExternalCacheDir()  /storage/emulated/0/Android/data/包名/cache

不同
1.存储位置不同
2.External的文件夹可以被其他有读写权限的app更改
3.External的文件夹不安全，外置卡被拔出时不能使用
4.getFilesDir和getCacheDir不申请读写权限就能使用
相同
当对应的app被删除时，删除这4个文件夹

Files和Cache的区别在于，当空间不足时，系统会删除cache

Environment.getExternalStorageDirectory()  //外置存储卡 路径



// 该方法指向 sd卡上的路径 /storage/emulated/0/Android/data/com.yourapp.package(应用包名)
getExternalCacheDir().getAbsolutePath()

// 当删除应用时，getExternalCacheDir().getAbsolutePath()指向的文件夹会一并删除

// 注意的是 调用 getExternalCacheDir().getAbsolutePath() 方法
// 就会马上创建一个 /storage/emulated/0/Android/data/com.yourapp.package文件夹
// 如果没有调用该方法 /storage/emulated/0/Android/data/com.yourapp.package文件夹不存在

// SD卡(外置卡)读写权限
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>



Parcelable
用于在Intent中压入对象，
对象的类要继承Parcelable三个接口：
 public class MyParcelable implements Parcelable {
     private int mData;

     public int describeContents() {
         return 0;
     }

     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mData);
     }

     public static final Parcelable.Creator<MyParcelable> CREATOR
             = new Parcelable.Creator<MyParcelable>() {
         public MyParcelable createFromParcel(Parcel in) {
             return new MyParcelable(in);
         }

         public MyParcelable[] newArray(int size) {
             return new MyParcelable[size];
         }
     };
     
     private MyParcelable(Parcel in) {
         mData = in.readInt();
     }
 }
 
如果要使用Parcel的
readArrayList和writeList方法，则列表的元素的类也要实现Parcelable接口



绘制VIew本身的内容，通过调用View.onDraw(canvas)函数实现
绘制自己的孩子通过dispatchDraw（canvas）实现



打开输入法，布局中体上移
步骤1 在manifest中对activity配置，android:windowSoftInputMode="adjustResize"
步骤2 activity最外层的布局必须是RelativeLayout
步骤3 将一个控件，置于RelativeLayout的底部，其他控件都基于该底部控件来布局



异步任务AsyncTask的四个方法
AsyncTask.execute()会启动异步任务，
onPreExecute(), 异步任务启动之后，第一个调用的方法，该方法在UI线程内，例如，显示进度条
doInBackground(Params...), 异步任务启动之后，在后台调用的方法，例如，加载网络数据
onProgressUpdate(Progress...), 异步任务过程中，调用的方法，例如，进度条展示进度
onPostExecute(Result), 异步任务结束之后，最后调用的方法，该方法在UI线程内，例如，隐藏进度条

AsyncTask.cancel(true)
用来结束异步任务，但不是系统自动结束，需要程序员自己写结束
在doInBackground()方法中，多次调用isCancelled()方法，判断是否结束
结束之后，只会调用onCancelled(),而不是onPostExecute()
		
mLoadBitmapTask.getStatus().equals(AsyncTask.Status.FINISHED)
检测是否结束					
					
					
					

使用EditText让键盘弹出或者收起
public void showKeyboard () {
	mEditText.requestFocus();
	InputMethodManager imm = (InputMethodManager) getContext().getApplicationContext()
			.getSystemService(Context.INPUT_METHOD_SERVICE);
	imm.showSoftInput(mEditText, InputMethodManager.SHOW_IMPLICIT);
}

public void hideKeyboard () {
	mEditText.clearFocus();
	InputMethodManager imm = (InputMethodManager) getContext().getApplicationContext()
			.getSystemService(Context.INPUT_METHOD_SERVICE);
	imm.hideSoftInputFromWindow(mEditText.getWindowToken(), 0);
}


// 加密file name
public static String getFileName(String uri) {
	String fileName = null;
	try {
		// SHA-256 加密
		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
		// string 转为UTF-8格式的字节数组
		messageDigest.update(uri.getBytes("UTF-8"));
		fileName = bytesToHex(messageDigest.digest(), new char[64]);
	} catch (Exception e) {
	} finally {
		return fileName;
	}
}


图库选图
Intent photoPickerIntent = new Intent(Intent.ACTION_PICK);
photoPickerIntent.setType("image/*");
startActivityForResult(photoPickerIntent, PICK_IMAGE);

在onActivityResult中
Uri selectedImageUri = data.getData();
或者






BitmapFactory.Options options = new BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.ARGB_8888;
// BitmapFactory 缩小bitmap，缩小2倍，options.inSampleSize设置为 1 是加载原图
// 经过测试，只有设置为2的指数幂有效，即：2，4（缩小4倍），8（缩小8倍）等等
options.inSampleSize = 2;
Bitmap fileBitmapScale = BitmapFactory.decodeFile(imagePath, options);



android 5.0以上
使得status bar 和 自己的布局共用一张背景
在activity中这么设置
	if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
		getWindow().getDecorView().setSystemUiVisibility(
				View.SYSTEM_UI_FLAG_LAYOUT_STABLE
						| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
		Window window = getWindow();
		window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
		window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
		window.setStatusBarColor(0x00ffffff);
	}
在AndroidManifest中配置
    android:theme="@style/MyBarTheme"
	
styles:
    <style name="MyBarTheme" parent="android:Theme.Holo.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:windowTranslucentStatus">true</item>
    </style>


	
	
	canvas 是不能绘制大于canvas.getMaximumBitmapWidth() 或者 canvas.getMaximumBitmapHeight()的图片
	报错：
	W/OpenGLRenderer: Bitmap too large to be uploaded into a texture (4208x2368, max=4096x4096)

	
	
	
	// 判断版本号
	if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP){
    // Do something for lollipop and above versions
	} else{
    // do something for phones running an SDK before lollipop
	}
	
	


Bitmap 相关

    // 得到一张 空(null) 的Bitmap ，用于取得图片高宽
    private static void getWHBitmap (String path) {
        BitmapFactory.Options opts = new BitmapFactory.Options();
        opts.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(path, opts);
	int h = opts.outHeight;
	int w = opts.outWidth;
    }


//得到bitmap的内存占用（单位 MB）
bitmap.getByteCount()/1024/1024
// ARGB_8888格式的图片是RGB_565格式的一倍左右
Bitmap.Config.ARGB_8888;
Bitmap.Config.RGB_565;


得到一张1MB以下的磁盘存储的图
public static Bitmap get1MbOpts (String path) {
        Bitmap bitmapArgb = getCompressionOpts(path, 1.024 * 1024D);
        return bitmapArgb;
    }
private static Bitmap getCompressionOpts (String path, double needSize) {
        if (path == null || path.isEmpty()) {
            return null;
        }
        BitmapFactory.Options opts = new BitmapFactory.Options();
        opts.inPreferredConfig = Bitmap.Config.ARGB_8888;
        File imageFile = new File(path);
        if (imageFile.exists()) {
            double fileSize = imageFile.length()/1024D; // image file size (KB)
            if (fileSize > needSize) {
                double fileLog = Math.log(fileSize)/Math.log(2);
                double needLog = Math.log(needSize)/Math.log(2);
                int size = (int)(fileLog - needLog + 1)*2;
                if (size == 0) {
                    opts.inSampleSize = 1;
                } else {
                    opts.inSampleSize = size;
                }
            } else {
                opts.inSampleSize = 1;
            }
        } else {
            return null;
        }
        Bitmap originBitmap = BitmapFactory.decodeFile(path, opts);
        return originBitmap;
    }




GridLayoutMenager,子项间隔
 public class SpaceItemDecoration extends RecyclerView.ItemDecoration {

        private int space;

        public SpaceItemDecoration(int space) {
            this.space = space;
        }

        @Override
        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
            // -1 for the title
            int gridPosition = parent.getChildLayoutPosition(view) - 1;
            if (0 <= gridPosition) {
                if (gridPosition % mManager.getSpanCount() == 0) {
                    outRect.left = space;
                } else if (gridPosition % mManager.getSpanCount() == mManager.getSpanCount() - 1) {
                    outRect.right = space;
                }

                if (gridPosition < mManager.getSpanCount()) {
                    outRect.top = space;
                } else {
                    // -1 for the title
                    int offsetTotalCount = (mAdapter.getItemCount() - 1);
                    int lastCount = offsetTotalCount % mManager.getSpanCount();
                    if (lastCount == 0) {
                        if (gridPosition >= offsetTotalCount - mManager.getSpanCount()) {
                            outRect.bottom = space;
                        }
                    } else {
                        if (gridPosition >= offsetTotalCount - lastCount) {
                            outRect.bottom = space;
                        }
                    }
                }

            }
        }
    }





android的Touch（dispatchTouchEvent，onInterceptTouchEvent，onTouchEvent）

	
	
	
	
	
	
	


