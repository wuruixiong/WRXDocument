
#while 循环

count=5
while count>0:
    print "while is execute"
    count=count-1

#井号键注销，以上2句为while的循环体，当没有缩进时，自动设置为下一句
#python自动换行，也可打入换行符 "\n" 如此会换2行
print "while break"


在python设置环境之后，在终端输入python，出现>>>之后，
可以直接执行python语句并按回车执行，但是不能保存，所以一般创建为.py文件保存代码。
例如：在window 下的cmd终端之中输入python
接着输入：
>>> x = 12
>>> print x
会输出：12


使用前先import,时间：
total = time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(time.time()))
today = time.strftime("%Y_%m_%d",time.localtime(time.time()))
startTime = time.strftime("%H:%M:%S",time.localtime(time.time()))


for 循环用法一，阶数为1，从0开始走到11，执行12次，：
	    for i in range(0,12,1):

首先逐行读取文件，接着逐字读取字符串并打印每个字符
for line in open(mTestInfoPath + "/test.txt"):
    for linechat in line:
        print linechat
        



对于模块和自己写的程序不在同一个目录下，可以把模块的路径通过sys.path.append(路径)添加到程序中。
在程序开头加上：
import sys
sys.path.append("path")

python序列：字符串、列表、元组

字典操作:
dict = {"a":a,"b":b,"c":c,"d":d,"e":e}
字典查询时直接
dict["key"]
如果没有该key会报错，以下方法可以解决，
dict.get("key", "deault")


列表操作：
列表：
["",123,object,()]
#长度
list_length = len(sample_list)

sample_list.append(var)   #追加元素

#遍历
for element in sample_list:
    print(element)

#遍历2
for i in range(len(lst)):
	print(lst[i])

#创建空列表
list = []
 
合并:
A.extend(B)
A+B

	
元组：
("","","")


文件写入
    fp = open(mTestInfoPath + "/MemoryInfo.txt","a")               #追加模式打开文件，没有文件会自动创建文件
    fp.write(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
    fp.write("\n\n")
    fp.flush()                                                     #从缓存区中将内容写入，如果没有这句，会导致有时写入文件的字符串顺序不一样
    fp.close




使用exec函数可以执行动态Python代码，即将字符串当做代码执行执行，
一开始使用到这个功能因为需要将模块名作为参数传给该文件，再导入该模块
例如：
exec("import " + "config720_1280 " + "as config")
之后可以使用config720_1280中的函数，例如：
config.finishSuggect[0]
config.editKeyboard[1]

使用eval可以类似于exec函数，可以将字符串作为计算表达式使用



字符串 : 用法1
mScritLastPath = "E:/test_result/test"
print mScritLastPath
print mScritLastPath.rindex("/")
i = mScritLastPath.rindex("/")
print mScritLastPath[:i]

结果
E:/test_result/test
14
E:/test_result

# 字符串匹配，找到返回找到的index，找不到返回-1
info = "abcaaa"
if info.find("d") != -1:
	print "find"
else:
	print "not find"




当在函数中需要修改全局变量时，如果没有global关键字则会出错，
因为python发现变量x在函数内部被赋值，则将x识别为局部变量，此时局部变量还未赋值时就被使用，所以报错。
加上global关键字后，可以得到希望的结果，如下：
x = 1  
def run():     
    global x   
    print x  
    x = 2  
      
if __name__ == '__main__':  
    run()  


	
可以在函数中嵌套函数，也可以在函数中创建变量，也可以函数中导入类，用法和不在函数中一样
	

扫描目录下的文件列表名
	
for findPY in os.listdir(path):
	print findPY


#多行注释 使用 """ 代码 """  
#for root, dirs, files in os.walk(originalFilePath)  
#查找一个文件夹下的所有的文件会有三个返回值，
#root是这个文件的父文件夹路径，dirs是文件夹下所有的文件夹列表，files是文件夹下所有的文件列表
#originalFilePath是文件夹路径
"""
for root, dirs, files in os.walk(originalFilePath):  
	for specialFile in files: 
		originalFiles.append(str(specialFile))

for root, dirs, files in os.walk(mateFilePath):  
	for specialFile in files: 
		mateFiles.append(str(specialFile))
"""


#if语句
number = 23
guess = random.uniform(10, 30)  #随机数生成
if guess == number:
    print("right")
elif guess < number:
    print("smaller")
else:
    print("bigger")

#当if 0 时, 判断不成立，会跳到else
if 0:
else :
	
#当if 非0(大于零小于零) 时, 判断成立
if "aaa":
if -1:
	
	
解析json
jsonTest = {"datakey1":"dataValue1", "datakey2":"dataValue2", "datakey3":"dataValue3"}
jsonObjectDump = json.dumps(jsonTest)
jsonObject = json.loads(jsonObjectDump)
print jsonObjectDump
print jsonObject["datakey1"]

jsonTest2 = ["dataValue1","dataValue2","dataValue3"]
jsonArrayDump = json.dumps(jsonTest2)
jsonArray = json.loads(jsonArrayDump)
print jsonArrayDump
print jsonArray[2]	
	
	
	
在python中执行shell命令
import subprocess #导入模块
#调用call方法，可以这么调用 subprocess.call(["cmd", "arg1", "arg2"],shell=True)
#例如：以长格式的形式查看当前目录下所有可见文件的详细属性
subprocess.call(["ls", "-l", "./"], shell=False)
#也可以
subprocess.call(["ls -l ./"], shell=True)

注：据说不建议使用 shell=True
	shell=True参数会让subprocess.call接受字符串类型的变量作为命令
----------------------------------------------------------------------------

函数定义
	
Python的函数 不用定义返回值类型，可以传入任意类型的参数，返回值可以是任意类型：

def testPrintf(str):
    print(str)
    return str

#main入口中调用函数testPrintf，可以输入任意类型的参数，testPrintf也可以返回任意类型的返回值
if __name__ == '__main__':
    mybo = False
    testPrintf(mybo)

    testPrintf('okm')

    st = {'mykey': 123}
    testPrintf(st['mykey'])


----------------------------------------------------------------------------

	
类定义

# Student表示类名称，后面接 (object) 表示Student类 继承object这个类，object是所有类的基类
# 通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。
class Student(object):
# __init__是最基础的方法，相当于构造方法，self相当于类本身，下面这个是 Student类的默认init函数
# def __init__(self) -> None:
#     super().__init__()

    #下面这个是改过的init函数，增加了两个参数 name和id
    #self相当于这个类本身，是init函数自带参数
    #直接写 self.studentName 和 self.studentId相当于创建全局变量 studentName和studentId
    #改过init函数之后，创建实例，需要传入两个参数，否则报错
    def __init__(self, name, id) -> None:
        super().__init__()
        self.studentName = name
        self.studentId = id
	

if __name__ == '__main__':
    # 没有改过init函数的类，直接加上括号就创建，例如 Student()
    ba = Student('wrx', 101)
    print(ba.studentId)

—---------------------------

    # 加双下滑线 __ 设置为私有变量
    def __init__(self, name, id) -> None:
        super().__init__()
        self.__studentName = name
        self.__studentId = id

    def get_name(self):
        return self.__studentName

    def set_name(self, name):
        self.__studentName = name
在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。

有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
	
----------------------------------------------------------------------------

Python是动态语言，可以在运行时，在类中直接创新的成员，还可以将方法作为参数传递给类，成为类的成员

正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。

先定义class：
class Student(object):
    pass
给实例绑定一个属性：
>>> s = Student()
>>> s.name = 'Michael' # 动态给实例绑定一个属性
>>> print(s.name)
Michael

给实例绑定一个方法(只有绑定的那个实例有效)：
>>> def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
>>> from types import MethodType
>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
>>> s.set_age(25) # 调用实例方法
>>> s.age # 测试结果
25

接上面代码，给一个类class绑定方法，给class绑定方法后，所有实例均可调用：
>>> def set_score(self, score):
...     self.score = score
...
>>> Student.set_score = set_score
----------------------------------------------------------------------------

使用__slots__ ,限制对类成员的访问

Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：

class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称

跑起代码：
>>> s = Student() # 创建新的实例
>>> s.name = 'Michael' # 绑定属性'name'
>>> s.age = 25 # 绑定属性'age'
>>> s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'score'
由于'score'没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。
使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义__slots__。



----------------------------------------------------------------------------

静态语言 vs 动态语言
对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。

对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：

class Timer(object):
    def run(self):
        print('Start...')
这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。

Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。

----------------------------------------------------------------------------
monkeyrunner总结：

android的monkeyrunner测试，指定脚本：
monkeyrunner path+file

device.drag((500,440) , (0,440) , 2.0  , 2)
#参数 1和2是坐标，3是延迟多少秒，4是动作帧数(延迟秒数和动作帧数配合使用，控制滑动动作的缓急)
#调整延迟秒数可以做成“快划效果”这时候动作帧数相应变大一点，
#例如device.drag((360,1168) , (360,400) , 0.1  , 10)

使用前先import,可以输入adb命令
os.popen("adb command")
例如输出log到一个.log文件（其他命令没试过）：
os.popen("adb logcat -v time > e:/2015_06_15.log")


#曲线拖动
device.touch(70, 1000, MonkeyDevice.DOWN)
# Move from 100, 500 to 300, 500
for i in range(1, 11):
    device.touch(70 + 20 * i, 1000, MonkeyDevice.MOVE)
    print "move ", 70 + 20 * i, 1000
    time.sleep(0.1)

# Move from (300, 500 to 200, 500)
for i in range(1, 11):
    device.touch(270, 1000 - 10 * i, MonkeyDevice.MOVE)
    print "move ", 270, 1000 - 10 * i
    time.sleep(0.1)

# Remove finger from screen
device.touch(300, 400, MonkeyDevice.UP)

#启动Activity，带有Extra
device.startActivity( extras = extraDic ,component = runComponent)


将内存信息写入文本
shell_print = device.shell('dumpsys meminfo com.crazystudio.emoji.kitkat')
print shell_print
#参数a,追加模式
fp = open("E:/test_result/2015_6_10/script_log/test.txt",'a')
fp.write(shell_print + '\n\n\n')

截图：
newimage = device.takeSnapshot()
newimage.writeToFile ( 'E:/source/workspace-emoji-keyboard-test/workspace/huiteng-emoji-keyboard/script_image/theme_main.png' , 'png');

将log信息写入文本
os.popen("adb logcat -v time > " + mTestInfoPath + "/" + getToday() + getNowTimeUnderline() + ".log")

#！这里执行adb命令使用了os.popen和device.shell两种方式，似乎os.popen适用更加广泛，有待研究

关闭开启ADB
  adb kill-server
  
  adb start-server


延伸的monkeyrecord

CMD_MAP = {
    'TOUCH': lambda dev, arg: dev.touch(**arg),
    'DRAG': lambda dev, arg: dev.drag(**arg),
    'PRESS': lambda dev, arg: dev.press(**arg),
    'TYPE': lambda dev, arg: dev.type(**arg),
    'WAIT': lambda dev, arg: MonkeyRunner.sleep(**arg)
	#加入自定义的
	'SHOT': lambda dev, arg: shotPhoto(),
    'LOG':lambda dev, arg: writeLogFile(),
     'MEMORY':lambda dev, arg: writeMemoryFile(**arg)  #带参数
}

在生成出来的文件中写入以下语句就可以调用，只能手动写入
SHOT|{}
LOG|{}
MEMORY|{'message':'slide 6 theme'}  #传入参数



