登录远程VPS服务器：
这个root@ 就是 搬瓦工上对应的root登录
ssh root@1.2.3.4 -p 12345
或者
ssh 1.2.3.4 -p 12345

98.142.131.139


Kbj5jPekDM2k




ssh root@98.142.131.139 -p 27801



第1条命令：
wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh
第2条命令
chmod +x shadowsocks-libev.sh
第3条命令
./shadowsocks-libev.sh 2>&1 | tee shadowsocks-libev.log

{
    "server":"98.142.131.139",
    "server_port":444,
    "local_address":"127.0.0.1",
    "local_port":1080,
    "password":"kk123098",
    "timeout":300,
    "method":"aes-256-cfb",
    "fast_open":false
}

ssh -p 27801 root@98.142.131.139


#############################################################
# One click Install Shadowsocks-Python server               #
# Intro: https://teddysun.com/342.html                      #
# Author: Teddysun <i@teddysun.com>                         #
# Github: https://github.com/shadowsocks/shadowsocks        #
#############################################################

Please enter password for shadowsocks-python
(Default password: teddysun.com):



----------------------------------------------------------------------------------------------------------------------------------------------------------


crud是指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)几个单词的首字母简写。
crud主要被用在描述软件系统中数据库或者持久层的基本操作功能。

----------------------------------------------------------------------------------------------------------------------------------------------------------

数据库使用MySql

持久层框架：
MyBatis
JPA/Hibernate

Hibernate是对象关系映射框架（ORM），它将Java类映射到数据库表。 
Hibernate ORM enables developers to more easily write applications whose data outlives the application process. 
As an Object/Relational Mapping (ORM) framework, Hibernate is concerned with data persistence as it applies to relational databases (via JDBC). 

MyBatis是持久性框架 而不是ORM。 它将SQL语句映射到Java方法。
MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. 

Hibernate可以根据您的Java模型创建或验证数据库模式，而MyBatis没有此类功能。 
这些解释 Stack Overflow、Wikipedia、MyBatis官网都有

---------------

MyBatis不支持自动建表，需要手动在数据库中创建表。
JPA/Hibernate可以在实体类中增加 @Entity @Id 等注解，将实体类映射到表结构中，
一个实体类对应一张表，在 Repository.save() 时自动创建表。

---------------

JPA/Hibernate通过 Repository来实现 CRUD操作
MyBatis则是使用 @Mapper注解一个 接口interface：
1.为该接口中的方法添加 注解@Insert，@Select等注解
2.如果不用注解，还可以使用 xml配置 来代替注解配置 CRUD操作
选择使用注解来搞，不喜欢过多的xml配置文件

----------------------------------------------------------------------------------------------------------------------------------------------------------

作用域、Spring Session、Redis

几乎所有web应用容器都提供了四种类似Map的结构：application session request page，
Jsp或者Servlet通过向着这四个对象放入数据，从而实现Jsp和Servlet之间数据的共享。

application:整个应用  对应servlet中ServletContext
session：会话　　　　对应servlet中HttpSession
request：一次请求　　对应servlet中的HttpServletRequest
page：当前页面




springboot作用域 保存用户信息：
http协议是无状态的，无法保存用户信息。
Session是作用域，保存用户信息

在单应用中我们的session来保存用户信息，通常会保存在服务器中（如tomcat）.
但是我们把应用搭建成分布式的集群，然后利用LVS或Nginx做负载均衡，
那么来自同一用户的Http请求将有可能被分发到两个不同的应用中。

Spring Session提供了一个API和实现来管理用户的会话信息，
同时也使得支持集群会话而不被绑定到应用程序容器特定的解决方案而变得微不足道。
实际上，我们不使用Tomcat的HttpSession，而是将session Id值持久化到Redis中。
Spring Session将使用由Redis支持的实现替换HttpSession。


----------------------------------------------------------------------------------------------------------------------------------------------------------

Cookie保存于客户端，也就是浏览器端
常用于用户免登陆等操作。

----------------------------------------------------------------------------------------------------------------------------------------------------------

Servlet
Java Servlet 是运行在 Web 服务器或应用服务器上的程序，
它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。
实现doget和dopost方法。
Servlet需要在web.xml配置

web Container
web容器也叫servlet容器，负责servlet的生命周期，映射url请求到相应的servlet。
例如，TomCat就是web容器

一个web Container里有多个Servlet，web Container接收用户请求，每个请求看做一个线程，
多个请求同时访问某一个Servlet，web容器的资源共享很重要。

----------------------------------------------------------------------------------------------------------------------------------------------------------

Spring 框架
Spring有哪些优点?

方便解耦， 简化开发
Spring是个大工厂，可以将所有对象创建以及对象间依赖关系的维护，交给Spring容器进行管理，避免硬编码造成过度的程序耦合，实现程序各层之间的解耦。

AOP编程的支持
Spring提供面向切面编程(将日志记录、权限控制、性能统计等服务理解成一个切面)，可以将日志、权限等服务从业务逻辑中分离出来，可以方便的实现对程序进行权限拦截、运行监控等功能。

声明式事务支持
Spring只需通过配置就可以完成对事务的管理，无需手动编程，大大提高了开发的效率。

方便集成各种优秀框架
Spring不排斥各种优秀开源框架，其内部提供了对各种优秀框架（如 : Struts、Hibernate、MyBatis等. . .）的直接支持。

方便程序的测试
Spring对Junit4支持，可以通过注解的方式来测试Spring程序

降低JavaEE API的使用难度
Spring对JavaEE开发中一些非常难用的API（JDBC、JavaMail、远程调用等. . .）都提供了封装，使这些API的使用难度大大降低。

--------------

面向方面编程（AOP）和控制反转 （IOC） 容器
与SpringMVC框架无缝连接，无需整合
Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式。
核心容器，Spring 上下文，Spring AOP，Spring DAO，Spring ORM，Spring Web 模块，Spring MVC 框架。

IOC（Inverse of Control）反转控制，就是将原本在程序中手动创建类对象的控制权，交由Spring框架管理。
DI（Dependency Injection）依赖注入，就是在Spring创建某个对象的过程中，将这个对象所依赖的属性（变量或其它类对象）注入进去。
IOC就是DI
IOC就是典型的工厂模式，通过BeanFactory去注入实例。

IOC简单例子
创建Person类、applicationContext.xml配置文件（在配置文件中配置Bean标签，对Person添加id，并对成员变量赋值）
在mian方法中创建ApplicationContext，通过id创建Person对象

在我们加载IOC容器后，Spring就会全自动的为我们创建相应的对象，此时我们就无需再自己 new 创建对象了
这就是所谓的控制反转，将创建对象的权限反转给Spring IoC容器，
对类之间的关系进行了解耦
所以Spring IoC容器会帮我们做两件事：1. 创建对象  2. 为属性赋值

Spring IoC设计的核心是Bean容器
BeanFactory采用了java经典的工厂模式，通过从xml配置文件中读取javaBean的定义，来实现javaBean的创建、配置和管理bean与bean之间的依赖关系，
所以BeanFactory可以称为IoC容器。
ApplicationContext的中文含义是: 应用上下文，继承自BeanFactory接口，

------------------

AOP就是典型的代理模式的体现。
AOP:面向切面编程。（Aspect-Oriented Programming）
AOP可以说是对 OOP（面向对象编程） 的补充和完善。
1.面向切面编程提供声明式事务管理 
2.spring支持用户自定义的切面 

Spring框架的AOP机制可以让开发者把业务流程中的通用功能抽取出来，单独编写功能代码。
在业务流程执行过程中，Spring框架会根据业务流程要求，自动把独立编写的功能代码切入到流程的合适位置。

例如，在一个业务系统中，用户登录是基础功能，凡是涉及到用户的业务流程都要求用户进行系统登录。
如果把用户登录功能代码写入到每个业务流程中，会造成代码冗余，维护也非常麻烦，当需要修改用户登录功能时，
就需要修改每个业务流程的用户登录代码，这种处理方式显然是不可取的。比较好的做法是把用户登录功能抽取出来，
形成独立的模块，当业务流程需要用户登录时，系统自动把登录功能切入到业务流程中。下图是用户登录功能切入到业务流程示意图。

AOP是面向切面的编程，其编程思想是把散布于不同业务但功能相同的代码从业务逻辑中抽取出来，
封装成独立的模块，这些独立的模块被称为切面，切面的具体功能方法被称为关注点。在业务逻辑执行过程中，
AOP会把分离出来的切面和关注点动态切入到业务流程中，这样做的好处是提高了功能代码的重用性和可维护性。

实现步骤是：首先编写需要切入业务流程的独立模块（也称为切面）和切入点（模块中的方法）；
然后在Spring配置文件中配置AOP，添加切入面、切入点以及需要切入的目标Bean；最后编写测试代码。

AOP例子（1）：
权限校验（用户是否已经登录）为切面(Aspect)，
核心代码（查询并修改本用户信息）为切点(PointCut)，
在执行核心代码之前切入 权限校验的切面。
切面代码和切点代码分离，两个模块独立分开维护，代码分工明确。
切面代码还可以作为公共模块提供给其他切点使用，因为不止这一个切点需要使用到权限校验。

通知（advice）:五种通知方式：
@Before：前置通知，在调用目标方法之前执行通知定义的任务
@After：后置通知，在目标方法执行结束后，无论执行结果如何都执行通知定义的任务
@After-returning：后置通知，在目标方法执行结束后，如果执行成功，则执行通知定义的任务
@After-throwing：异常通知，如果目标方法执行过程中抛出异常，则执行通知定义的任务
@Around：环绕通知，在目标方法执行前和执行后，都需要执行通知定义的任务。

具体请参考demo

----------------------------------------------------------------------------------------------------------------------------------------------------------

SpringMCV框架
springmvc在java web项目中就是一个全功能MVC模块，而MVC框架就是一个分离了控制器，
模型对象、分派器以及处理程序的各个角色，这种分离让它们更容易进行定制。
功能类似于Servlet，springmvc的核心控制器dispatcherServlet是继承自framworkerSevlet。
方法级别的拦截，每个方法之间都是独立的，独享request response数据。

需要在web.xml中配置org.springframework.web.servlet.DispatcherServlet
各种注解
@Controller
负责注册一个bean 到spring 上下文中
@RequestMapping
注解为控制器指定可以处理哪些 URL 请求
@RequestBody
该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，
然后把相应的数据绑定到要返回的对象上 ,再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上
@ResponseBody
 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区
@ModelAttribute 　　　
在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法
在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中 
@RequestParam　
在处理方法入参处使用 @RequestParam 可以把请求参 数传递给请求方法
@PathVariable
绑定 URL 占位符到入参
@ExceptionHandler
注解到方法上，出现异常时会执行该方法
@ControllerAdvice
使一个Contoller成为全局的异常处理类，类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常



Spring注解@Component、@Repository、@Service、@Controller区别
如果 Web 应用程序采用了经典的三层分层结构的话，
最好在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释，
而用 @Component 对那些比较中立的类进行注释。 

@Repository用于mapper的注解
@Service用于service的注解
@Controller用于Controller的注解





----------------------------------------------------------------------------------------------------------------------------------------------------------

Mybatis使用： 

Mybatis 注解(Annotation) 和 xml 的选型，据说复杂语句使用注解配置比较麻烦。
注解是新支持的特性





Mybatis 
1. spring boot依赖mybatis：
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>1.3.2</version>
        </dependency>
现在也可在创建工程时，选择依赖mybatis了

2. 如果引入mybatis的依赖，就要在 application.properties 中加入连接数据库，否则报错
例如：
spring.jpa.hibernate.ddl-auto=create
spring.datasource.url=jdbc:mysql://localhost:3306/springTestDB
spring.datasource.username=root
spring.datasource.password=WRXdemysql

3. Mapper注解的使用：
两种增加mapper的方式
1. 在Application中，也就是加了@SpringBootApplication注解的类中，为其增加注解：@MapperScan，只需要增加一次。
2. 在单个Interface中增加@Mapper，这个接口用于进行基本的sql操作，DAO接口。

例如：
使用时，添加一个@Mapper注解接口：
@Mapper
public interface UserMapper {

    @Select("select * from user where name = #{name} and password = #{password}")
    List<User> selectUserByNamePwd(User user);

    @Select("select * from user where uid = #{uid}")
    List<User> selectUserByUid(Integer uid);

    @Insert("insert user (name, password, email) values(#{name}, #{password}, #{email})")
    void addOne(User user);

    @Update("update user set name = #{name} where uid = #{uid} and password = #{password}")
    void updateName(User user);

    @Delete("delete from user where uid = #{uid} and name = #{name} and password = #{password}")
    void deleteOne(User user);
}

还可以传入bean对象，直接使用#号，对象里面的全局变量
#{}是预编译处理，${}是字符串替换。
Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值，防制sql注入

直接调用方法即可获得数据对象列表。


@Select如果查询到多个数据，没有列表返回而是单个对象返回，会报错
每一次mybatis从数据库中select数据之后，都会检查数据条数和dao中定义的返回值是否匹配。
若返回一条数据，dao中定义的返回值是一个对象或对象的List列表，则可以正常匹配，将查询的数据按照dao中定义的返回值存放。
若返回多条数据，dao中定义的返回值是一个对象，则无法将多条数据映射为一个对象，此时mybatis报错。
例如：返回的是user对象，查到多个user数据时报错，返回的是user列表，查到一个或者多个都不会报错



---------------

Mybatis  xml使用：

通常使用xml方式来访问数据库，使用sql语言，
通常使用mapper作为根标签，与一个java类的mapper绑定


第三方工具类
tk.Mybatis
简化开发，使用框架定义好的方法即可（增删改查都已经定义好了），不再需要在mapper.xml文件中配置了。
只要继承tk.Mybatis.mapper就好

引入流程：
1.导包：
<dependency>
	<groupId>tk.mybatis</groupId>
	<artifactId>mapper-spring-boot-starter</artifactId>
	<version>2.1.0</version>
	<exclusions>
		<exclusion>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</exclusion>
	</exclusions>
</dependency>

2.mapper继承tk框架里面的mapper(还可以加入泛型)：
public interface UserMapper extends Mapper<UmsMember>
2.1 bean类的id成员变量加入注解@Id和@GeneratedValue
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private String id;

3.TkMybatis默认使用继承Mapper接口中传入的实体类对象去数据库寻找对应的表（bean类以大驼峰命名，表以下划线命名）
因此如果表名与实体类名不满足对应规则时,会报错,这时使用@Table为实体类指定表。
方法定义好了，加上会自动去找到对应的表，所以不需要再去创建mapper.xml了

4.Application的@MapperScan换成tk框架里面的

5.在application.properties配置文件中,配置mapper.xml文件指定的位置[可选]

6.如果有特殊的需求,可以自己实现mapper.xml自定义sql语句，但路径必须与@MapperScan的对应


----------------------------------------------------------------------------------------------------------------------------------------------------------

application.properties文件配置
可以在上一级目录中添加config目录，在创建application.properties文件

单元测试的配置：
需要在resoures中的application.properties增加配置
特别是zookeeper的相关配置只有在这里才生效

























