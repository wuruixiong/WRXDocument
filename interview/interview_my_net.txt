
Api调用工程师

设计模式

java代码
	JDK JRE
	基础语法，数据类型
	算法
	jdk8

java高级
	高级特性
	注解
	jvm虚拟机
		内存分区
		新生代回收器，老生代回收器
		强、弱、软，虚引用
		gc机制
	java11和java14高级特性
	
高并发，多线程，线程同步，反射，异常，泛型
内存泄漏
死锁，活锁，乐观锁，悲观锁
数据脏读，幻读
缓存击穿，雪崩
熔断，降级，监控
负载均衡

spring开发
	springmvc
	结构分层：表现层，业务层，持久层
	ioc控制反转(或者叫di依赖注入)，aop面对切面编程，ioc容器
	spring 动态代理
	spring boot，底层代码解析，注解实现
	spring cloud 重要组件
		Netflix Eureka注册中心
		Ribbon负载均衡
		Fegin
		Hystrix
		Zuul网关
	spring security
		oauth2
	spring data
		jpa
	中间件
		rabbitMQ消息队列
		kafka
	事务控制
	restful风格
	阿里框架
		dubbo，zookeeper
	两种注册中心的对比，也是http和rpc协议的对比
		eureka，zookeeper
	springCloud netflix 
	springCloud alibaba
		spring cloud中的几乎所有的组件都使用Netflix公司的产品，在其基础上做了一层starter的封装
		然而Netflix的服务发现组件Eureka已经停止更新
		将来的框架选型可能会更多的偏向springCloud alibaba

数据库相关
	基础sql语言的使用
	nosql，redis，MongoDB
	sql，mysql，sqllite
	持久层框架，mybatis，jpa，ORM框架 对象关系映射

 搜索
	ElasticSearch


数据安全，加密，网络协议
数据安全
	数据库的数据加密存储方案
	加密RSA的衍生协议
	对称加密，非对称加密，不可逆加密
	实际应用
	数字签名，摘要算法
网络协议
	网络协议基础，tcp/ip五层结构
		tcp握手
	http
		通讯过程
	https：结合数据安全，保证通讯安全
		通讯过程

部署工具
	docker
	k8s

版本控制工具
	git
	svn

项目构建工具
	maven
	gradle

---------------------------------------------------------------------------------


网络协议

TCP/IP 网络五层结构

应用层：HTTP协议，FTP协议文件传送，SNMP邮件协议
传输层：UDP，TCP协议
网络层：IP协议，路由器、三层交换机
数据链路层：MAC地址，以太网交换机（二层交换机），网卡
物理层：中继器、集线器、双绞线

----------

数据的整条发送链是：
1、某进程(也就是在应用层)准备好待传输数据，若目的地址是域名则要先通过DNS解析成IP地址

2、交付到运输层(TCP/UDP层)，运输层对数据进行适当的分组等操作，后对每一个分组数组加上首部形成报文段(或用户数据报)首部包括源地址、源端口、目的地址、目的端口和一些其他的诸如校验和等数据

3、交付到网际层(IP层)，对分组数据加上首部形成IP数据报，首部包括源地址、目的地址(跟运输层的目的地址不同，运输层的目的地址是数据要传送的最终地址，而该目的地址是通过路由表信息得出，是该数据下一步该转移的目的计算机)和校验和等数据

4、交付到数据链路层(mac层)，先是对把数据封装成帧(也就是添加首部[SOH]和尾部[EOT])，然后进行透明传输(也就是封装的数据里面，如果出现首部SOH和尾部EOT这样的数据，对其进行转义，也就是加上ESC转义字符，这种方法称为字节/字符填充)

5、交付到物理层，根据数据链路层的mac知道要传输到目的计算机，通过特定的传输介质传送到下一个地址

6、若源主机与最终目的主机在同一个网段，则该地址是最终的目的主机，开始接收数据，进入第7步骤，若源主机和最终目的主机不在同一个网段，进入第11步骤

7、交付到数据链路层，对数据进行卸装，该层会对接收的数据进行差错检测，有差错的数据都会被丢弃

8、交付到IP层，解帧校验

9、交付到运输层，在该主机上，根据端口找到对应的应用，当使用的TCP协议时，提供一种面向连接的可靠的传输服务，可以说是建立了一个虚拟通道，源主机的数据通过该虚拟通道进行传输；若是使用的UDP协议时，提供一种面向的非连接的尽最大努力的不可靠的传输服务，数据传输快，但是无法保证数据100%传输。

10、建立了传输连接后，应用开始接收数据，发送方数据和接收方都必须满足相同的标准应用层协议，如http、ftp、smtp等，通过标准协议应用即可正确的接收源主机发送过来的数据。

11、该计算机不是最终主机，那该计算机就是路由器也就是用于转发分组数据的中转站，首先接收数据的处理同步骤7和8一样，然后接下来的流程又是如同步骤3,

12、如此循环直至找到最终主机，将数据传送到目的应用

----------

报文封装流程：
应用层对原数据封装一层http协议内容：请求行、请求头、空行、请求体（请求体就是原数据）
传输层 封装一层 TCP报头，形成TCP报文
网络层 封装一层IP报头，形成IP报文
数据链路层 添加帧头和帧尾，MAC帧是数据链路层的传输基本单位
物理层 基本单位是bit(比特)，将数据以bit发送至下一个地址

----------

socket是套接字，是一个比较抽象的概念，严格意义上来说，不属于五层结构的哪一层，至少是网络层以上的概念。
位于应用层和传输层之间，用于封装TCP，UDP，套接字Socket=（IP地址：端口号）
里面还封装了应用层的某一个端口号，例如：HTTP默认端口号80，FTP默认端口号21

Socket就是用来进程间通讯的
举个例子：
在主机A的pid1号进程 和 主机B的进程pid1号进程 之间通讯，因为套接字的 ip:port 刚刚好就对应了一台主机上的一个进程。

------------------------------------------------------------------------------------------------------------------------------------------------------------------

HTTP 超文本传输协议

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 -->
浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户

一次完整的HTTP请求过程从TCP三次握手建立连接成功后开始，客户端按照指定的格式开始向服务端发送HTTP请求，
服务端接收请求后，解析HTTP请求，处理完业务逻辑，最后返回一个HTTP的响应给客户端，HTTP的响应内容同样有标准的格式。

HTTP请求格式主要有四部分组成，分别是：请求行、请求头、空行、消息体，每部分内容占一行
<request-line>
<general-headers>
<request-headers>
<entity-headers>
<empty-line>
[<message-body>]

请求行：请求行是请求消息的第一行，由三部分组成：分别是请求方法（GET/POST/DELETE/PUT/HEAD）、请求资源的URI路径、HTTP的版本号
GET /index.html HTTP/1.1

请求头：请求头中的信息有和缓存相关的头（Cache-Control，If-Modified-Since）、客户端身份信息（User-Agent）等等。
Cache-Control:max-age=0
Cookie:gsScrollPos=; _ga=GA1.2.329038035.1465891024; _gat=1
If-Modified-Since:Sun, 01 May 2016 11:19:03 GMT
User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36

请求体
若方法字段是GET，则此项为空，没有数据
若方法字段是POST,则通常来说此处放置的就是要提交的数据
比如要使用POST方法提交一个表单，其中有user字段中数据为“admin”, password字段为123456，那么这里的请求数据就是 user=admin&password=123456，使用&来连接各个字段。

注意：请求体有很多种，例如可以是：
key-value：键值对类型
String：字符串类型
Form：类似于Html的表单数据提交
Stream：流类型
File：文件类型

此外，post请求体还需要设置 请求头Content-Type，每种类型的Content-Type都不同:
Form: application/x-www-form-urlencoded
Json: application/json
Stream: application/octet-stream  二进制流，不知道下载文件类型
文件是图片时: image/jpeg
String: text/plain 或者 text/html

***************

（HTTP响应也是由以下组成，分别是：状态行、消息报头、响应正文）
HTTP响应消息的格式包括：状态行、响应头、空行、消息体。每部分内容占一行。
<status-line>
<general-headers>
<response-headers>
<entity-headers>
<empty-line>
[<message-body>]

状态行：状态行位于相应消息的第一行，有HTTP协议版本号，状态码和状态说明三部分构成。如：
HTTP/1.1 200 OK

响应头：响应头是服务器传递给客户端用于说明服务器的一些信息，以及将来继续访问该资源时的策略。
Connection:keep-alive
Content-Encoding:gzip
Content-Type:text/html; charset=utf-8
Date:Fri, 24 Jun 2016 06:23:31 GMT
Server:nginx/1.9.12
Transfer-Encoding:chunked

响应体：响应体是服务端返回给客户端的HTML文本内容，或者其他格式的数据，比如：视频流、图片或者音频数据。
响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。


***************

关于请求体的格式， 
Http 请求头和响应头都有一个 头字段：Content-Type，表示的是 post请求的请求体格式 或者 服务器返回的响应体的格式
Content-Type通常有这几种格式
’application/json’ 
’application/x-www-form-urlencoded’
’multipart/form-data’

不同的类型，服务端接收方式是不同的，前端发送方式也是有区别的
application/json：将json数据序列化之后再发送，个人理解是转成字符串发送
application/x-www-form-urlencoded：表单提交，个人理解是转成键值对发送
multipart/form-data: 参数会被分割成多块，每一个参数块都有自己独立的content-type，这种方式可以用于提交普通表单和文件上传

***************

主要区分一下get和post
此外还有put和delete，从restful的规范来说，增删改查分别对应 put，delete，post，get

1.提交数据的形式：
GET请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，会直接展现在地址栏中，以?分割URL和传输数据，参数之间以&相连，如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5 %A5%BD。
如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，
得出如：%E4 %BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。
而POST方法则会把数据放到 请求数据（请求体） 字段中以&分隔各个字段，请求行不包含数据参数，地址栏也不会额外附带参数

2.提交数据的大小
  get方法提交数据的大小直接影响到了URL的长度，但HTTP协议规范中其实是没有对URL限制长度的，限制URL长度的是客户端或服务器的支持的不同所影响：
比如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。
  post方式HTTP协议规范中也没有限定，起限制作用的是服务器的处理程序的处理能力。
所以大小的限制还是得受各个web服务器配置的不同而影响。

3.提交数据的安全
POST比GET方式的安全性要高
通过GET提交数据，用户名和密码将明文出现在URL上，因为一下几个原因get方式安全性会比post弱：
(1)登录页面有可能被浏览器缓存
(2)其他人查看浏览器的历史纪录，那么别人就可 以拿到你的账号和密码了
(3)当遇上跨站的攻击时，安全性的表现更差了

------------

端口
一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。
那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。

TCP端口和UDP端口。由于TCP和UDP 两个协议是独立的，因此各自的端口号也相互独立，比如TCP有235端口，UDP也 可以有235端口，两者并不冲突。

公认端口
这类端口也常称之为"常用端口"。
这类端口的端口号从0到1024，它们紧密绑定于一些特定的服务。通常这些端口的通信明确表明了某种服务的协议，这种端口是不可再重新定义它的作用对象。
例如：80端口实际上总是HTTP通信所使用的，而23号端口则是Telnet服务专用的。这些端口通常不会像木马这样的黑客程序利用。

------------------------------------------------------------------------------------------------------------------------------------------------------------------

TCP （传输层）

TCP报文格式0是不怎么重要的，1、2、3是比较重要的
（0）源端口、目的端口、数据偏移、窗口、校验和、紧急指针、选项和填充、数据部分
（1）序号：Seq序号（Sequence number），占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
		    每台机器的序列号都是属于这台机器的，例如计算机A发送到计算机B的数据包的序列号，和计算机B发送给计算机A的序列号是完全不一样的
（2）确认序号：Ack序号（Acknowledgment number），占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
                           Ack确认号通常是这么用的：主机A发送给主机B数据和Seq，主机B回复Ack表明已经收到了数据。
（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
  　　（A）URG：紧急指针（urgent pointer）有效。
  　　（B）ACK：确认序号有效。
  　　（C）PSH：接收方应该尽快将这个报文交给应用层。
  　　（D）RST：重置连接。
  　　（E）SYN：发起一个新连接。
  　　（F）FIN：释放一个连接。

---------------------

三次握手
(1).客户端随机生一个数x，发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。
(2).服务器端收到SYN报文，也随机生成一个数y，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。
(3).客户端收到服务器端的SYN报文，回应一个 (SEQ =x+1） ACK(ACK=y+1）报文，进入Established状态。
注意：以上三次通讯之后，握手完成，至此，序列号seq和确认号ack都使用了通讯双方的随机数进行加密
	   握手完成之后的这个seq我们称之为 ISN初始序列号，它是由初始序列号随机算法生成的，

为什么是三次？
为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。
 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。
如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

总结：
第一次握手 主机A发送SYN和主机A的序列号SEQ给主机B
第二次握手 主机B对主机A回复ACK和主机B的序列号SEQ（这里的SEQ和第一次握手的SEQ不能弄混，主机B的序列号SEQ是指主机B向主机A发送数据的序列号）
第三次握手 主机A对主机B回复ACK

SEQ是随机产生的，不能是固定值，避免通讯时被攻击
ISN（初始序列号），据我理解ISN和SEQ是相同的意思，很多博客在描述三次握手时使用了ISN的概念，可能握手时使用的seq被叫做isn

---------------------

传输流程

建立连接后，两台主机就可以相互传输数据了
传输过程也同样需要使用到 TCP报文中的 序列号Seq，确认号Ack，
注意：这里使用到的  序列号Seq，确认号Ack就是第三次握手时使用的值， (SEQ =x+1） ACK(ACK=y+1），无论是A给B发，还是B给A发都是用这个值
简单来说就是，主机A发送seq和数据给主机B，主机B回复ack，即算是一次数据传输成功

使用的标志位应该是 PSH

主机A发送 (SEQ =x+1） 、ACK(ACK=y+1）、字节数为100  的数据给主机B
主机B回复Ack=x+1 + 100+1，Seq=y+1
回复的Ack=主机A发过来的序列号+数据长度+1，因为传输过程中可能丢包，所以要加上数据长度，表明完整地收到了数据，最后加 1 是为了告诉对方要传递的 Seq 号
回复的Seq为主机A发过来的确认号，即y+1。

随着不断地通讯，使用的seq和ack会越来越往上增加。
如果没有 数据长度，返回的确认号就是发来的序列号+1


---------------------

四次挥手
(1).客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
(2).服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 
(3).服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
(4).客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 

------------------------------------------------------------------------------------------------------------------------------------------------------------------

IP协议 网络层

报文格式，1位就是1bit
4位版本：IP报文版本号 IPV4:4，IPV6:6
4位首部长度：IP header 长度，没有选项，则一般为5（5x32bit＝20B）
8位服务类型：一般没有使用，详细参考RFC
16位总长度：header＋数据 总长度
16位标识：IP 报文的唯一id，分片报文的id 相同，便于进行重组。
3位标志：标明是否分片。
13位片偏移：参考下图。如果是第一片取值为0，第二片取值175，以此类推。
8位TTL：生存时间，即路由器的跳数，每经过一个路由器，该TTL 减一，因此路由器需要重新计算IP报文的校验和。
8位协议：ICMP：1，TCP：6，UDP：17，其他的自行百度
16位首部校验和：IP header校验和，接收端收到报文进行计算如果校验和错误，直接丢弃。
32位源IP地址：无须解释
32位目的IP地址：无须解释
选项：这个一般也没有使用。详细参考RFC
数据：上层的报文，如TCP 报文、UDP报文等。


几个协议：
ICMP（Internet Control Message Protocol：互联网控制消息协议）：主要负责网络层和传输层的数据交换，是为了更有效地转发IP数据报文和提高数据报文交付成功的机会，是介于传输层和网络层之间的协议。
ARP（Address Resolution Protocol：地址解析协议）：主要是将IP地址解析成MAC地址的协议。
RARP（Reverse Address Resolution Protocol：逆地址解析协议）：正好相反，是将MAC地址解析成IP地址的协议。
IP协议（Internet Protocol：网际协议）：是TCP/IP协议族中最为核心的协议。它提供不可靠、无连接的服务，也即依赖其他层的协议进行差错控制。


重点介绍 ARP协议：
工作过程
主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；
主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；
当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：
第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。
第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。
第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。
第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。


----------

网络层 IP协议的自我总结

IP地址是不能直接用来进行通信的。这是因为IP地址只是主机在抽象的网络层中的地址。
若要将网络层中传送的数据报交给目的主机，还要传到链路层转变成MAC帧后才能发送到实际的网络上。
因此，不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用MAC硬件地址。

mac地址可以标识全世界上唯一一台主机，仅仅在局域网内有效。
ip地址可以标识世界上唯一一台联网的主机，在广域网内也有效

交换机是利用bai物理地址或者说MAC地址来确定du转发数据的目的地址。
MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。

ARP表 和 ARP请求
ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。
ARP相当于一个键对值，键是ip，对是MAC地址，ARP表保存在 主机或者路由器上。

-------
局域网之间 主机间的通讯，
两台主机之间的通讯需要 IP地址和MAC地址。
如果是局域网之间通讯，主机A 想要和 IP为B的主机B通讯，只需要广播发送ARP请求到全网的网络设备上，
此时主机B收到主机A的数据，发现数据包是给自己的，因为数据包里面包含了IP地址和MAC帧，所以主机B知道了主机A的ip和mac，
接着主机B返回数据给主机A，主机A也就知道了主机B的ip和mac。
首次建立连接之后，有了ARP表，以后就不用再发广播了。


不同网段间主机通信
主机A可以通过ip地址检查到目标地址主机B是否与自己在同一网段内，
如果不在，广播发送ARP请求  找到路由网关（网关是一个概念，路由器能够实现网关的功能，可以看做路由就是网关），
网关收到后就会回应主机 A ，把网关的MAC地址告诉主机 A ，当获取到网关的MAC地址后，把网关的MAC地址作为MAC帧中的目的MAC地址，
然后就把数据丢给网关 192.168.0.1 ，网关根据路由表，转发给下一个路由器，再由下一个路由器交付给主机 B 所在的网络，即网关，网关再通过ARP，找到目的主机 B，完成数据交付。

网关的ip地址通常都是本局域网内的ip段，尾段改为1，例如 xxx.xxx.xxx.1 

路由表的基本查找方法是：
搜索路由表，寻找与目的IP地址完全匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接相连的网络接口
搜索路由表，寻找与目的IP地址网络号匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接相连的网络接口
搜索路由表，寻找“默认（default）”表目。如果找到，则把报文发送给该表目指定的下一站路由器
 
--------

主机A 到 主机B 的数据，主要是通过 IP地址来指明方向的（例如 我的主机 get请求到 淘宝的服务器）
首先主机A域名解析出一个淘宝的ip地址，再层层封装到数据，接着使用，发送数据到本局域网内的路由器A上，
互联网上有数不胜数的路由器连接着，而路由器A也连着多个路由器，
路由器A根据IP地址查找路由表，把数据发向下一跳的路由器，经过多个路由器的发送，最终发到了主机B的局域网的路由器上,接着发给主机B
路由器根据 进行选址，选择发送到哪一个路由器上。


三个概念：路由器，路由表，路由协议
Internet网络的主要节点设备是路由器，路由器通过路由表来转发接收到的数据。转发策略可以是人工指定的（通过静态路由、策略路由等方法）。
路由协议是用来确定到达路径的，它包括RIP，IGRP（Cisco私有协议），EIGRP（Cisco私有协议），OSPF，IS-IS，BGP。
起到一个地图导航，负责找路的作用。它工作在网络层。
路由表就是路由协议计算出来的结果。路由器查找路由表，获取到前往下一跳路由器的ip地址。
主机上也有路由表，例如mac系统就可以在终端输入 netstat -nr命令查看路由表

例如最简单的 RIP路由协议，路由器运行RIP后，会首先发送路由更新请求，收到请求的路由器会发送自己的RIP路由进行响应；网络稳定后，路由器会周期性发送路由更新信息。


------------------------------------------------------------------------------------------------------------------------------------------------------------------

数据链路层和物理层

这一层主要涉及到一些物理传输，比如以太网，无线局域网，电缆等

IP数据包到了这层就不一样了啊！数据链路会在IP数据报的首尾加上首部和尾部代表数据包的结束，封装成帧。首部和尾部都是8位2进制表示，可以一样也可以不一样。

再往下到物理层就成为比特流传输了

------------------------------------------------------------------------------------------------------------------------------------------------------------------

加密算法

对称加密:A与 B 之间之间的通讯数据都用同一套的密钥来进行加密解密。
对称加密通常有 DES,IDEA,3DES 加密算法。


非对称加密：用公钥和私钥来加解密的算法。打个比方，A 的公钥加密过的东西只能通过 A 的私钥来解密；同理，A 的私钥加密过的东西只能通过 A 的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。
缺点，加解密比对称加密耗时.
优点，比对称加密安全.
但是非对称加密也是存在漏洞，因为公钥是公开的，如果有 C 冒充 B 的身份利用 A 的公钥给 A 发消息，这样就乱套了，所以接下来就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。
常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）
RSA目前来说还算安全，可以用在SSL/TLS上


Hash算法（摘要算法），不可逆算法
Hash算法的特点是单向不可还原，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。只要源数据不同，算法得到的摘要必定不同。
常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA
目前仅剩SHA-2算法是安全的，其他算法均可破解


数字签名
数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。
数字签名是 A将原始明文通过 hash 算法得到摘要，这个摘要是不可逆的；将明文加密，连同摘要一起发送给B；B接收到后解密，得到这个摘要a和加密的明文，再将加密明文解密得到原始明文，然后通过同一 hash 算法得到新的摘要b，比较a与b就可得知在传输过程中是否被更改过。
因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。


------------------------------------------------------------------------------------------------------------------------------------------------------------------

TLS/SSL，SpringBoot，数字签名和数字证书，公钥私钥 
SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。
TLS与SSL在传输层与应用层之间对网络连接进行加密。
-------------------------------
公钥私钥都可以用来加密和解密，一般私钥服务机保留用来加密报文，公钥发给客户机用来解密服务机发过来的报文
私钥加密公钥解密

数字签名
首先通过数字摘要技术（哈希摘要算法）把交易信息缩短成固定长度的字符串，然后用非对称加密技术（私钥）对摘要进行加密，进而形成数字签名。

数字证书
数字签名，用户公钥，用户某些相关信息组成数字证书。数字证书被 证书授权中心 的私钥加密
数字证书是附带在发送的报文上的

服务端发送原报文和数字证书给客户端，客户端开始验证：
数字证书用ca的公钥解密，得到用户公钥和数字签名
公钥解密数字签名得到 数字摘要
原报文进行哈希摘要算法得到另一份数字摘要
两份数字摘要进行对比

数字摘要进行对比验证 完整性，确保信息没有被修改过
公钥私钥的加解密验证 通信双方的合法性并且保证报文不是明文，确保通信的对方的身份正确
数字证书中心也是确保 通信双方的合法性，当客户端没有服务端的公钥时，数字证书中心的公钥解密报文，拿到服务端的公钥。
客户端浏览器中内置的受信任的数字证书中心，浏览器中有一个默认的数字证书中心列表

Certificate报文发送之后，互相确认了通信双方的身份，也拥有了服务端的公钥，之后双方就是用公钥私钥加密通信。

在https中这套机制是在 传输层 中的，用于tcp握手，握手完成之后，双方用公私钥，加解密传输信息。
-------------------------------

windows查看证书
底部任务栏搜索internet选项，或者控制面板找internet选项，或者ie浏览器的工具的internet选项
internet选项 -> 内容
受信任的根证书颁发机构 就是ca，例如：Actalis Authentication Root CA


------------------------------------------------------------------------------------------------------------------------------------------------------------------


HTTPS:
0.建立TCP连接
由于SSL协议依赖于TCP连接实施，所以在SSL交互之前需要先建立TCP连接。客户端connect服务端，服务端acccept客户端，经历三次握手以后TCP连接建立。

具体数据交互过程：
1. 客户端发送 Client Hello给服务端

2. 服务端发送 Server Hello给客户端
   服务端发送 Server Certificate报文
   服务端发送 Client server key exchange报文
   服务端发送 Certificate request报文
   服务端发送 Server hello done报文

3. 客户端发送 Client Certificate报文
   客户端发送 Client key exchange报文
   客户端发送 Certificate verity报文
   客户端发送 change cipher spec 报文
   客户端发送 Client finish message报文

4. 服务端发送 change cipher spec 报文
   服务端发送 server finish message报文

Client Hello
	1.Version Number. 2 for SSL 2.0 ； 3 for SSL 3.0 ；3.1 for TLS.
	2.Randomly Generated Data. 随机码，（random_C，也叫Client random）用于生成MS（master secret）和MAC密钥，
	3.Session Identification (if any). 有或者无，有则客户端传上一次session的id可以恢复session
	4.Cipher Suite. 客户端支持的密码算法列表，供服务器选择
	5.Compression Algorithm. 客户端支持的压缩算法列表，供服务器选择
	
Server Hello.
	1.Version Number. 服务器选择的版本
	2.Randomly Generated Data. 随机码，（random_S，也叫Server random）用于生成MS（master secret）和MAC鉴别码。此时服务端已经可以生成自己的MS，（master secret）后面会对比客户端生成的M，用于会话加密，是对称的。MAC密钥用于鉴别报文完整性。
	3.Session Identification (if any). 有3种情况，1无：说明这次是新session；2新的，表明是新session，可能是服务器恢复旧session失败导致；3旧的：服务器恢复session成功，这个id与客户端给的一样。
	4.Cipher Suite. 服务端选择的密钥算法
	5.Compression Algorithm. 服务端选择的压缩算法

Server Certificate. 服务端的公钥证书，包含公钥

Server Key Exchange. 通常没有，可选的，是一个暂时用于加密客户端发送的信息。仅仅用于服务端的公钥无法对信息加密

Client Certificate Request. 请求客户端的公钥，可选的。

Server Hello Done. 说明hello结束，等待客户端回应

Client Certificate. 发送客户端公钥

Client Key Exchange. 证书没问题，用双方选择的随机码生成pre-master secret，用服务端公钥加密后发送，用于会话加密，是对称密钥。

Certificate Verify. 仅当客户端发送的自己公钥时会有。数字签名，客户端用自己私钥加密，服务端用客户端给的公钥解密，做端点鉴别。

Change Cipher Spec. 告诉服务端已经用协商好的算法加密信息。

Client Finished. 一段用服务端公钥以及加密信息的hash，如果服务端能解开，说明没问题

Change Cipher Spec Message. 告诉客户端已经用协商好的算法加密信息

Server Finished Message.

关于身份验证：
服务端和客户端(可选)都会发送自己的证书给对方，通过数字证书验证对方身份的合法性

关于加密随机数的生成：
客户端:
计算产生随机数字Pre-master
	此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 random_C 和 random_S 与自己计算产生的 Pre-master，
	计算得到协商密钥:enc_key=Fuc(random_C, random_S, Pre-Master)
	在Client Key Exchange（第三次握手）中发服务端
服务器:
	用私钥解密加密的 Pre-master 数据，基于之前交换的两个明文随机数 random_C 和 random_S，
	计算得到协商密钥:enc_key=Fuc(random_C, random_S, Pre-Master);
random_C 和 random_S：
	在hello阶段就互相发送给对方的随机数

MS: master secret，用于对称加密，master_secret就是上面的enc_key，它由三个随机数加密而成
MAC : message authentication key ，用于鉴别报文完整性。注意与链路层的MAC区别
MS和MAC都是由两个随机数生成的。

正式开始通信：
将http明文加密后进行传输
双方通信的密文由 明文加密钥加算法 组成。先用密钥加密，再用算法加密。


总结：
1.客户端向服务端发出请求，包含协议版本号、随机数Client random，以及客户端支持的加密方法
2.服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）
3.客户端确认数字证书有效，生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数
4.服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）
5.由于双方都拿到了三个随机数，就可以根据之前约定的加密方法，使用前面的三个随机数来生成"对话密钥"（session key）
6.双发都有了对称秘钥，就可以用来加密接下来的整个对话过程。

为什么不用 证书里面的公钥来加密？
因为非对称加密非常耗时，基本只在建立https连接时使用。





--------------------------------------------------------------------------------------


HTTPS,常称为HTTP over TLS,HTTP over SSL

重点介绍 TLS、SSL
事实上我们现在用的都是TLS，TLS1.0和SSL3.0几乎没有区别，但因为历史上习惯了SSL这个称呼，平常还是以SSL为多。
所以最新的技术还是TLS

SpringBoot内置tomcat配置SSL证书
1.将阿里云域名   cyclothe.com  解析成www.cyclothe.com  到你的服务器下

2.将域名对应的443  80  端口开发安全组,    浏览器默认对80端口隐藏

3.去阿里云的域名中申请免费的ssl证书, 下载tomcat版

4.将下载好的文件放到resource下

5.配置你的yml文件:

server:
  port: 443 #服务端口
  ssl:
    key-store: classpath:1844576_www......cn.pfx (下载的文件名)
    key-store-password: 你的证书密码
    key-store-type: PKCS12

6:创建跳转https配置文件
就是把80端口的访问重定向到433端口



7:访问你的浏览器
















--------------------------------------------------------------------------------------



















