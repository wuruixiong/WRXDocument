
设计模式

java代码
	JDK JRE
	基础语法，数据类型
	算法
	jdk8

java高级
	高级特性
	注解
	jvm虚拟机
		内存分区
		新生代回收器，老生代回收器
		强、弱、软，虚引用
		gc机制
	java11和java14高级特性
	
高并发，多线程，线程同步，反射，异常，泛型
内存泄漏
死锁，活锁，乐观锁，悲观锁
数据脏读，幻读
缓存击穿，雪崩
熔断，降级，监控
负载均衡

spring开发
	springmvc
	结构分层：表现层，业务层，持久层
	ioc控制反转(或者叫di依赖注入)，aop面对切面编程，ioc容器
	spring 动态代理
	spring boot，底层代码解析，注解实现
	spring cloud 重要组件
		Netflix Eureka注册中心
		Ribbon负载均衡
		Fegin
		Hystrix
		Zuul网关
	spring security
		oauth2
	spring data
		jpa
	中间件
		rabbitMQ消息队列
		kafka
	事务控制
	restful风格
	阿里框架
		dubbo，zookeeper
	两种注册中心的对比，也是http和rpc协议的对比
		eureka，zookeeper
	springCloud netflix 
	springCloud alibaba
		spring cloud中的几乎所有的组件都使用Netflix公司的产品，在其基础上做了一层starter的封装
		然而Netflix的服务发现组件Eureka已经停止更新
		将来的框架选型可能会更多的偏向springCloud alibaba

数据库相关
	基础sql语言的使用
	nosql，redis，MongoDB
	sql，mysql，sqllite
	持久层框架，mybatis，jpa，ORM框架 对象关系映射

 搜索
	ElasticSearch


数据安全，加密，网络协议
数据安全
	数据库的数据加密存储方案
	加密RSA的衍生协议
	对称加密，非对称加密，不可逆加密
	实际应用
	数字签名，摘要算法
网络协议
	网络协议基础，tcp/ip五层结构
		tcp握手
	http
		通讯过程ß
	https：结合数据安全，保证通讯安全
		通讯过程

部署工具
	docker
	k8s

版本控制工具
	git
	svn

项目构建工具
	maven
	gradle

---------------------------------------------------------------------------------

Spring

IOC
IOC（Inverse of Control）反转控制，就是将原本在程序中手动创建类对象的控制权，交由Spring框架管理。
DI（Dependency Injection）依赖注入，就是在Spring创建某个对象的过程中，将这个对象所依赖的属性（变量或其它类对象）注入进去。
IOC就是DI
IOC就是典型的工厂模式，通过BeanFactory去注入实例。

IOC简单例子
创建Person类、applicationContext.xml配置文件（在配置文件中配置Bean标签，对Person添加id，并对成员变量赋值）
在mian方法中创建ApplicationContext，通过id创建Person对象

在我们加载IOC容器后，Spring就会全自动的为我们创建相应的对象，此时我们就无需再自己 new 创建对象了
这就是所谓的控制反转，将创建对象的权限反转给Spring IoC容器，
对类之间的关系进行了解耦
所以Spring IoC容器会帮我们做两件事：1. 创建对象  2. 为属性赋值

Spring IoC设计的核心是Bean容器
BeanFactory采用了java经典的工厂模式，通过从xml配置文件中读取javaBean的定义，来实现javaBean的创建、配置和管理bean与bean之间的依赖关系，
所以BeanFactory可以称为IoC容器。
ApplicationContext的中文含义是: 应用上下文，继承自BeanFactory接口


IOC工厂模式详情


------
spring 支持几种 bean 的作用域？

当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：

singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例
prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例
equest：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效
session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效
globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效
其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。

如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。


-------------------

AOP

AOP就是典型的代理模式的体现。
AOP:面向切面编程。（Aspect-Oriented Programming）
AOP可以说是对 OOP（面向对象编程） 的补充和完善。
1.面向切面编程提供声明式事务管理 
2.spring支持用户自定义的切面 

AOP是面向切面的编程，其编程思想是把散布于不同业务但功能相同的代码从业务逻辑中抽取出来，
封装成独立的模块，这些独立的模块被称为切面，切面的具体功能方法被称为关注点。在业务逻辑执行过程中，
AOP会把分离出来的切面和关注点动态切入到业务流程中，这样做的好处是提高了功能代码的重用性和可维护性。

AOP一般适用于具有横切逻辑的场合，如访问控制、事务管理、性能检测等。
说白了 AOP就是用来打印日志。


AOP代理模式详情


---------------------------------------------------------------------------------

Spring MVC运行流程：

在这里插入图片描述Spring运行流程描述：

用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；

DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；

DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）

提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：

1、HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息
2、数据转换：对请求消息进行数据转换。如String转换成Integer、Double等
3、数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
4、数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中

Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；

根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；

ViewResolver 结合Model和View，来渲染视图；

将渲染结果返回给客户端。



Spring MVC的核心组件：

DispatcherServlet：中央控制器，把请求给转发到具体的控制类
Controller：具体处理请求的控制器
HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略
ModelAndView：服务层返回的数据和视图层的封装类
ViewResolver：视图解析器，解析具体的视图
Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作

---------------------------------------------------------------------------------

Netflix Eureka注册中心
Ribbon负载均衡
Fegin
Hystrix
Zuul网关

-------------------

Hystrix
服务熔断，服务降级

---------------------------------------------------------------------------------




缓存穿透、缓存击穿、缓存雪崩

缓存 redis





---------------------------------------------------------------------------------

SQL
mybatis

















---------------------------------------------------------------------------------

消息队列中间件
rabbitMQ消息队列
kafka











---------------------------------------------------------------------------------


事务：

所谓的事务，就是数据库事务，而spring中事务指的是对数据库事务的封装，具体也能体现在代码上。

在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致以下问题：
脏读（Dirty read）、脏写（Dirty write）
不可重复读（Nonrepeatable read）
幻读（Phantom reads）

我们在实际业务场景中，经常会遇到数据频繁修改读取的问题。在同一时刻，不同的业务逻辑对同一个表数据进行修改，
这种冲突很可能造成数据不可挽回的错乱，所以我们需要用事务来对数据进行管理。

事务的概念
事务其实就是一系列指令的集合。
一个或者一组sql语句来完成一个功能

事务必须服从ACID原则。ACID指的是原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。
原子性：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，
              所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。
一致性：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。
隔离性：在该事务执行的过程中，无论发生的任何数据的改变都应该只存在于该事务之中，
             对外界不存在任何影响。只有在事务确定正确提交之后，才会显示该事务对数据的改变。
             其他事务才能获取到这些改变后的数据。
持久性：当事务正确完成后，它对于数据的改变是永久性的。


ACID的理解，
一致性：个人理解，一致性的最基础的，其他三个都是为了实现最终的一致性而区分出来的。
在数据库中：
保证原子性，通过日志，将所有对数据的更新操作写入日志，如果事务失败，就对还未成功的指令进行undo撤销还原操作（回滚数据），
保证持久性，对已经成功但是还未写入磁盘的操作进行redo重做流程
保证隔离性 当并发事务执行时，每个事务（多组SQL命令）之间互不影响
以上这些操作都是为了保证全部数据的一致性


​当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，
称buffer pool的数据页为dirty page 脏数据，如果这个时候发生非正常的DB服务重启，那么这些数据还没在内存，并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），
也就是会发生数据丢失，如果这个时候，能够在有一个文件，当buffer pool 中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），
那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。

------------------

为了实现一致性，引入了两种锁，悲观锁、乐观锁

悲观锁





乐观锁



------------------

 数据库事务的隔离级别
数据库事务的隔离级别有4个，这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题。
1. Read UnCommitted(读未提交) 不能防止 脏读 、不可重复读 、幻读
最低的隔离级别。一个事务可以读取另一个事务并未提交的更新结果。
2. Read Committed(读提交) 可以防止脏读
大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果。
3. Repeatable Read(重复读) 可以防止 脏读 、不可重复读 
mysql的默认级别。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。
4. Serializable(序列化) 防止  脏读 、不可重复读 、幻读
最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。


脏数据
是指事务对缓冲池中行记录的修改，并且还没有提交。

脏读
指的是在不同事务下，当前事务可以读取到另外事务未提交的数据，简单来说就是可以读到脏数据。
和脏页不同，如果读到了脏数据，即一个事务读取到了另外一个事务未提交的事务，显然违反了了事务的隔离性

不可重复读
指在一个事务内多次读取同一数据，在这个事务还没结束时，另一个事务也访问该数据，并修改了改数据，因此在第一个事务中的两次读取数据之间，
由于第二个事务的修改，第一个事务两次读取到的数据可能是不一样的。这样就发生了在一个事务内两次读取的数据是不一样的，这种情况称为不可重复读。
注意和脏读的区别：脏读读取到的是未提交的数据，不可重复读读到的是已提交的数据，但违反了数据库事务的一致性

幻读
事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

不可重复读的重点是修改:
同样的条件, 你读取过的数据, 再次读取出来发现值不一样了

幻读的重点在于新增或者删除 (数据条数变化)
同样的条件, 第1次和第2次读出来的记录数不一样
幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。


防止方法：
脏读：修改时加排他锁，直到事务提交后才释放，读取时加共享锁，读取完释放事务1读取数据时加上共享锁后（这 样在事务1读取数据的过程中，其他事务就不会修改该数据），不允许任何事物操作该数据，只能读取，之后1如果有更新操作，
那么会转换为排他锁，其他事务更 无权参与进来读写，这样就防止了脏读问题。
但是当事务1读取数据过程中，有可能其他事务也读取了该数据，读取完毕后共享锁释放，此时事务1修改数据，修改 完毕提交事务，其他事务再次读取数据时候发现数据不一致，就会出现不可重复读问题，所以这样不能够避免不可重复读问题。

不可重复读：读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁。读取时候不允许其他事物修改该数据，不管数据在事务过程中读取多少次，数据都是一致的，避免了不可重复读问题
和脏读相比，不可重复度的操作建立在事务上，只有事务提交之后才释放锁。

幻读问题：采用的是范围锁RangeS RangeS_S模式，锁定检索范围为只读，这样就避免了幻影读问题


---------------------------------------------------------------------------------

Spring事务
Spring也有事务的概念，也要遵循ACID原则。原子性、一致性、隔离性、持久性


传播特性



声明式事务、编程式事务

1. 编程式事务管理
编程式事务管理是侵入性事务管理，使用TransactionTemplate或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring推荐使用TransactionTemplate。

2. 声明式事务管理
声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。
编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。
显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。




































	
