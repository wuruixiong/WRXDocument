
设计模式

java代码
	JDK JRE
	基础语法，数据类型
	算法
	jdk8

java高级
	高级特性
	注解
	jvm虚拟机
		内存分区
		新生代回收器，老生代回收器
		强、弱、软，虚引用
		gc机制
	java11和java14高级特性
	
高并发，多线程，线程同步，反射，异常，泛型
内存泄漏
死锁，活锁，乐观锁，悲观锁
数据脏读，幻读
缓存击穿，雪崩
熔断，降级，监控
负载均衡

spring开发
	springmvc
	结构分层：表现层，业务层，持久层
	ioc控制反转(或者叫di依赖注入)，aop面对切面编程，ioc容器
	spring 动态代理
	spring boot，底层代码解析，注解实现
	spring cloud 重要组件
		Netflix Eureka注册中心
		Ribbon负载均衡
		Fegin
		Hystrix
		Zuul网关
	spring security
		oauth2
	spring data
		jpa
	中间件
		rabbitMQ消息队列
		kafka
	事务控制
	restful风格
	阿里框架
		dubbo，zookeeper
	两种注册中心的对比，也是http和rpc协议的对比
		eureka，zookeeper
	springCloud netflix 
	springCloud alibaba
		spring cloud中的几乎所有的组件都使用Netflix公司的产品，在其基础上做了一层starter的封装
		然而Netflix的服务发现组件Eureka已经停止更新
		将来的框架选型可能会更多的偏向springCloud alibaba

数据库相关
	基础sql语言的使用
	nosql，redis，MongoDB
	sql，mysql，sqllite
	持久层框架，mybatis，jpa，ORM框架 对象关系映射

 搜索
	ElasticSearch


数据安全，加密，网络协议
数据安全
	数据库的数据加密存储方案
	加密RSA的衍生协议
	对称加密，非对称加密，不可逆加密
	实际应用
	数字签名，摘要算法
网络协议
	网络协议基础，tcp/ip五层结构
		tcp握手
	http
		通讯过程
	https：结合数据安全，保证通讯安全
		通讯过程

部署工具
	docker
	k8s

版本控制工具
	git
	svn

项目构建工具
	maven
	gradle

---------------------------------------------------------------------------------

JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。
JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。
具体来说 JDK 其实包含了 JRE。

--------------------
三种表格
List 元素可重复，读取顺序是有序的，vector线程安全
Map 键对值，HashTable线程安全
Set 类似于list，元素不可重复，存入与取出的顺序有可能不一致

---------------------------------------------------------------------------------

 jvm 的主要组成部分？及其作用？
类加载器（ClassLoader）
运行时数据区（Runtime Data Area）
执行引擎（Execution Engine）
本地库接口（Native Interface）

组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，
运行时数据区（Runtime Data Area）再把字节码加载到内存中，
而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，
因此需要特定的命令解析器  执行引擎（Execution Engine），将字节码翻译成底层系统指令，
再交由 CPU 去执行，而这个过程中需要调用  其他语言的本地库接口（Native Interface） 来实现整个程序的功能。

Android的虚拟机叫做 ART，也是java虚拟机的一种。

---------------------------------------------------------------------------------

Java类加载机制
JVM加载的是.class文件。其实，类的加载指的是将类的.class文件中的二进制数据读入到内存中，
将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。
类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，
并且向Java程序员提供了访问方法区内的数据结构的接口。

JVM将类的加载分为3个步骤：
1、装载（Load）
2、链接（Link）
3、初始化（Initialize）

而链接（Link）又分3个步骤：
1，验证
2，准备
3，解析

---------------------------------------------------------------------------------

 jvm 运行时数据区:

程序计数器   线程私有
虚拟机栈   线程私有
本地方法栈   线程私有
堆
方法区

有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。

--------------------

JVM 虚拟机技术

JVM是Java Virtual Machine（Java虚拟机）的缩写，是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
Java虚拟机主要由字节码指令集、寄存器、栈、垃圾回收堆和存储方法域等构成。 JVM屏蔽了与具体操作系统平台相关的信息，
使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，
实际上最终还是把字节码解释成具体平台上的机器指令执行。

Heap是堆，stack是栈
JVM内存结构分为：方法区（method），栈内存（stack），堆内存（heap），本地方法栈（java中的jni调用）

Java Heap
对象和数组就是存放在堆里面。
Java虚拟机管理的内存的最大一块，这块区域随着虚拟机的启动而创建。
线程安全的问题，Java Heap是一块共享的区域，操作共享区域的成员就有了锁和同步。
与Java Heap相关的还有Java的垃圾回收机制（GC）,Java Heap是垃圾回收器管理的主要区域。
新生代、老生代、永久代的概念就是在堆里面，现在大多数的GC基本都采用了分代收集算法。
Java Heap还有Eden空间，From Survivor空间,To Survivor空间等。
Java Heap可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。

栈（Stack）也称Java虚拟机栈（VM Stack）
相对于Java Heap来讲，Java Stack是线程私有的，她的生命周期与线程相同。Java Stack描述的是Java方法执行时的内存模型，
每个方法执行时都会创建一个栈帧（Stack Frame）用于存储 局部变量表、操作数栈、动态链接、方法出口等信息。
每个线程在执行一个方法时，都意味着有一个栈帧在当前线程对应的栈帧中入栈和出栈。

本地方法栈（Native Stack）
本地方法栈（Native Stack）与Java虚拟机站（Java Stack）所发挥的作用非常相似，
他们之间的区别在于虚拟机栈为虚拟机栈执行java方法（也就是字节码）服务，而本地方法栈则为使用到Native方法服务。

方法区（Method Area）与堆（Java Heap）一样，是各个线程共享的内存区域，
它用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是她却有一个别名叫做非堆（Non-Heap）。
分析下Java虚拟机规范，之所以把方法区描述为堆的一个逻辑部分，应该觉得她们都是存储数据的角度出发的。
一个存储对象数据（堆），一个存储静态信息(方法区)。

对象是存放堆里面，对象的引用应该是存在栈里面的

1、线程私有的数据区域有：
Java虚拟机栈（Java Virtual Machine Stacks）
本地方法栈（Native Stack）
2、线程共有的数据区域有：
堆（Java Heap）
方法区

--------------------

上面提到的Java虚拟机栈：
Java的栈中存储以下类型数据，栈对应的英文单词是Stack
基本类型
引用类型变量
方法

栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。
栈有一个很重要的特殊性，就是存在栈中的数据可以共享。

在函数中定义的一些基本类型的变量(8种)和对象的引用变量都是在函数的栈Stack内存中分配。当在一段代码块中定义一个变量时，
java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。

堆Heap内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，
还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，
以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。

引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，
即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，
才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。
这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针。

--------------------

垃圾回收，GC机制

GC常用算法
GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。
目前主流的JVM（HotSpot）采用的是分代收集算法。
正是因为使用了分代收集算法，所以才有意义上的这些 年轻代，老年代

现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。
在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。
老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。


Heap（堆），Method Area（方法区）是垃圾回收机制的主要区域
堆有分为
新生代，新生代又分为 Eden空间，From Survivor空间，To Survivor空间
老年代

持久代：方法区 因为存储了不会被销毁的 静态变量，所以有些人把方法区成为 持久代
有的虚拟机并没有持久代，JAVA8 开始持久代也已经被彻底删除了，取代它的是另一个内存区域也被称为 Metaspace（元空间）
原先永生代中类的元信息会被放入本地内存（元数据区，meta space），将类的静态变量和内部字符串放入到java堆中。

1.当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC(也称minor gc)，也就是年轻代的垃圾回收。
一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。 
2.这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，
然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区， 
3.再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。
4.经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），
这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。 
5.老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收。
如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作。

--------------------

什么时候触发GC
       (1)程序调用System.gc时可以触发
       (2)系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）

GC又分为 minor GC 和 Full GC (也称为 Major GC )
Minor GC触发条件：
  当Eden区满时，触发Minor GC。

Full GC触发条件：
  a.调用System.gc时，系统建议执行Full GC，但是不必然执行
  b.老年代空间不足
  c.方法区空间不足
  d.通过Minor GC后进入老年代的平均大小大于老年代的可用内存
  e.由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

---------------------------------------------------------------------------------

Spring



-------------------

Netflix Eureka注册中心
Ribbon负载均衡
Fegin
Hystrix
Zuul网关

-------------------

Hystrix
服务熔断，服务降级




-------------------

缓存穿透、缓存击穿、缓存雪崩

























---------------------------------------------------------------------------------







	
	
