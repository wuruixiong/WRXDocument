

1.介绍一下自己
Android也是用java语言开发的，所以Java基础还需行，最习惯的开发工具是idea和android studio
版本控制工具，git，svn都用得很熟
Maven，gradle项目构建工具也用得很熟。
Spring 全家桶，springboot springcloud的框架也都挺熟悉的
redis，mybatis，rabbitmq


---------------------------------------------------------------------------------------------------------------



2. 容器
HashMap内部结构，数组+链表或者树的结构，数组为主体，数组的每一个元素都是 单向链表的表头或者树的根节点
插入数据时，是 调用了native方法hashcode获取一个哈希值，然后拿这个hash值右移16位再和他本身做异或，这样做是为了尽量保留他的hashcode的特征，高16位和低16位都保留
然后拿数组长度减1和刚刚得到的数做并运算，最后得到一个数组下标。
因为他的数组长度初始值是16，然后每次扩容的时候是拿当前长度左移1位，所以它的长度总是2次幂。
2次幂的数有一个特点，就是1后面接多个0，减1有一个特点，就是转换成2进制之后全是1。
所以拿数组长度-1去做并运算，得到的数组下标就不会越界。
这些其实都是为了减少hash冲突。


Arraylist内部是维护一个数组，增删改查基本都是围绕这个数组做的
LikeedList内部是一个双向链表，表元素的结构是自定义内部类。


---------------------------------------------------------------------------------------------------------------



3.AOP，IOC

IOC控制反转，就是将对象的创建和赋值，交给IOC容器来处理，我们只需提供配置即可。

IOC的好处，帮我们节省了 new对象，对象赋值的流程，只需要加上@AutoWrite注解，就会自动注入。
比方说，类A有一个全局变量类B，需要在构造方法或者set方法传入，那么如果有100个类持有类A并且要对类A的类B进行赋值，那就要写100次new和100次赋值。
如果现在类A中的类B需要换成类C，那就要修改100处代码。
现在有了IOC容器，自动注入，就节省了这一部分代码，只需在config中写一次创建的代码，赋值的代码甚至不需要写了，修改起来也特别简单。

AOP
切面编程，就是利用了动态代理的技术，实现 前置增强，后置增强，环绕增强的。

AOP 的代理bean创建流程，已经如何实现切面编程的原理：
创建过程可以重点理解 JDK动态代理，Cglib代理是怎么生成的。

1. 在BeanPostProcessor 后置处理中创建代理
2. 在DefaultAopProxyFactory中选择 JDK动态代理，Cglib代理
3. JDK动态代理是用 Proxy.newProxyInstance 把classload放进去最终生成一个动态代理类的
    每次我们调用动态代理类，其实都是使用了 invoke方法 把方法、参数进行调用的，在invoke之前和之后可以进行增强。
4. Cglib是继承被代理类，生成一个子类，重写它的方法中实现增强。


Bean的生命周期：

个人理解为四个阶段
1.实例化 Instantiation ，实例化就是调用构造函数，new对象
2.属性赋值 Populate，赋值就是对new出来的对象中的变量进行依赖注入，
自上而下的，如果检测当前对象依赖一个对象，对象又依赖一个对象，一直这么依赖下去，那么会直到一个对象不依赖，然后创建，然后一层一层往上进行注入
这个依赖注入有一个过程，还涉及循环依赖问题，

3.初始化 Initialization
又分几个阶段
检查bean是否实例了Aware接口，BeanNameAware，BeanClassLoaderAware，BeanFactoryAware，EnvironmentAware，EmbeddedValueResolverAware，ApplicationContextAware

BeanPostProcessor 

调用自定义的 InitializingBean接口或者 init-method配置

BeanPostProcessor 后置处理

4.销毁 Destruction
DisposableBean接口和destroy-method





循环依赖
三级缓存，三个hashmap
Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256); //一级缓存
Map<String, Object> earlySingletonObjects = new HashMap<>(16); // 二级缓存
Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16); // 三级缓存

第一缓存存放是已经完全初始化的对象
第二缓存是存放正在初始化中的对象
第三缓存存放对象工厂，生产出来的对象存放在第二级缓存中，同时移除自身对应的工厂元素






---------------------------------------------------------------------------------------------------------------

4.多线程

队列：
1. 直接提交队列：SynchronousQueue
2. 有界的任务队列：ArrayBlockingQueue实现
3. 无界的任务队列：用LinkedBlockingQueue实现
4. 优先任务队列：PriorityBlockingQueue实现，自定义规则根据任务的优先级顺序先后执行。




---------------------------------------------------------------------------------------------------------------


最近一个项目

1.离职原因，没有签订劳动合同，发工资的时候和入职时说好的不一样，难怪不肯签合同，感觉受到了欺骗。
   电脑配置太低，有不能用自己的开发，说是要换也没换。
   卡我社保，那家公司都不给交。
   老板人品不好，架构师还是ok的，所以才一直忍着做下去，最后还是受不了，就离开了。
   让我在那里工作时感到顾虑重重。
  
2.技术框架 mysql + mybatis + springboot，还用到 若依RuoYi自动代码生成，PowerDesigner建模工具，数据库 navicat 工具，Swagger 编写接口文档。
3.做ERP的，物业相关服务，saas系统架构，数据库级别隔离
4.saas系统，一套代码，多用户使用，区别是数据库不同。之前的项目是请人做的，各种bug很多，例如物业的住户有时候查询到别家物业的住户。
  例如，一个新物业购买了我们的产品，就会为他单独建立数据库，在配置文件中配置不同的mysql和redis，多个租户共享一套服务，但是动态创建数据库；动态切换数据库。

5.数据结构：上百张表格。目前只是维护了其中几张表。还创建了一张。

6.工作职责，从controller写到service写到mapper，从控制层到业务层到持久层
   根据具体业务需求，编写逻辑代码，对mysql进行增删改查，查询数据时使用redis（查询是否有缓存，没有就去mysql查，查到了就往缓存里面存一份），插入数据时使用redission分布式锁
   restful规范去返回数据给前端
   看了一下业务层，serviceimpl那里，是没有加事务的，提了一下意见，让我加上声明式事务，利用aop的技术去批量添加事务
   期间还经历了jvm调优事件，当时是这么调的，jvm老年代的比例稍微调高，调整回收算法，并行执行，调大整个堆内存，调大线程栈空间大小。























