MVC模式
MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，
一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，
在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、
处理和输出功能在一个逻辑的图形化用户界面的结构中。

--------------------------------------------------------------------

代码书写：
/**
 * 类的用途
 *
 * @author  作者名称
 * @since   JDK1.0
 */

/**
 * 方法用途
 * 
 * @param      参数1   解释
 * @param      参数2   解释
 * @param      参数3   解释
 * @return     解释
 *             
 * @exception  异常
 *                                             
 */


-------------------------------------------------------------------- 
 
查找：
顺序查找，也称为线形查找，从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，
若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

二分查找(要求数组是有序的)，要求线形表中的结点按关键字值升序或降序排列，用给定值k先与中间结点的关键字比较，
中间结点把线形表分成两个子表，若相等则查找成功；若不相等，
再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，
这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

分块查找(要求数组是块有序的)也称为索引查找，把线形分成若干块，在每一块中的数据元素的存储顺序是任意的，
但要求块与块之间须按关键字值的大小有序排列，还要建立一个按关键字值递增顺序排列的索引表，
索引表中的一项对应线形表中的一块，索引项包括两个内容：键域存放相应块的最大关键字
链域存放指向本块第一个结点的指针。分块查找分两步进行，先确定待查找的结点属于哪一块，然后在块内查找结点。

哈希表查找是通过对记录的关键字值进行运算，
直接求出结点的地址，是关键字到地址的直接转换方法，不用反复比较。
假设f包含n个结点，Ri为其中某个结点（1≤i≤n），keyi是其关键字值，在keyi与Ri的地址之间建立某种函数关系，
可以通过这个函数把关键字值转换成相应结点的地址，有：addr(Ri)=H(keyi)，addr(Ri)为哈希函数。

-----------------------------------------------------------------------------------------------------------

/**********************************************************************************************************
java相关

-----------------------------------------------------------------------------------------------------------
引用和对象

每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。――――《Java编程思想》

每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。
你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。
所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。
尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。  ――――《Java编程思想》

首先创建一个对象
Person person = new Person("熊熊烈火");

创建对象的语句是 new Person("熊熊烈火")，而Person person是一个指向该创建的新对象的 引用(强引用)！

同理
Person person;   //声明一个Person类的引用person
person = new Person("熊熊烈火");  //将引用person

这两行代码实现的功能和上面的一行代码是完全一样的。
在Java中new是用来在堆上创建对象用的，如果person是一个对象的话，那么第二行为何还要通过new来创建对象呢？
由此可见，person并不是所创建的对象，是什么？上面的一段话说的很清楚，“操纵的标识符实际是指向一个对象的引用”，
也就是说person是一个引用，是指向一个可以指向Person类的对象的引用。

Person person;
person = new Person("熊熊烈火");
person = new Person("熊熊烈火二号");
这里让person先指向了“熊熊烈火”这个对象，然后又指向了“熊熊烈火二号”这个对象。
也就是说，Person person，这句话只是声明了一个Person类的引用，它可以指向任何Person类的实例。

int a;
a=2;
a=3;
这里先声明了一个int类型的变量a，先对a赋值为2，后面又赋值为3.也就是说int类型的变量a，
可以让它的值为2，也可以为3，只要是合法的int类型的数值即可。

也就是说，一个引用可以指向多个对象，而一个对象可以被多个引用所指
比如：
Person person1 = new Person("熊熊烈火");
Person person2 = person1;
person1和person2都指向了“熊熊烈火”这个对象。

-----------------------------------------------------------------------------------------------------------

按值传递和按引用传递。(main方法中可以有 按值传递、按引用传递)
按值传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的一个副本。
因此，如果函数修改了该参数，仅改变副本，而原始值保持不变。

按引用传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的内存地址，而不是值的副本。
因此，如果函数修改了该参数，调用代码中的原始值也随之改变。

1.对象是按引用传递的
2.原始数据类型是按值传递的

“参数传递机制”，它是与赋值语句时的传递机制的不同。
Java 应用程序有且仅有的一种参数传递机制，即按值传递，当传参数给方法时，只是传递 原始值的副本

注意：
java只有值传递参数，当一个对象实例作为一个参数传递到方法中时，
参数的值是该对象的引用的一个副本，指向同一个对象，
所以对象中的内容可以改变(个人理解：可以调用该副本的方法，使得对象的某些状态被改变)
但是，对象的引用是不会改变的(个人理解：如果，对该副本进行重新赋值，出了这个方法就没用了)

-----------------------------------------------------------------------------------------------------------


Java垃圾回收
JVM是否回收一个对象的标准：是否还有引用变量引用该对象(个人理解，不管是强引用还是软、弱引用，只要没有引用就会被GC)，
只要有引用变量引用该对象，垃圾回收机制就不会回收它。
只要没有变量引用该对象，就会被GC。

Java中那些不可达的对象就会变成垃圾。对象之间的引用可以抽象成树形结构，通过树根（GC Roots）作为起点，从这些树根往下搜索，搜索走过的链称为引用链。
当一个对象到GC Roots没有任何引用链相连时，则证明这个对象为可回收的对象。


-----------------------------------------------------------------------------------------------------------

面向对象编程有三大特性：封装、继承、多态

封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。
对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。

继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。

多态有三个必要条件：继承、重写、向上转型。
继承：在多态中必须存在有继承关系的子类和父类。
重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。
(向上转型 就是声明一个父类的引用，new一个子类，再使父类的引用指向子类的对象
例如，A类是B类的父类，TestA a = new TestB();)


-----------------------------------------------------------------------------------------------------------











**********************************************************************************************************/



升级风险：
1.不要在必经路径上增加新的模块、功能，引起崩溃得不偿失
2.多个AIP版本的手机都要经过测试
3.良好的代码注释习惯

--------------------------------------------------------------------


















-----------------------------------------------------------------------------------------------------------
项目经验：
Emoji-Camera
基础数据结构，MoveBitmapInfo(中心坐标点，存放矩阵变量，位移，角度，缩放，emoji bitmap等信息)

绘制
1.在onDraw方法中，先绘制背景，接着将所有的 emoji和text绘制出来
2.canvas重载了很多绘制bitmap的方法，drawBitmap，可以将一个矩阵对象(Matrix)设置给这个方法，负责传递位移，旋转，缩放等信息
3.在onTouch中，会传递各种事件，ACTION_DOWN，ACTION_POINTER_DOWN，ACTION_MOVE，ACTION_POINTER_UP，ACTION_UP，
通过按下或者移动产生的坐标轴，来改变矩阵的位移，旋转，缩放信息，event.getPointerCount>1判断是否多手指操作，


1.位移，只能单指位移，在move事件中，会将当前手指触点的xy坐标传入，将触点坐标设置为表情的中心坐标就可以了

2.通过emoji红色功能图标，改变旋转角度，缩放。
缩放：中心坐标点不变，手指移动点改变，计算两点直接的距离，在除以原来的距离，得到缩放比例
旋转：中心坐标点不变，手指移动点改变，两点产生一直线，直线有斜率，通过新斜率和旧斜率的加减法运算得到角度
最困难的是有四个象限，两条坐标轴的上半轴和下半轴，
而返回的xy坐标不是以emoji中心为零点，而是以view的左上角点为零点
所以每一次都要以emoji中心为零点，分八种情况判断。通过三角函数公式来计算角度

3.多指操作，改变旋转角度，缩放。
缩放：先计算原两点距离，手指移动两点改变，计算新两点直接的距离，再次除以原来的距离，得到缩放比例
旋转：先计算原两点直线斜率，手指移动点改变，计算新两点直接的斜率，通过新斜率和旧斜率的加减法运算得到角度
夹角公式：tanθ=(k2- k1)/(1+ k1k2)，用原两点直线斜率和新两点直接的斜率得到旋转角度θ  (用atan取值)

4.数学相关知识，两个点移动，形成旧两点和新两点，构成两直线，两直线相交，会有2种夹角，通过顺时针还是逆时针方向，判断是哪一种夹角
如何判断顺时针还是逆时针，通过旧点和新点的坐标比较来判断。
和x轴平行的直线斜率为0

--------------------------------------------------------------------



android相关：

Android中造成内存泄漏的具体原因：
该被GC掉的东西没有被GC掉
1.读取数据库的Cursor，Map表，list忘记close
2.IO流没有关闭(InputStream,OutputStream)
3.Activity的context被静态类持有，例如被单例模式的对象持有
  当这个Activity比较占内存的情况下很致命
4.Bitmap对象，忘记recycle
5.广播接收者注册了之后 registerReceiver，忘记取消注册调用unregisterReceiver
  还有很多监听者需要在add之后cancel
6.handle泄漏：
	  (1).当一个Android应用启动的时候，会自动创建一个供应用主线程使用的Looper实例。
	Looper的主要工作就是一个一个处理消息队列中的消息对象。
	在Android中，所有Android框架的事件（比如Activity的生命周期方法调用和按钮点击等）都是放入到消息中，
	然后加入到Looper要处理的消息队列中，由Looper负责一条一条地进行处理。
	主线程中的Looper生命周期和当前应用一样长。
	  (2).当一个Handler在主线程进行了初始化之后，
	我们发送一个target为这个Handler的消息到Looper处理的消息队列时，
	实际上已经发送的消息已经包含了一个Handler实例的引用，
	只有这样Looper在处理到这条消息时才可以调用Handler#handleMessage(Message)完成消息的正确处理。
	  (3).在Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。静态的内部类不会持有外部类的引用。
	  (4).解决，定义静态的Handler，持有软引用的Activity。
	  
	  
--------------------------------------------------------------------
UI线程，负责渲染View，分发事件到响 应监听器并执行，对界面进行轮询的监听。
值得注意的是，普通View由UI线程后绘制
SurfaceView可以由后台线程来绘制，适合快速更新UI画面或UI画图需要较长时间



UI线程阻塞:
不能在UI线程中执行耗时操作，会阻塞UI线程，导致ANR异常。





疑问：当复制粘贴一大批Emoji时，为何会造成阻塞UI线程？原因？


	  
--------------------------------------------------------------------
  
Task (Activity任务堆栈)(A task is a stack of activities.) 
task是一个具有栈结构的容器，可以放置多个Activity实例
默认情况下，一个应用内的所有Activity都具有相同的affinity，
都是从Application继承而来，而Application默认的affinity是<manifest>中的包名，
我们可以为<application>设置taskAffinity属性值，这样可以应用到<application>下的所有<activity>，
也可以单独为某个Activity设置taskAffinity。
FLAG_ACTIVITY_NEW_TASK：当Intent对象包含这个标记时，系统会寻找或创建一个新的task来放置目标Activity，
寻找时依据目标Activity的taskAffinity属性进行匹配，如果找到一个task的taskAffinity与之相同，
就将目标Activity压入此task中，如果查找无果，则创建一个新的task。

启动一个应用，系统就会为之创建一个task，来放置根Activity；默认情况下，
一个Activity启动另一个Activity时，两个Activity是放置在同一个task中的，后者被压入前者所在的task栈，
当用户按下后退键，后者从task被弹出，前者又显示在幕前，特别是启动其他应用中的Activity时，两个Activity对用户来说就好像是属于同一个应用；
系统task和task之间是互相独立的，当我们运行一个应用时，按下Home键回到主屏，启动另一个应用，这个过程中，之前的task被转移到后台，
新的task被转移到前台，其根Activity也会显示到幕前，过了一会之后，在此按下Home键回到主屏，再选择之前的应用，
之前的task会被转移到前台，系统仍然保留着task内的所有Activity实例，而那个新的task会被转移到后台，如果这时用户再做后退等动作，
就是针对该task内部进行操作了。


--------------------------------------------------------------------

Activity和Fragment
Fragment有 getActivity()方法，Activity有 getFragmentManager()方法。

Fragment不能与Activity分开使用，Fragment必须在Activity中使用
尽管Fragment有着自己的生命周期，但是，当Activity销毁时，在Activity上，所有的Fragment也会并销毁

Fragment的子类必须实现一个无参数的构造方法，没有会崩溃
因为framework(系统)在回复状态期间会自动调用constructor(构造方法/构造器)来instantiate(实例化) 

Fragment生命周期
onAttach(Activity) 当一个Fragment associated(被关联)到一个activity时
onCreate(Bundle) 初始化
onCreateView(LayoutInflater, ViewGroup, Bundle) 初始化并返回和Fragment相关的view的hierarchy(层次)
onActivityCreated(Bundle) 告知Fragment，activity已经onCreate()完毕
onViewStateRestored(Bundle)告知Fragment，他的所有的保存状态的view被恢复
onStart() 使Fragment可见，依赖于包容Fragment的 Activity已经onstart
onResume() 使Fragment能和用户interact(互动)，同样依赖于Activity的onResume
onPause() 不再与用户互动，因为此时Activity处于onPause，或者Activity正在修改它
onStop()  不可见，因为此时Activity处于onStop，或者Activity正在修改它
onDestroyView() 允许Fragment清除和他associated (关联的)view
onDestroy() 销毁
onDetach() 不再与Activity关联


Activity 中的 onSaveInstanceState,用于Activity和Fragment保存和恢复数据
onSaveInstanceState() 只有在系统即将要自动清理销毁Activity或Fragment前才会调用, 比如 
1, 由于重力感应 手机从竖屏变为横屏, 
2, 手机点击Home键和长按Home键
3, 点击电源键锁屏时
4, 从当前Activity跳到另一个Activity
5, 应用内存不足即将自动销毁时等情况


Fragment (back Stack)回退栈
用法是，当前Fragment打算被替换成其他Fragment时，你把Fragment压入回退栈( 调用addToBackStack() )
点击返回按键时，旧Fragment会重新出现，也可以通过 popBackStack()（模拟用户发出的返回命令）将片段从返回栈中弹出
例如：
fragmentTransaction.replace(R.id.simple_fragment, newFragment);
fragmentTransaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
fragmentTransaction.addToBackStack(null); //把被替换的旧Fragment压入堆栈，null表示旧Fragment无名字
fragmentTransaction.commit();//记得commit



系统为你保存Fragment，Activity启动时，先创建Fragment，系统又把保存的Fragment给了Activity，
如此，导致存在2个Fragment,
Fragment.setRetainInstance(ture) 在onDetach脱离Activity,新Activity创建的时候返回给新Activity

Activity.onSaveInstanceState(),Activity.onRestoreInstanceState()用来保存回复数据，
临时性，不宜保存长久数据，应为onSaveInstanceState()和onRestoreInstanceState()的调用时机不定，
通常在 按下home键，横竖屏切换时调用

--------------------------------------------------------------------

其他三大组件

Service服务
1.可以在后台执行长时间运行操作而不提供用户界面的应用组件。
服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。
此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)
例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。

2.两种方式启动
启动 startService()
绑定 bindService() 

两种生命周期
onCreate()
onStartCommand()
onDestroy()

onCreate()
onBind()
onUnbind()
onDestroy()

3.
onStartCommand()
当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。
一旦执行此方法，服务即会启动并可在后台无限期运行。则在服务工作完成后，需要调用 stopSelf() 或 stopService() 来停止服务。
onBind()
当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。
在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。
务必实现此方法，但如果并不希望允许绑定，则应返回 null。

4.注册，在 Manifest中
<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>

5.顺序
Activity中创建 内部类并实现接口ServiceConnection，ServiceConnection的onServiceConnected方法将 参数IBinder service传入
Activity调用bindService (Intent service, ServiceConnection conn, int flags)
Service中创建IBinder service，并在onBind方法中返回
如此，Activity和Service都有IBinder，这样就可以通信了



ContentProvider内容提供者
1.多个应用程序之间共享数据，使用ContentProvider
ContentProvider为存储和获取数据提供了统一的接口。ContentProvide对数据进行封装，不用关心数据存储的细节。使用表的形式来组织数据。
Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。 

2.ContentProvider中实现query，insert，delete，update等方法对数据库进行 增删改查 SQLiteDatabase类

3.ContentResolver
当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，
可以使用ContentResolver类来完成，要获取ContentResolver对象，可以使用Context提供的getContentResolver()方法。
ContentResolver提供的方法和ContentProvider提供的方法对应的有以下几个方法。
public Uri insert(Uri uri, ContentValues values) 
public int delete(Uri uri, String selection, String[] selectionArgs)
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)

4.Uri
Uri指定了将要操作的ContentProvider，其实可以把一个Uri看作是一个网址，我们把Uri分为三部分。
第一部分是"content://"。可以看作是网址中的"http://"。
第二部分是主机名或authority，用于唯一标识这个ContentProvider，外部应用需要根据这个标识来找到它。可以看作是网址中的主机名，比如"blog.csdn.NET"。
第三部分是路径名，用来表示将要操作的数据。可以看作网址中细分的内容路径。

5.注册，在 Manifest中
<provider android:authorities="list"  //uri列名
          android:name="string"  //类名
    . . .
</provider>




BroadcastReceiver广播
1.在AndroidManifest文件、代码registerReceiver(用unregisterReceiver取消注册)中注册广播，

2.可以接受系统广播，也可以app自己发送广播，app自己介绍广播，
系统广播：CALL_ACTION(拨打电话),PACKAGE_ADDED_ACTION(新安装一个应用程序包),PACKAGE_REMOVED_ACTION(删除一个应用程序包)

3.Normal broadcasts（普通广播）：Normal broadcasts是完全异步的可以同一时间被所有的接收者接收到。
Ordered broadcasts（有序广播）：Ordered broadcasts的接收者按照一定的优先级进行消息的接收。
如：A,B,C的优先级依次降低，那么消息先传递给A，在传递给B，最后传递给C。

4.发送广播的方法：
sendBroadcast(intent)
sendOrderedBroadcast(intent2, null)

5.生命周期
onReceive
BroadcastReceiver的生命周期，从对象调用它开始，到onReceive方法执行完成之后结束。
另外，每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceive方法中执行完就销毁，
如果BroadcastReceiver的onReceiver方法中不能在10秒内执行完成，Android会出现ANR异常。
所以不要在BroadcastReceiver的onReceiver方法中执行耗时的操作。

如果需要在BroadcastReceiver中执行耗时的操作，可以通过Intent启动Service来完成。但不能绑定Service。

特别是，您可能无法从一个BroadcastReceiver中显示一个对话框，或绑定到服务。
对于前者，则应该使用NotificationManager的API。
对于后者，你可以使用Context.startService()来启动一个Service。








