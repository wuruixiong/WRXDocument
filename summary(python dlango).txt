

使用 pycharm开发 python web， 现在有虚拟机，所以不用安装dlango，只需直接创建项目再运行即可。
个人理解，想要使用安装过的dlango开发也可，但需要制定路径，

python3.6 默认安装了pip3，可以使用pip3直接安装 dlango框架

------------------------------------------------------------------------

dlango 整体框架：

服务器对url进行解析后, 调用View中的逻辑(MTV中的V), 其中又涉及到Model(MTV中的M), 与数据库的进行交互, 将数据发到Template(MTV中的T)进行渲染, 然后发送到浏览器中, 浏览器以合适的方式呈现给用户。

MTV：
Django的MTV模式本质上与MVC模式没有什么差别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同，Django的MTV分别代表：
Model(模型)：负责业务对象与数据库的对象(ORM)
Template(模版)：负责如何把页面展示给用户
View(视图)：负责业务逻辑，并在适当的时候调用Model和Template
  区别于MCV，View代替了Controller的功能，Template代替了原本的 View的功能。
  此外，Django还有一个url分发器，它的作用是将一个个URL的页面请求分发给不同的view处理，view再调用相应的Model和Template


MCV:把web应用分为模型(Model),控制器(Controller),视图(View)三层；他们之间以一种插件似的，松耦合的方式连接在一起。
模型负责业务对象与数据库的对象(ORM),视图负责与用户的交互(页面)，控制器(C)接受用户的输入调用模型和视图完成用户的请求。


------------------------------------------------------------------------

官方教程mysite：

第一步，第一阶段：

使用PyCharm直接创建Django项目，或者命令创建项目(需要安装django)： django-admin startproject mysite

创建完成后，看到以下结构：
mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        wsgi.py

翻译官方的资料：
外部mysite/根目录 只是您的项目的容器。它的名字与Django无关;你可以将它重命名为任何你喜欢的东西。

manage.py：一个命令行工具，可让您以各种方式与此Django项目进行交互。你可以在django-admin和manage.py中阅读关于manage.py的所有细节。

内部mysite/目录 是实际Python包。如果其他python文件 要import 到 mysite 下一些代码，就需要加上mysite这个包名。例如：from mysite import urls

mysite / __ init__.py：一个空文件，告诉Python这个目录应该被视为一个Python包。如果您是Python初学者，请阅读官方Python文档中有关软件包的更多信息。

mysite / settings.py：这个Django项目的设置/配置。 Django settings 会告诉你有关设置如何工作的所有信息。

mysite / urls.py：这个Django项目的URL声明;您的Django支持的网站的“目录”。您可以在URL调度器中阅读更多关于URL的内容。

mysite / wsgi.py：WSGI兼容的Web服务器为您的项目提供服务的入口点。有关更多详细信息，请参阅如何使用WSGI进行部署。

这样就可以执行一下这个服务器程序了，在系统的命令行，或者pycharm的命令行，或者pycharm直接按下run图标。
命令行：python manage.py runserver

有这么一段输出：Starting development server at http://127.0.0.1:8000/。浏览器访问一下本机的127.0.0.1:8000/。
会看到一个“恭喜！”页面，火箭起飞。

这里暂时无需配置服务器，Django自带 开发和调试用的服务器，但是当项目准备要正式上线时，就需要配置服务器，例如Apache。

还可以在其他端口跑这个服务器程序：python manage.py runserver 8080




第一步，第二阶段：
环境搭建好， 一个“项目”已经建立起来了，在Django中编写的每个app(application)都包含遵循特定约定的Python包。 
Django自带有一个实用程序，可以自动生成app(application)的基本目录结构。

创建一个名为Polls的app：
在manage.py同级的目录下执行命令行：python manage.py startapp polls
目前pycharm只有在创建项目时才能加入app，如果在项目中创建，只能用命令行。

创建之后看到一个polls目录，有以下结构：
polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py

打开polls/views.py，添加代码：
from django.http import HttpResponse
def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")

这是Django中最简单的视图。 要调用视图，我们需要将它映射到一个URL - 为此我们需要一个URLconf。
要在polls目录中创建一个URLconf。

创建polls/urls.py，添加代码：
from django.urls import path
from . import views
urlpatterns = [
    path('', views.index, name='index'),
]

下一步是将根URLconf指向polls.urls模块。
在mysite/urls.py中，为django.urls.include添加一个导入，并在urlpatterns列表中插入一个include（）:
from django.contrib import admin
from django.urls import include, path
urlpatterns = [
    path('polls/', include('polls.urls')),
    path('admin/', admin.site.urls),
]

include（）函数允许引用其他URLconf。 每当Django遇到include（）时，它会截断与该点匹配的URL的任何部分，并将剩余的字符串发送到包含的URLconf以供进一步处理。
include（）背后的想法是使插入和播放URL变得容易。 由于民意调查(polls)是在他们自己的URLconf（polls / urls.py）中，它们可以放在“/ polls /”下，或者放在“/ fun_polls /”下，或者放在“/ content / polls /”或任何其他路径根下， 该应用程序仍然可以工作。

接着run一下，可以访问polls下的index: http://127.0.0.1:8000/polls/

--------------------------

第二步：
设置数据库，创建第一个模型(model)，并快速介绍Django自动生成的管理站点。

第一阶段，Database(数据库)的设置：
打开mysite / settings.py。 这里可以配置SQLite。SQLite包含在Python中，当项目上线时，应当使用像PostgreSQL这样的更具可扩展性的数据库。
(顺便编辑一下时区：settings.py/TIME_ZONE)

查看INSTALLED_APPS设置。它包含在此Django实例中激活的所有Django application的名称。 
App可以用于多个项目，可以打包并分发这些应用程序以供他人在其项目中使用。

默认情况下，INSTALLED_APPS包含以下应用程序，所有应用程序都附带Django：
django.contrib.admin - 管理网站。 你会很快使用它。
django.contrib.auth - 一个认证系统。
django.contrib.contenttypes - 内容类型的框架。
django.contrib.sessions - 会话框架。
django.contrib.messages - 一个消息框架。
django.contrib.staticfiles - 管理静态文件的框架。

其中一些应用程序至少使用了一个数据库表，所以我们需要在数据库中创建表格，然后才能使用它们。 
运行命令：  
python manage.py migrate

migrate命令查看INSTALLED_APPS设置，并根据 mysite/settings.py 文件中的数据库设置以及 polls下的 migrations (数据库迁移) 创建任何必需的数据库表。 
您会看到每条适用的迁移消息。 如果您有兴趣，请为您的数据库运行命令行客户端并键入
\ dt（PostgreSQL），SHOW TABLES; （MySQL），.schema（SQLite）
或 SELECT TABLE_NAME FROM USER_TABLES; （Oracle）来显示Django创建的表。

默认应用程序包含在常见的情况下，但不是每个人都需要它们。 如果您不需要其中的任何或全部，
请在运行migrate 之前 注释或删除 INSTALLED_APPS中的相应行。 migrate命令将仅在INSTALLED_APPS中运行应用程序的migrations。

运行之后可以看到创建了一个db.sqlite3数据库。


第二阶段，创建模型：models
在我们简单的民意调查应用程序(polls app)中，我们将创建两个模型：问题和选择。
一个问题有一个问题和一个出版日期。 选择有两个领域：选择的文本和一个票数。 每个选项都与一个问题相关联。

polls/models.py:
from django.db import models
class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')
class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

每个模型都由代表django.db.models.Model的子类表示。每个模型都有许多类变量，每个变量表示模型中的数据库字段。(类的定义中，加一个括号再加类表示父类)
每个字段由一个Field类的实例表示 - 例如，字符字段的CharField和日期时间的DateTimeField。这告诉Django每个字段拥有什么类型的数据。
每个Field实例的名称（例如question_text或pub_date）是机器友好格式的字段名称。您将在您的Python代码中使用此值，并且您的数据库将使用它作为列名称。
某些Field类需要参数。例如，CharField要求你给它一个max_length。这不仅在数据库模式中使用，而且在验证中使用，我们很快就会看到。
一个Field也可以有各种可选的参数;在这种情况下，我们已将投票的默认值设置为0。
最后，请注意使用ForeignKey定义的关系。这告诉Django每个Choice都与单个问题有关。 Django支持所有常见的数据库关系：多对一，多对多和一对一。



第三阶段，激活模型：
上边的模型代码为Django提供了大量信息。
有了它，Django能够：
为此应用程序创建数据库模式（CREATE TABLE语句）。
创建一个用于访问Question和Choice对象的Python数据库访问API。

但首先我们需要告诉我们的项目，民意调查应用程序已安装。
要将该应用程序包含在我们的项目中，我们需要在INSTALLED_APPS设置中添加对其配置类的引用。 
PollsConfig类位于polls / apps.py文件中，因此其虚线路径为'polls.apps.PollsConfig'。 
编辑mysite / settings.py文件并将该虚线路径添加到INSTALLED_APPS设置。
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

再跑一下命令：
python manage.py makemigrations polls
会看到终端的输出：
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Choice
    - Create model Question
    - Add field question to choice

这段命名是告诉 Django 修改了models(这里是创建)，并被存储为一个 migration
Migrations是Django存储对模型(以及数据库模式)的更改——它们只是磁盘上的文件。
如果您愿意，您可以阅读您的新模型的迁移; polls/migrations/0001_initial.py.

运行命令，自动管理数据库，sqlmigrate命令接受迁移名称并返回其SQL:
python manage.py sqlmigrate polls 0001

可能会看到终端的以下输出：
BEGIN;
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" serial NOT NULL PRIMARY KEY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL
);
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" serial NOT NULL PRIMARY KEY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Add field question to choice
--
ALTER TABLE "polls_choice" ADD COLUMN "question_id" integer NOT NULL;
ALTER TABLE "polls_choice" ALTER COLUMN "question_id" DROP DEFAULT;
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
COMMIT;

不同的输出取决于使用的数据库的不同，上面的示例是为PostgreSQL生成的。
将app的名称和model的小写名称- question 和 choice 相结合，自动生成表名。(您可以重写此行为。)
Primary keys 主键(IDs)被自动添加。(你也可以重写这个。)
按照惯例，Django将“_id”附加到  foreign key field 外键字段名。(是的，你也可以重写这个。)
外键关系由 外键约束显式FOREIGN KEY constraint 显示。不要担心可延迟的部分;这只是告诉PostgreSQL在事务结束之前不强制执行外键。
它适合于您正在使用的数据库，因此特定于数据库的字段类型(如auto_increment (MySQL)、串行(PostgreSQL)或整数主键自动增量(SQLite)将自动为您处理。
引用字段名也一样——例如，使用双引号或单引号。
sqlmigrate命令实际上并没有在您的数据库上运行迁移——它只是将它打印到屏幕上，以便您可以看到SQL Django认为是必需的。
它有助于检查Django将要做什么，或者是否有数据库管理员需要SQL脚本进行更改。

如果您感兴趣，也可以运行python manage.py check ;这将检查项目中的任何问题，而不需要进行迁移或修改数据库。

所以，再次运行migrate, 在数据库中创建这些模型表:  python manage.py migrate
migrate命令将所有尚未应用的迁移(Django跟踪应用程序在数据库中使用名为django_migrations的特殊表)，并在数据库上运行它们
说白了，本质上是 对模型的更改与数据库中的模式同步。

迁移非常强大，随着时间的推移，您可以更改您的模型，当您开发项目时，无需删除数据库或表，
并生成新的数据库——它专门用于升级数据库，而不会丢失数据。
记住进行模型更改的三个步骤:
1. 在models.py中创建 新的models
2. python manage.py makemigrations [app name] 为这些更改创建迁移。
3. python manage.py migrate 将这些更改应用到数据库。



第三阶段，使用API：

命令行 进入Django 的shell下：
python manage.py shell

>>> from polls.models import Choice, Question  

#打印所有的对象
>>> Question.objects.all()
<QuerySet []>

>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())
>>> q.save()

#可以查看打印信息
>>> q.id
1
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)

#修改信息
>>> q.question_text = "What's up?"
>>> q.save()

#打印所有的对象
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>


polls/models.py，将一个__str__()方法添加到问题和选择中:
from django.db import models
class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text
class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text

导入datetime和django的添加一个方法：
import datetime
from django.db import models
from django.utils import timezone
class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)

再次进入shell： python manage.py shell：
>>> from polls.models import Choice, Question
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith='What')
<QuerySet [<Question: What's up?>]>

>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

>>> Question.objects.get(pk=1)
<Question: What's up?>

>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

>>> q = Question.objects.get(pk=1)

>>> q.choice_set.all()
<QuerySet []>

>>> q.choice_set.create(choice_text='Not much', votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text='The sky', votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)

>>> c.question
<Question: What's up?>

>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()


第四阶段，Django管理：
Django完全自动化了模型管理界面的创建。
Django是在新闻编辑室环境中编写的，在“内容发布者”和“公共”站点之间有着非常清晰的分离。
网站管理员使用该系统添加新闻故事、事件、体育比赛成绩等等，这些内容会在公共站点上显示。Django解决了为站点管理员创建一个统一的界面来编辑内容的问题。

创建管理者用户：
python manage.py createsuperuser

接着需要输入用户名，邮件，密码等等：
Username: admin
Email address: admin@example.com
Password: **********
Password (again): *********
Superuser created successfully.


Run 服务器，其实可以不用执行：
python manage.py runserver

访问， http://127.0.0.1:8000/admin/ ，进入登录界面。
会看到在 authentication and authorization这一栏下有两个选项： Groups群管理 Users用户管理

polls/admin.py 添加代码，将之前创建的问题管理给用户：
from django.contrib import admin
from .models import Question
admin.site.register(Question)

接着会看到在polls这一栏下有一个 Question的选项, 点击进入。

注意事项:
表单是由问题模型自动生成的。
不同的模型字段类型(DateTimeField, CharField)对应于适当的HTML输入小部件。每种类型的字段都知道如何在Django管理中显示自己。
每个DateTimeField都获得了免费的JavaScript快捷方式。日期得到一个“今天”的快捷方式和日历弹出，并且时间得到一个“现在”的快捷方式和一个方便的弹出列表通常进入的时间。
页面的底部提供了几个选项:
保存-保存更改，并返回到该类型对象的变更列表页面。
保存并继续编辑-保存更改并重新加载该对象的管理页面。
保存并添加另一个-保存更改，并为这类对象加载一个新的空白表单。
删除-显示删除确认页。
如果“发布日期”的值与您在教程1中创建问题时的时间不匹配，这可能意味着您忘记为TIME_ZONE设置设置正确的值。更改它，重新加载页面并检查是否出现了正确的值。












--------------------------

其他细节：

（1）
wsgi：Web Server Gateway Interface。略有了解：python已经实现了接受HTTP请求、解析HTTP请求、发送HTTP响应这些底层，wsgi就是提供接口的。
WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。例如：
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'<h1>Hello, web!</h1>']
上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：
environ：一个包含所有HTTP请求信息的dict对象
start_response：一个发送HTTP响应的函数。

这样，只需要关系怎么响应http请求，不需要去管理底层的 http和tcp通讯。

（2）
项目(Project)与应用程序(app即application)
项目和应用程序有什么区别？ 应用程序是一种Web应用程序，它可以执行某些操作，例如Weblog系统，公共记录数据库或简单的民意调查应用程序。 
项目是特定网站的配置和应用程序的集合。 项目可以包含多个应用程序。 一个应用程序可以在多个项目中。

（3）
更换数据库：
如果希望使用其他数据库，请安装适当的数据库绑定，并在DATABASES的“默认”项中更改以下键以匹配数据库连接设置：
ENGINE - “django.db.backends.sqlite3”，“django.db.backends.postgresql”，“django.db.backends.mysql”或“django.db.backends.oracle”。 
其他后端也可用。
NAME - 数据库的名称。 如果您使用SQLite，数据库将成为您计算机上的文件; 在这种情况下，NAME应该是该文件的完整绝对路径，包括文件名。 
缺省值os.path.join（BASE_DIR，'db.sqlite3'）将把文件存储在你的项目目录中。
如果您不使用SQLite作为数据库，则必须添加其他设置，例如USER，PASSWORD和HOST。 

对于SQLite以外的数据库
如果使用SQLite之外的数据库，请确保你已经创建了一个数据库。 在数据库的交互式提示中使用“CREATE DATABASE database_name;”做到这一点。
还要确保mysite / settings.py中提供的数据库用户具有“创建数据库”权限。 这允许自动创建测试数据库，这将在稍后的教程中需要。
如果您使用的是SQLite，则无需事先创建任何内容 - 数据库文件将在需要时自动创建。

（4）
migration，数据库迁移，

（5）
filter 数据过滤：
很少会一次性从数据库中取出所有的数据；通常都只针对一部分数据进行操作。
在Django API中，我们可以使用`` filter()`` 方法对数据进行过滤：
>>> Publisher.objects.filter(name='Apress')
[<Publisher: Apress>]

filter() 根据关键字参数来转换成 WHERE SQL语句。 前面这个例子 相当于这样：
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';

可以传递多个参数到 filter() 来缩小选取范围：
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress>]

多个参数会被转换成 AND SQL从句， 因此上面的代码可以转化成这样：
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE country = 'U.S.A.'
AND state_province = 'CA';

SQL缺省的 = 操作符是精确匹配的， 其他类型的查找也可以使用：
>>> Publisher.objects.filter(name__contains="press")
[<Publisher: Apress>]
在 name 和 contains 之间有双下划线。和Python一样，Django也使用双下划线来表明会进行一些魔术般的操作。
这里，contains部分会被Django翻译成LIKE语句：
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name LIKE '%press%';

（6）


------------------------------------------------------------------------

表1：商品分类
分类ID（主键）	分类名称
1		鞋子
2		衣服
3		裤子

表2：商品
商品ID（主键	商品名称  商品简介  商品分类（外键）  分类ID（外键）
1		短袖	无	 衣服		2
2		牛仔裤	无	 裤子		3
3		跑鞋	无	 鞋子		1
4		外套	无	 衣服		2



表3：用户
用户id（主键）	用户名
1		A
2		B
3		C


表4：对话列表
id		对话内容		发送方

















