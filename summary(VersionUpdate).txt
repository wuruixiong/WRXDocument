

在版本更新时，有两种更新方式，
一是由安卓市场进行更新，此种方法不多做介绍
二是内置版本更新，逻辑是：由应用内部检查当前版本和后端拿到的更新版本对比，如果版本落后即更新

介绍内置版本更新：
内置的版本更新也分为两种方式更新，以下这两种更新方式，可以同时存在，
注意的是，更新状态是由后端控制的
一, 强制更新，不提醒用户，当用户打开app时，自动下载后端服务器上的apk，并自动安装。
二, 推荐更新，弹出对话框，提醒用户更新，当用户同意更新时，下载后端服务器上的apk，下载完成后自动安装
三, 详细逻辑：
(1).用户打开app时，从后端服务器拿到准备更新的versionCode，对比当前app内的versionCode
(2).接着判断强制更新还是推荐更新（如果软件设计只打算用其中一种，不用判断）
(3.1).如果是强制更新，判断目标文件夹中是否有符合 文件名条件的apk，
      再次对比apk的版本和当前版本，如果符合条件即安装，
      没有则开启线程去下载apk，下载到目标文件夹，下载完成之后，拿到文件夹中符合 文件名的apk，
      再次对比apk的版本和当前版本，如果符合条件即安装，
      此时，如果调出安装页面，用户还可以选择不安装，
      那么，下次进入app时，参照之前的做法，判断目标文件夹中是否有符合 文件名条件的apk。
(3.2).如果是推荐更新，
      如果用户点击不跟新，那么不再显示更新提醒对话框，
      注意，此时应该用本地磁盘缓存记录下用户的选择；
      如果用户点击了更新，逻辑和3.1相同，
      判断目标文件夹中是否有符合 文件名条件的apk，
      再次对比apk的版本和当前版本，如果符合条件即安装，
      没有则开启线程去下载apk，下载到目标文件夹，下载完成之后，拿到文件夹中符合 文件名的apk，
      再次对比apk的版本和当前版本，如果符合条件即安装，
      此时，如果调出安装页面，用户还可以选择不安装，
      那么，下次进入app时，参照之前的做法，判断目标文件夹中是否有符合 文件名条件的apk。

Android中有两种关于版本的信息，versionName，versionCode
versionName是给用户看的（例如：”1.0.2”），在代码中并不没有多大意义，因为只是字符串，不推荐作为进行版本更新的标志
versionCode是一个整形数字（例如：”102”），可作为内置版本更新时的更新参照标识
注意：为了避免versionName和versionCode不同步，这里推荐这么设置：如果versionName是1.0.0，那么可以把versionCode设置为100；如果versionName是2.2.8，可以把versionCode设置为228。


