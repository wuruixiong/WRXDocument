public
protected
private
abstract
static
final
transient
volatile
synchronized
native
strictfp


int	4个字节 
char	2个字节
byte	1个字节,字节英文就是byte,1B=8位/8比特/8bit
short	2个字节
long	8个字节
float	4个字节
double	8个字节
关于boolean占几个字节，众说纷纭，虽然boolean表现出非0即1的“位”特性，但是存储空间的基本计量单位是字节，不是位。所以boolean至少占一个字节。 
JVM规范中，boolean变量作为int处理，也就是4字节；boolean数组当做byte数组处理。

String，一个英文字符占1个字节。中文字符根据编码，UTF-8编码：中文字符3个字节；GBK编码：中文字符占2个字节。


两位16进制的数就是一个字节（8位）组成。
一个字节8位，就是2的8次方，两位16进制也是2的8次方。1位16进制数是0到F，同等于4位2进制数0000到1111
两位16进制数从00开始(最小值)到FF为止(最大值)，同等于8位2进制数00000000到11111111


内存分配基础
Java把内存分成两种，一种叫做栈内存，一种叫做堆内存
在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。
堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。
从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的: 




黄金比例：(√5-1)/2  约等于 0.618， 约等于6:10，约等于5:8

冲印尺寸(英寸)    	文件体积(约) 	要求最低分辨率   	相片对应尺寸
(1寸 / 2寸)      	150-200KB     	640x480(30万)    	2.5 × 3.5 cm  / 5.3 × 3.5cm 
(5×3.5英寸)3R    	500-550KB    	1280x960(120万)   	12.70×8.89  cm
(6×4英寸)  4R    	600-650KB    	1280x1024(130万)  	15.24×10.16 cm
(7×5英寸)  5R    	800-900KB    	1600x1200(200万)  	17.78×12.70 cm
(8×6英寸)  6R    	1-1.2MB      	1900x1280(240万)  	20.32×15.24 cm
(10×8英寸) 8R-8F 	1.3-1.5MB    	2048x1536(300万)  	25.40×20.32 cm

注：一般默认一个像素3字节(RGB颜色模式)，即3B



访问控制符(access specifier):public private protected



------------------------------------------------------------

InputStream指的是在数据流中的数据读入到指定object是为Input，通常使用InputStream.read
OutputStream指的是将数据输出到OutputStream中，是为Output，通常使用OutputStream.write
------------------------------------------------------------

float浮点类型，只有在数值后面加f就是浮点数值，例如0.5f

Integer.MAX_VALUE
整型最大值

long是长整型，也就是说拿两个long去做除法，拿到的不会是浮点型
------------------------------------------------------------

java三目运算：
a ? b:c
a为真返回b，为假返回c
------------------------------------------------------------

new A() 是为匿名对象

一个方法在 方法体内调用自身 是为 递归调用

------------------------------------------------------------

相等判断

Java中判断两个变量是否相等有两种方式：
1. ==
2. equals

如果变量是基本类型，那么使用==和使用equals会得到相同的结果，都是判断变量的值是否相对。

如果变量是引用类型，==运算符判断变量是否指向同一引用对象，equals判断变量"值"是否相等。

对象也可以利用==运算符进行值判断，只有当Java值类型对应的包装类（Boolean、Byte、Short、Integer、Long、Float、Double、Charcater）

------------------------------------------------------------

Java的注解和反射原理 以及 JNI

------------------------------------------------------------

1，**重点内容**sqrt是开方： 
比如math.sqrt(9)结果为3 意思是求9的开方根，数学上称为根号2下的9 
2.**重点内容**pow（a,b） 
Math.pow(27, 3)意思是求27的三次方 就是27*27*27的意思 
重点内容假如你想求开三次方，或者四次方 可以借助pow方法 
例如：Math.pow(27, 1/3) 
结果为3 就是对27的1/3次方 就是根号3下的27

------------------------------------------------------------

三角函数公式使用，Math.PI为圆周率，1度为π/180弧度
Math.sin((30) * Math.PI / 180) = 0.49999999 //sin30度，约等于0.5
Math.sin(30) 是指sin30弧度
Math.asin(0.49999999)可以得到反sin的数值：0.52359877(这就是30度的值：30*Math.PI/180 == 0.52359877)
Math.asin(0.49999999)*180/Math.PI = 30   //也可以使用toDegrees()来得到角度，toDegrees()也是使用了 数值乘以180再除以圆周率的计算公式的
------------------------------------------------------------
java整型的与、或、非、异或运算：
计算之前将10进制转为2进制，对每位进行运算
例如：1与2就是2进制的：1与10结果为0
129-->10000001
128-->10000000
128|129 -->10000001 结果129
异或就是相同为真不相同为假，1和1、0和0异或都为真
------------------------------------------------------------
继承的父类的子类可以重写public，protected方法，必须是只有public，protected修饰符的方法，
如果方法加了static，final等修饰符不可被重写

------------------------------------------------------------
整型没初始化值为0
字符串没有初始化值为null, 因为 字符串 String 是一个类
即：
    String mText;//值为0
    int mInt;	 //值为null
------------------------------------------------------------

针对二进制和字节的运算，位运算：&  |  ~  ^  >>  <<  >>>

整型是4个字节32位，8就是000...0001000（1000前面还有28个0），9就是000...0001001（1001前面还有28个0）

& 与运算符，当且仅当两个对应的位置都是1，结果才是1，否则结果为0
8&9  1000&1001  结果1000 即 8

| 或运算符，当且仅当两个对应的位置都是0，结果才是0，否则结果是1，
那么8|9就是1000|1001 即1001 即9

~ 非运算符，取反

^ 异或运算符

<< 左侧位移，表示这个数乘以2的n次方， 符号位不变，低位补0，溢出截断

>> 右侧位移，表示除以这个数的n次方，低位溢出，符号位不变，并用符号位补溢出的高位。

<<< 无符号右移运算符。低位溢出，高位补0






------------------------------------------------------------
字符串操作：
StringClip.isEmpty();  // 判断为空
StringClip.length() ; //长度
StringClip.equals(new String); //比较是否相等

字符串和char数组互转
String str = "ggg";
char[] bm;
bm = str.toCharArray();
str = String.valueOf(bm);


浮点除法运算，加(float)强转是关键
float wratio = (float)mViewWidth / mBackgroundBitmap.getWidth();
int转float
Math.round(mBackgroundBitmap.getHeight() * wratio))


对数运算，
n=loga(b), 其中，a叫做“底数”，b叫做“真数”，n叫做“以a为底的b的对数”。
零和负数没有对数。当不写底数时，一般默认以10为底数

java的Math.log运算是以自然数e为底数
(常数e为底数的对数叫做自然对数)
(自然常数e,约为2.71828)

例如 进行以2为底(base)的对数运算，可以这么写
logb(n)=loge(n)/loge(b)  (换底公式)
Math.log(8)/Math.log(2)=3.0


//Double转int
Double d = 10d;
int mBorderRadius = d.intValue();


实例化数组： String res_randomstr[?];//问号是表示创建几个元素，
	    res_randomstr=new String[10];//例如：下标为res_randomstr[0]到res_randomstr[9]共10个
		
数组定义： 1.private String[] text = {"t", "t", "t"}; //可以在类之内方法之外如此定义，数组text会有3个元素   

		   2.private String[] text;			     //此时text数组为空
		     text = new String[]{"t", "t", "t"}; //在方法之内 实例化, text数组有三个元素  
			 
		   3.private String[] text;	// 定义数组text, 此时text数组为空
		     text = new String[2];  //也可以在方法之内实例化, text数组有三个元素, 但是三个元素都为空 
			 text[0] = "t"			// 对第一个元素赋值


数组长度：int grid_id[][];
	grid_id.length//有几个数据就有几个,即第一维的长度
二维数组元素长度:   grid_id[].length
输出2维数组所有数据：     
           for(int i=0;i<grid_id.length;i++)
                {
                    for(int j=0;j<grid_id[i].length;j++) {
                        Log.v(String.valueOf(grid_id[i][j]),String.valueOf(grid_id[i][j]));
                    }
                }
				
------------------------------------------------------------------------------
在线程的使用过程中，要特别注意线程同步的问题，
例如：在线程中遍历列表list，如果其他线程对列表list进行 删除操作，则可能出现 下标溢出、空指针等错误
方法1：如果列表list在主线程创建，则在主线程中复制多个列表list，再作为参数赋给各个线程

方法2：使用线程同步synchronized锁住list，在使用到list的地方都将list使用synchronized锁住

方法3：使用线程同步synchronized锁住方法，封装list，将list用另外的类A 封装，在该类A的实例化对象中对list操作，
	   其他线程通过操作类A的实例化对象来对list操作， 在类A中的操作list的方法method前加入synchronized，将操作list的方法锁住，
	   可以防止多个线程同时操作该方法，这样也就是对list操作实现了线程同步






	   
------------------------------------------------------------------------------

实例化表： ArrayList list;
list=new ArrayList();
增加操作：add（n）；从0开始加入
删除操作：remove（n）
取出操作：get（n）；从0开始取出例如：get（0），get（1），get（2）
计算长度：list.size();有几个数据就有几个，如果add3次，list.size（）就是3
表中的元素转换int类型：Integer.valueOf(String.valueOf(list.get(n))).intValue();
表中的元素转换String类型：String.valueOf(list.get(n));
	   

生成随机数： Random r = new Random();
	     r.nextInt(9);//生成从0到8
	   r.nextInt(n);//生成从0到n-1
	   

创建线程：  
  private class Mythread extends Thread
    {
        int scount;
        int slevel;
//构造方法
        private Mythread(int count,int level)
        {
           scount=count;
            slevel=level;
        }
//重写run方法
        @Override
        public void run(){
            
        }
    }

最后：Mythread实例化之后.start

创建线程2
       //实例化借口
　　class MutliThread implements Runnable{
      @Override
　　public void run(){}
　　}
      MutliThread m3=new MutliThread();
      Thread t1=new Thread(m1);
      t1.start；
	   

Math.max(13,90)//返回90
Math.min(13,90)//返回13
	   

return 跳出有返回值的方法       
        return ;//可以退出void方法
break 跳出当前循环，如果在switch中，碰到break，会退出switch
	   
	   
JSON的2种格式：
1、对象：对象在js中表示为“{}”括起来的内容，数据结构为 {key：value,key：value,...}的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。
2、数组：数组在js中是中括号“[]”括起来的内容，数据结构为 ["java","javascript","vb",...]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。
	 表示数组的格式需要注意：一般情况下都是这么表示数组的：
	 {"sites":[ "Google", "Runoob", "Taobao" ]}   在中括号之前再加一个键对值再用大括号包裹

JSON解析
封装并存储成文件：
            JSONObject object = new JSONObject();
            try {
                object.put("Common1", "#ffffffff");
                object.put("Common2", "#ffffffff");
                object.put("Common3", "#ffffffff");
                object.put("Common4", "#ffffffff");
                object.put("Common5", "#ffffffff");
                object.put("Common6", "#ffffffff");
                object.put("Common7", "#ffffffff");
                object.put("Common8", "#ffffffff");
                object.put("Common9", "#ffffffff");
                object.put("Common10", "#ffffffff");
            } catch (JSONException e) {
                e.printStackTrace();
            }

            try {
                OutputStream os = context.openFileOutput(FileName, Activity.MODE_PRIVATE);
                os.write(object.toString().getBytes());
                os.close();
                Log.w(FileName+" is create",FileName+" is create");
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

读取JSON文件
            try {
                FileInputStream fis =context.openFileInput(FileName);
                byte[] buff=new byte[1024];
                int hasRead=0;
                StringBuilder sd=new StringBuilder("");
                while ((hasRead=fis.read(buff))>0)
                {
                    sd.append(new String(buff,0,hasRead));
                }
                fis.close();
//                Log.w("JSON",sd.toString());
                return sd.toString();
            }
            catch (Exception e)
            {
            }

将上面的返回值（字符串型）转成JSONTokener ，使用JSONObject 查找数据，sd.toString()就是JSON的数据格式
        try {
            JSONTokener jsonTokener = new JSONTokener(sd.toString());
            JSONObject jsonObject = (JSONObject) jsonTokener.nextValue();
            jsonObject.getString("Common"+CommonNumber);
        } catch (JSONException ex) {
        }
		
		
JSON数组封装：
JSONObject person = new JSONObject();  
JSONArray phone = new JSONArray();  
phone.put("12345678").put("87654321");  
person.put("phone", phone); 

JSON数组读取：
String t={"initial":"R","name":"reiz","likes":["JavaScript","Skiing","Apple Pie"]}
JSONObject.fromObject(t)
JSONArray likes=jo.getJSONArray("likes"); //得到likes数组
like.getString(2);                        //得到likes数组第三个
	   
	   
反射机制：
方法无参数：
	获取方法：
	Class iInputMethodWrapper = service.getClass();
	try {
		Method getInternalInputMethod = iInputMethodWrapper.getMethod("getInternalInputMethod",null);
	} catch (Exception e) {
		e.printStackTrace();
	}
	
	 执行方法：
	 getInternalInputMethod.invoke("iInputMethodWrapper",null)
	   

	   
"abc|asd|amsd".split("|")
输出结果是String[6]{"","adc","|","asd","|","amsd"}
"abc|asd|amsd".split("\\|")
输出结果是String[3]{"adc","asd","amsd"}
如果使用split，发现输出结果有问题，尝试加入转义符:\\
	   
	   


// 定义 三种 TYPE，
@IntDef({DATA_TYPE_1, DATA_TYPE_2, DATA_TYPE_3})
@Retention(RetentionPolicy.SOURCE)
public @interface Type {}

public static final int DATA_TYPE_1 = 1;
public static final int DATA_TYPE_2 = 2;
public static final int DATA_TYPE_3 = 3;

// 在调用 setType()时，会有提示输入参数可以是 DATA_TYPE_1, DATA_TYPE_2, DATA_TYPE_3
public setType(@Type int type) {
	int i = type;
}
	   
	   


// 使用 迭代器Iterator，进行 列表list的循环中的删除元素操作
List<String> names = ....
Iterator<String> i = names.iterator();
while (i.hasNext()) {
   String s = i.next(); // must be called before you can call i.remove()
   // Do something
   i.remove();
}	   


// 表情code 转为字符串: Integer.toHexString(Character.codePointAt("\uD83D\uDE01", 0)) == 1f601
String code = "\uD83D\uDE00";
String output = "\"";
for (char c : code.toCharArray()) {
	output = output + "\\u" + Integer.toHexString(c);
}
output = output + "\"";

Character.codePointAt("\uD83D\uDE01", 0)  ==  128513
Integer.toHexString(128513)  ==  1f601
Unicode:U+1F601

// 字符串 转为 表情code: String.valueOf(Character.toChars(Long.parseLong("1f601", 16))) == \uD83D\uDE00
 Long.parseLong("1f601", 16) == 128513
 Character.toChars(128513) == char[2] codeChar
 codeChar[0] == \uD83D
 codeChar[1] == \uDE00
 code = String.valueOf(codeChar) == \uD83D\uDE00



每个类都会自带一个无参数的构造方法
如果一个类创建一个带参数的构造方法，那么他的子类如果重写该类的带参数构造方法，那么必须在该构造方法的第一行调用该构造方法的super

子类继承父类，一定会调用父类的构造方法，如果没有在代码中写出super调用，那么会调用父类的无参数的构造方法
如果用super指定了其他父类带参数的构造方法，那么不会调用无参数的构造方法


不可以 存在2个方法 同名，参数类型和数量完全相同，只有返回值不同



将一段字符串经过加密之后，转为另外一段字符串，
适用于一段uri，经过加密之后，生成文件名字符串
public static String getFileName (String uri) {
	String fileName = null;
	try {
		// SHA-256 加密
		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
		// string 转为UTF-8格式的字节数组
		messageDigest.update(uri.getBytes("UTF-8"));
		fileName = bytesToHex(messageDigest.digest(), new char[64]);
	} catch (Exception e) {
	} finally {
		return fileName;
	}
}
private static final char[] HEX_CHAR_ARRAY = "0123456789abcdef".toCharArray();
private static String bytesToHex(byte[] bytes, char[] hexChars) {
	int v;
	for (int j = 0; j < bytes.length; j++) {
		v = bytes[j] & 0xFF;
		hexChars[j * 2] = HEX_CHAR_ARRAY[v >>> 4];
		hexChars[j * 2 + 1] = HEX_CHAR_ARRAY[v & 0x0F];
	}
	return new String(hexChars);
}


------------------------------------------------------------------------------


Java 正则表达式
正则表达式定义了字符串的模式。
正则表达式可以用来搜索、编辑或处理文本。
正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。

正则表达式的两个类：
Pattern 类：
pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。
要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。
Matcher 类：
Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。
你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

-----------------
规则：
.  	表示所有的字符，所有的单个字符
?	前面的零 (0) 或一 (1) 个字符或数字，X? X没有出现或者只出现一次
*	前面的零 (0) 或更多个字符或数字，X* X出现0次或更多
+	前面的一 (1) 或更多个字符或数字，X+ X出现1次或更多

^xxx  在开头匹配正则xxx，一般写在开头，没什么用，有写没写效果一致
xxx$  在结尾匹配正则xxx，一般写在末尾，没什么用，有写没写效果一致
^还表示反义，必须在括号内使用
[a-z]字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。
x|y 匹配 x 或 y。例如，'z|food' 匹配"z"或"food"。'(z|f)ood' 匹配"zood"或"food"

圆括号()是组，主要应用在限制多选结构的范围/分组/捕获文本/环视/特殊模式处理
1、(abc|bcd|cde)，表示这一段是abc、bcd、cde三者之一均可，顺序也必须一致
2、(abc)?，表示这一组要么一起出现，要么不出现，出现则按此组内的顺序出现
3、(?:abc)表示找到这样abc这样一组，但不记录，不保存到$变量中，否则可以通过$x取第几个括号所匹配到的项，比如：(aaa)(bbb)(ccc)(?:ddd)(eee)，可以用$1获取(aaa)匹配到的内容，而$3则获取到了(ccc)匹配到的内容，而$4则获取的是由(eee)匹配到的内容，因为前一对括号没有保存变量
4、a(?=bbb) 顺序环视 表示a后面必须紧跟3个连续的b
5、(?i:xxxx) 不区分大小写 (?s:.*) 跨行匹配.可以匹配回车符

方括号是单个匹配，字符集/排除字符集/命名字符集
1、[0-3]，表示找到这一个位置上的字符只能是0到3这四个数字，与(abc|bcd|cde)的作用比较类似，但圆括号可以匹配多个连续的字符，而一对方括号只能匹配单个字符
2、[^0-3]，表示找到这一个位置上的字符只能是除了0到3之外的所有字符
3、[:digit:] 0-9 [:alnum:] A-Za-z0-9

-----------------

规则2：

.*表示 任意长度的所有字符，看实例1/2

\d  任意数字，等同于[0-9],表达式要写 \\d。实例3
Matcher.find()方法是搜索(部分匹配)，是查找输入串中与模式匹配的子串，如果该匹配的串有组还可以使用group()函数。实例3
Matcher.matches()是全部匹配，是将整个输入串与模式匹配，如果要验证一个输入的数据是否为数字类型或其他类型，一般要用matches()。实例3




-----------------

实例：

实例1：
 Pattern pattern = Pattern.compile("Java.*");
 Matcher matcher = pattern.matcher("Java不是人");
 boolean b= matcher.matches(); // 这里返回true


实例2.1：
Pattern p = Pattern.compile(".*runoob.*");
Matcher m = p.matcher("I am noob from runoob.com.");
boolean isMatch = m.matches();  // 这里返回true
实例2.2：
Pattern p = Pattern.compile(".*runoob.*");
Matcher m = p.matcher("I am noob from runoob.com.");
m.group(); // 这里返回"I am noob from runoob.com." 
           // 因为匹配规则是 runoob之前与之后的所有字符，只有原来的输入字符串符合查找规则
       

实例3.1：
String str="The population of 2984444215 is growing";
Pattern p=Pattern.compile("\\d+"); // 查找所有的数字
Matcher m=p.matcher(str);
m.find() //返回true，因为查找到了字符
String result=m.group(); // 这里的返回值是 2984444215

实例3.2.1：
String str="The population of 2984444215 is growing";
Pattern p=Pattern.compile("\\d+"); // 匹配所有的数字
Matcher m=p.matcher(str);
m.matches() //返回false，str这个字符串的整体 不符合匹配规则
实例3.2.2：
String str="2984444215“;
Pattern p=Pattern.compile("\\d+"); // 匹配所有的数字
Matcher m=p.matcher(str);
m.matches() //返回true，str这个字符串全是数字 符合匹配规则


实例4.1，提取字符串：
        String pattern = "【美团网】(.*?)（登录验证码，请完成验证），如非本人操作，请忽略本短信。";
        String content = "【美团网】345208（登录验证码，请完成验证），如非本人操作，请忽略本短信。";
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(content);
        m.groupCount(); // 只找到一个，返回1
        boolean isMatch = m.find();  // 这里返回true
        System.out.print(m.group(1));  // 返回验证码345208



实例4.2，提取字符串：
void main {
        String str = "abc3443abcfgjhgabcgfjabc";
        String rgex = "abc(.*?)abc";

        List<String> list = new ArrayList<String>();
        Pattern pattern = Pattern.compile(rgex);// 匹配的模式
        Matcher m = pattern.matcher(soap);
        while (m.find()) {  // 找到2个
            int i = 1;
            list.add(m.group(i));
            i++;
        }

        System.out.println(list); // 输出两个元素的列表：[3443, gfj]
}

-------------------------------------------------------------------------------------

在String中，一个英文字符占1个字节，而中文字符根据编码的不同所占字节数也不同。
在UTF-8编码下，一个中文字符占3个字节；而使用GBK编码时一个中文字符占2个字节。
测试代码如下：
 public static void main(String[] args) throws UnsupportedEncodingException {
        String str1 = "hello";
        String str2 = "你好abc";

        System.out.println("utf-8编码下'hello'所占的字节数:" + str1.getBytes("utf-8").length);
        System.out.println("gbk编码下'hello'所占的字节数:" + str1.getBytes("gbk").length);

        System.out.println("utf-8编码下'你好abc'所占的字节数:" + str2.getBytes("utf-8").length);
        System.out.println("gbk编码下你好'你好abc'所占的字节数:" + str2.getBytes("gbk").length);
    }

-------------------------------------------------------------------------------------

注解：定义一个类似于接口或者类的.java文件
四种元注解，用于描述 @interface (.class)
@Target
@Retention
@Document
@Inhrited

@Target
修饰使用范围：
ElementType取值：
1.CONSTRUCTOR:用于描述构造器
2.FIELD:用于描述域(域是一种属性，可以是一个类变量，一个对象变量，一个对象方法变量或者是一个函数的参数)
3.LOCAL_VARIABLE:用于描述局部变量
4.METHOD:用于描述方法
5.PACKAGE:用于描述包
6.PARAMETER:用于描述参数
7.TYPE:用于描述类、接口(包括注解类型) 或enum声明

@Retention  表示需要在什么级别保存该注释信息
RetentionPoicy取值
1.SOURCE:在源文件中有效（即源文件保留）
2.CLASS:在class文件中有效（即class保留）
3.RUNTIME:在运行时有效（即运行时保留）
使用RUTIME,注解处理器可以通过反射，获取到该注解的属性值。

@Documented:
用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，
因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。

@Inherited 标记注解，阐述了某个被标注的类型是被继承的。


例0：
一般都是这三个注解构成自定义注解：
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)  
@Documented 

例1：
@Target(ElementType.FIELD)
public @interface Name {  
    String value() default "";  
}

@Target(ElementType.METHOD)
public @interface GetName {  
    String name();
}

@Target(ElementType.TYPE) 
public @interface Person {  
    String PersonName();  
}

例2：
@Name("阿特罗伯斯")  
private String name;  

@GetName(name="apple")  
public String work() {  
    return "work over!";  
}

@Person(PersonName="这是一个有用的工具类")
public class Utility {  
    
    @Name("阿特罗伯斯")  
    private String name; 
  
    @GetName(name="apple")  
    public String work() {  
        return "work over!";  
    }
}  

例3：使用
Class<?> rtClass = Class.forName("com.test.Utility");  // 反射获取 Utility类
// Class<?> rtClass = Utility.class;

Field[] fields = rtClass.getDeclaredFields();   //取到的Field[]只有一个元素，因为Utility只写了 @Name
for (Field field : fields) {
            if (field.isAnnotationPresent(Name.class)) {  
                Name arg0 = field.getAnnotation(Name.class);  
                arg0.value();  // 这个值就是 "阿特罗伯斯"
            }
}

Method[] methods = rtClass.getMethods();  // 取到的Method[]只有一个元素，因为Utility只写了一个方法
boolean c = rtClass.isAnnotationPresent(Person.class);  
 if (b) {  // 判断一下 Utility.class类型是否为 Person.class
    Person p = (Person)rtClass.getAnnotation(Person.class);
    p.PersonName();  // 这个值是 "这是一个有用的工具类"
    for (Method method : methods) {  
       if (method.isAnnotationPresent( GetName.class )) {  
                        GetName g = (GetName)method.getAnnotation(GetName.class);  
                        g.name() // 这个值就是 "apple"
       }  
    }  
}  



















